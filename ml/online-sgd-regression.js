// This file is a part of stdlib. License is Apache-2.0: http://www.apache.org/licenses/LICENSE-2.0
import e from"./../assert/is-array.js";import t from"./../utils/copy.js";import i from"./../utils/define-property.js";import r from"./../assert/is-positive-integer.js";import n from"./../assert/is-boolean.js";import a from"./../utils/define-nonenumerable-read-only-property.js";import o from"./../math/base/special/pow.js";import s from"./../math/base/special/max.js";import l from"./../assert/is-nonnegative-number.js";import p from"./../assert/is-positive-number.js";import u from"./../assert/is-plain-object.js";import m from"./../assert/is-string.js";import c from"./../assert/has-own-property.js";function h(e,t){var i,r=e.length,n=0;for(i=0;i<r;i++)n+=e[i]*t[i];return n}var d=r,v=n,f=a,b=o,g=h,w=1e-11;function y(e){var t;if(this.scale<w){for(t=0;t<this.nWeights;t++)this._data[t]*=this.scale;this.scale=1}if(this.norm*=b(e,2),!(e>0))throw new RangeError("Scaling weight vector by nonpositive value, likely due to too large value of eta * lambda. Value: `"+e+"`");this.scale*=e}function E(e,t){var i,r,n;for(r=0,void 0===t&&(t=1),n=0;n<e.length;n++)i=e[n]*t,r+=this._data[n]*i,this._data[n]=this._data[n]+i/this.scale;this.intercept&&(i=1*t,r+=this._data[n]*i,this._data[n]=this._data[n]+i/this.scale),this.norm+=(g(e,e)+(this.intercept?1:0))*b(t,2)+2*this.scale*r}function j(e){var t,i=0;for(t=0;t<e.length;t++)i+=this._data[t]*e[t];return i+=this.intercept?this._data[t]:0,i*=this.scale}function T(e,t){var i;if(!(this instanceof T))return new T(e,t);if(!d(e))throw new TypeError("invalid argument. First argument `dim` must be a positive integer. Value: `"+e+"`.");if(!v(t))throw new TypeError("invalid argument. Second argument `intercept` must be a boolean primitive. Value: `"+t+"`.");for(this.scale=1,this.norm=0,this.intercept=t,this.nWeights=e+(this.intercept?1:0),this._data=new Array(this.nWeights),i=0;i<this.nWeights;i++)this._data[i]=0}f(T.prototype,"scaleTo",y),f(T.prototype,"add",E),f(T.prototype,"innerProduct",j);var _=s,R=1e-7;function P(e,t,i){var r;t>0&&(r=1-i*t,e.scaleTo(_(r,R)))}var V=P;function k(e,t,i,r,n,a){var o=e.innerProduct(t)-i;V(e,n,r),o>a?e.add(t,-r):o<-a&&e.add(t,+r)}var O=P;function W(e,t,i,r,n){var a=i-e.innerProduct(t);O(e,n,r),e.add(t,r*a)}var F=P;function x(e,t,i,r,n,a){var o=e.innerProduct(t)-i;F(e,n,r),o>a?e.add(t,-r):o<-a?e.add(t,+r):e.add(t,-r*o)}function q(e,t,i){var r,n;switch(r=1,e){case"basic":n=function(){var e=1e3/(r+1e3);return r+=1,e};break;case"constant":n=function(){return r+=1,t};break;case"pegasos":n=function(){var e=1/(i*r);return r+=1,e};break;default:throw new Error("invalid input value. `learningRate` must be either `basic`, `constant` or `pegasos`. Value: `"+e+"`")}return n}var S=.1,A=.02,I=!0,z=.001,B="basic",C="squaredError",D={epsilon:S,eta0:A,intercept:I,lambda:z,learningRate:B,loss:C},G=l.isPrimitive,H=p.isPrimitive,J=n.isPrimitive,K=u,L=m.isPrimitive,M=c;function N(e,t){return K(t)?M(t,"epsilon")&&(e.epsilon=t.epsilon,!H(e.epsilon))?new TypeError("invalid option. `epsilon` option must be a positive number. Option: `"+e.epsilon+"`."):M(t,"eta0")&&(e.eta0=t.eta0,!H(e.eta0))?new TypeError("invalid option. `eta0` option must be a positive number. Option: `"+e.eta0+"`."):M(t,"lambda")&&(e.lambda=t.lambda,!G(e.lambda))?new TypeError("invalid option. `lambda` option must be a nonnegative number. Option: `"+e.lambda+"`."):M(t,"learningRate")&&(e.learningRate=t.learningRate,!L(e.learningRate))?new TypeError("invalid option. `learningRate` option must be a primitive string. Option: `"+e.learningRate+"`."):M(t,"loss")&&(e.loss=t.loss,!L(e.loss))?new TypeError("invalid option. `loss` option must be a primitive string. Option: `"+e.loss+"`."):M(t,"intercept")&&(e.intercept=t.intercept,!J(e.intercept))?new TypeError("invalid option. `intercept` option must be a primitive boolean. Option: `"+e.intercept+"`."):null:new TypeError("invalid argument. Options must be an object. Value: `"+t+"`.")}var Q=e,U=t,X=i,Y=T,Z=k,$=W,ee=x,te=q,ie=D,re=N;function ne(e){var t,i,r,n,a,o,s;if(o=U(ie),arguments.length>0&&(s=re(o,e)))throw s;switch(r=null,o.loss){case"epsilonInsensitive":i=Z;break;case"huber":i=ee;break;case"squaredError":i=$;break;default:throw Error("invalid input value. `loss` option must be either `epsilonInsensitive`, `huber` or `leastSquares`. Value: `"+o.loss+"`")}return n=te(o.learningRate,o.eta0,o.lambda),X(a={},"coefs",{get:function(){var e,t;for(e=new Array(r.nWeights),t=0;t<e.length;t++)e[t]=r._data[t]*r.scale;return e},configurable:!1,enumerable:!1}),a.update=function(e,a){var s;if(r||(r=new Y(e.length,o.intercept),t=o.intercept?r.nWeights-1:r.nWeights),!Q(e)||e.length!==t)throw new TypeError("invalid input value. First argument `x` must be an array of length "+this.nFeatures+". Value: `"+e+"`");s=n(),i(r,e,a,s,o.lambda,o.epsilon)},a.predict=function(e){if(!Q(e)||e.length!==t)throw new TypeError("invalid input value. First argument `x` must be an array of length "+this.nFeatures+". Value: `"+e+"`");return r.innerProduct(e)},a}var ae=ne;export default ae;
//# sourceMappingURL=online-sgd-regression.js.map