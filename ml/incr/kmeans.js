// This file is a part of stdlib. License is Apache-2.0: http://www.apache.org/licenses/LICENSE-2.0
import r from"./../../assert/is-positive-integer.js";import t from"./../../assert/is-matrix-like.js";import e from"./../../assert/is-vector-like.js";import i from"./../../utils/define-nonenumerable-read-only-property.js";import n from"./../../random/base/minstd-shuffle.js";import o from"./../../math/base/special/floor.js";import a from"./../../math/base/special/ln.js";import s from"./../../blas/base/dcopy.js";import f from"./../../array/float64.js";import m from"./../../ndarray/ctor.js";import u from"./../../ndarray/base/ctor.js";import p from"./../../blas/base/gcopy.js";import d from"./../../assert/is-plain-object.js";import c from"./../../assert/has-own-property.js";import l from"./../../assert/is-boolean.js";import v from"./../../assert/is-array-like-object.js";import h from"./../../assert/contains.js";import y from"./../../math/base/special/sqrt.js";import g from"./../../random/sample.js";import w from"./../../random/base/discrete-uniform.js";import b from"./../../random/base/mt19937.js";import j from"./../../constants/math/float64-pinf.js";import E from"./../../stats/incr/mean.js";import T from"./../../stats/incr/meanstdev.js";var z=f,O=m,k=u,x={codegen:!1};function A(r,t,e){return(e?k:O)("float64",2,x)(new z(r*t),[r,t],[t,1],0,"row-major")}var V=p.ndarray;function P(r,t){var e,i,n,o,a,s,f,m,u,p,d;for(u=t.shape[0],p=t.shape[1],e=t.data,i=r.data,n=t.strides[0],o=t.strides[1],a=r.strides[0],s=r.strides[1],f=t.offset,m=r.offset,d=0;d<u;d++)V(p,e,o,f,i,s,m),f+=n,m+=a;return r}var F=f,M=m,q=u,N={codegen:!1};function R(r,t){return(t?q:M)("float64",1,N)(new F(r),[r],[1],0,"row-major")}var S=p.ndarray;function _(r,t){return S(t.shape[0],t.data,t.strides[0],t.offset,r.data,r.strides[0],r.offset),r}var B=["euclidean","correlation","cosine"],L=["forgy","sample","kmeans++"],Y=d,C=c,D=l.isPrimitive,G=v,H=r.isPrimitive,I=h,J=B,K=L;function Q(r,t){if(!Y(t))return new TypeError("invalid argument. Options argument must be an object. Value: `"+t+"`.");if(C(t,"metric")&&(r.metric=t.metric,!I(J,r.metric)))return new TypeError("invalid option. `metric` option must be one of the following: ["+J.join(", ")+"]. Option: `"+r.metric+"`.");if(C(t,"init")){if(!G(t.init))return new TypeError("invalid option. `init` option must be an array-like object. Option: `"+t.init+"`.");if(!I(K,t.init[0]))return new TypeError("invalid option. `init` option method must be one of the following: ["+K.join(", ")+"]. Option: `"+t.init[0]+"`.");if(r.init[0]=t.init[0],t.init.length>1&&(r.init[1]=t.init[1],!H(r.init[1])))return new TypeError("invalid option. First `init` parameter option must be a positive integer. Option: `"+r.init[1]+"`.");if(t.init.length>2&&(r.init[2]=t.init[2],!H(r.init[2])))return new TypeError("invalid option. Second `init` parameter option must be a positive integer. Option: `"+r.init[2]+"`.")}return C(t,"normalize")&&(r.normalize=t.normalize,!D(r.normalize))?new TypeError("invalid option. `normalize` option must be a boolean. Option: `"+r.normalize+"`."):C(t,"copy")&&(r.copy=t.copy,!D(r.copy))?new TypeError("invalid option. `copy` option must be a boolean. Option: `"+r.copy+"`."):(C(t,"seed")&&(r.seed=t.seed),null)}var U=["forgy",1],W=["sample",1],X={forgy:U,sample:W,"kmeans++":["kmeans++",1,1]},Z=y;function $(r,t,e,i){var n,o,a,s;for(o=0,n=i,s=0;s<r;s++)o+=(a=t[n])*a,n+=e;for(o=Z(o),n=i,s=0;s<r;s++)t[n]/=o;return t}var rr=$;function tr(r){var t,e,i,n,o,a,s;for(t=r.data,o=r.shape[0],a=r.shape[1],e=r.strides[0],i=r.strides[1],n=r.offset,s=0;s<o;s++)rr(a,t,i,n),n+=e;return r}function er(r,t,e,i,n,o,a,s,f,m){var u,p,d,c;for(u=i,p=a,d=m,c=0;c<r;c++)t[u]=(t[u]-n[p])/s[d],u+=e,p+=o,d+=f;return t}var ir=er;function nr(r,t){var e,i,n,o,a,s,f;for(e=r.data,a=r.shape[0],s=r.shape[1],i=r.strides[0],n=r.strides[1],o=r.offset,f=0;f<a;f++)ir(s,e,n,o,t,2,0,t,2,1),o+=i;return r}var or=g.factory,ar=s.ndarray;function sr(r,t,e){var i,n,o,a,s,f,m,u,p,d,c;for(p=r.shape[0],d=r.shape[1],n=r.data,f=r.strides[1],m=r.offset,o=t.data,a=t.strides[0],s=t.strides[1],i=[],c=0;c<t.shape[0];c++)i.push(c);for(u=p===i.length?i:or({seed:e,size:p,mutate:!1,replacement:!1})(i),c=0;c<p;c++)ar(d,o,s,a*u[c],n,f,m);return r}var fr=y;function mr(r,t,e,i,n,o,a){var s,f,m,u,p;for(s=i,f=a,u=0,p=0;p<r;p++)u+=(m=t[s]-n[f])*m,s+=e,f+=o;return fr(u)}var ur=mr;function pr(r,t,e,i,n,o,a){var s=ur(r,t,e,i,n,o,a);return s*s}function dr(r,t,e,i,n,o,a){var s,f,m,u;for(s=i,f=a,m=0,u=0;u<r;u++)m+=t[s]*n[f],s+=e,f+=o;return m}var cr=dr;function lr(r,t,e,i,n,o,a){var s=1-cr(r,t,e,i,n,o,a);return s*s}var vr=dr;function hr(r,t,e,i,n,o,a){var s=1-vr(r,t,e,i,n,o,a);return s*s}var yr=w.factory,gr=b.factory,wr=j,br=s.ndarray,jr=pr,Er=lr,Tr=hr;function zr(r,t,e,i,n,o){var a,s,f,m,u;for(m=n.data,a=(f=n.strides[0])*o,s=0,u=0;u<e;u++)r[u]=t(i,m,1,s,m,1,a),s+=f;return r}function Or(r,t,e,i,n){var o,a,s,f,m,u,p,d,c,l,v,h,y,g,w,b,j,E,T,z,O,k,x,A,V,P,F,M;if(A=r.shape[0],f=r.shape[1],d=t.shape[0],h=r.data,j=r.strides[0],E=r.strides[1],T=r.offset,y=t.data,w=t.strides[0],b=t.strides[1],p=gr({seed:n}),s=yr({seed:p()}),p=p.normalized,v="cosine"===e?Er:"correlation"===e?Tr:jr,x=s(0,d-1),1===A)return br(f,y,b,w*x,h,E,T);for(o=[x],z=new Array(f),m=new Array(2*d),g=0,P=0;P<d;P++)m[g]=wr,m[g+1]=0,g+=2;for(u=new Array(d),F=1;F<A;F++){for(zr(z,v,d,f,t,o[F-1]),c=0,g=0,P=0;P<d;P++)z[P]<m[g]?(m[g]=z[P],m[g+1]=F-1,c+=z[P]):c+=m[g],g+=2;for(u[0]=m[0]/c,g=2,P=1;P<d;P++)u[P]=u[P-1]+m[g]/c,g+=2;for(l=wr,O=-1,M=0;M<i;M++){for(x=-1;-1===x;)for(V=p(),P=0;P<d;P++)if(V<u[P]){x=P;break}for(c=0,a=w*x,g=0,P=0;P<d;P++)(k=v(f,y,1,w*P,y,1,a))<m[g]?c+=k:c+=m[g],g+=2;c<l&&(l=c,O=x)}o.push(O)}for(P=0;P<A;P++)br(f,y,b,w*o[P],h,E,T),T+=j;return r}var kr=w.factory,xr=E;function Ar(r,t,e){var i,n,o,a,s,f,m,u,p,d,c,l,v,h,y,g;for(v=r.shape[0],h=r.shape[1],n=r.data,m=r.strides[0],u=r.strides[1],d=r.offset,a=t.data,o=t.shape[0],s=t.strides[0],f=t.strides[1],l=t.offset,i=kr(0,v-1,{seed:e}),p=[],y=0;y<v*h;y++)p.push(xr());for(y=0;y<o;y++){for(c=h*i(),g=0;g<h;g++)p[c+g](a[l+f*g]);l+=s}for(c=0,y=0;y<v;y++){for(g=0;g<h;g++)n[d+u*g]=p[c](),c+=1;d+=m}return r}var Vr=j;function Pr(r,t,e,i,n,o,a,s,f){var m,u,p,d;for(m=Vr,d=0;d<t;d++)(p=r(e,i,1,o,a,s,f))<m&&(m=p,u=d),o+=n;return u}function Fr(r,t,e,i,n,o,a,s){var f,m;for(m=0;m<r;m++)f=e[n],f+=(o[s]-f)/t,e[n]=f,n+=i,s+=a;return e}var Mr=Pr,qr=Fr;function Nr(r,t,e,i,n){var o,a,s,f,m,u,p,d,c,l,v,h;for(l=t.shape[0],o=t.shape[1],f=r.shape[0],a=t.data,m=t.strides[0],s=r.data,u=r.strides[0],d=0,h=0;h<f;h++)p=m*(v=Mr(n,l,o,a,m,0,s,1,d)),c=e.get(v,0)+1,qr(o,c,a,1,p,s,1,d),i(v,n(o,a,1,p,s,1,d)),d+=u}var Rr=p.ndarray,Sr=A,_r=tr,Br=nr,Lr=sr,Yr=Or,Cr=Ar,Dr=Nr;function Gr(r,t,e,i,n,o){var a,s;return s=r.shape[1],function(f){void 0===a&&((a=Sr(o.init[1],s,!0)).count=0);if(a.count<o.init[1]&&(Rr(s,f.data,f.strides[0],f.offset,a.data,a.strides[1],a.strides[0]*a.count),a.count+=1,a.count<o.init[1]))return!1;o.normalize&&("cosine"===o.metric?a=_r(a):"correlation"===o.metric&&(a=Br(a,i())));r="forgy"===o.init[0]?Cr(r,a,o.seed):"sample"===o.init[0]?Lr(r,a,o.seed):Yr(r,a,o.metric,o.init[2],o.seed);return Dr(a,r,t,e,n),!0}}var Hr=y;function Ir(r,t){var e,i;for(e=[],i=0;i<t;i++)e.push(0);return function(t,i){var n,o,a;return a=r.get(t,0)+1,r.set(t,0,a),r.set(t,1,r.get(t,1)+i),o=r.get(t,2),o+=(n=i-o)/a,e[t]+=n*(i-o),r.set(t,2,o),r.set(t,3,Hr(e[t]/(a-1))),r}}var Jr=T,Kr=f;function Qr(r){var t,e,i,n,o;for(2,t=2*(i=new Kr(2*r)).BYTES_PER_ELEMENT,e=[],n=0,o=0;o<r;o++)e.push(Jr(new Kr(i.buffer,n,2))),n+=t;return function(t){var n;if(0===arguments.length)return i;for(n=0;n<r;n++)e[n](t.get(n));return i}}var Ur=r.isPrimitive,Wr=t,Xr=e,Zr=i,$r=n,rt=o,tt=a,et=s,it=A,nt=P,ot=R,at=_,st=Q,ft=X,mt=Gr,ut=Ir,pt=Qr,dt=pr,ct=lr,lt=hr,vt=Pr,ht=Fr,yt=$,gt=tr,wt=er,bt=nr,jt=4;function Et(r,t){var e={};return e.centroids=it(r,t,!1),e.stats=it(r,jt,!1),e}function Tt(){var r,t,e,i,n,o,a,s,f,m,u,p,d,c;if(Wr(arguments[0]))c=arguments[0].shape[0],s=arguments[0].shape[1],t=it(c,s,!0),t=nt(t,arguments[0]),arguments.length>1&&(i=arguments[1],d=!0);else{if(!Ur(arguments[0]))throw new TypeError("invalid argument. First argument must either be a positive integer specifying the number of clusters or a matrix containing initial centroids. Value: `"+arguments[0]+"`.");if(c=arguments[0],!Ur(s=arguments[1]))throw new TypeError("invalid argument. Argument specifying number of dimensions must be a positive integer. Value: `"+s+"`.");arguments.length>2&&(i=arguments[2],d=!0)}if((m={metric:"euclidean",init:ft["kmeans++"].slice(),seed:$r(),normalize:!0,copy:!0}).init[1]=c,m.init[2]=2+rt(tt(c)),d&&(p=st(m,i)))throw p;if(m.init[1]<c)throw new RangeError("invalid option. First `init` parameter option must be greater than or equal to the number of clusters. Options: `"+m.init[1]+"`.");return n=Et(c,s),a=it(c,jt,!0),r=ut(a,c),"cosine"===m.metric?(f=ct,m.copy&&(o=ot(s,!0))):"correlation"===m.metric?(f=lt,m.normalize&&(e=pt(s)),m.copy&&(o=ot(s,!0))):f=dt,void 0===t?(t=it(c,s,!0),u=mt(t,a,r,e,f,m)):nt(n.centroids,t),Zr(l,"seed",m.seed),Zr(l,"predict",v),l;function l(i){var p,d,l,v,h,y,g,w,b,j,E;if(0===arguments.length)return u?null:n;if(!Xr(w=i))throw new TypeError("invalid argument. Must provide a 1-dimensional ndarray. Value: `"+w+"`.");if(w.shape[0]!==s)throw new Error("invalid argument. Vector length must match centroid dimensions. Expected: "+s+". Actual: "+w.shape[0]+".");if(e&&e(w),u){if(!1===u(w))return null;u=void 0}else m.normalize&&("cosine"===m.metric?(m.copy&&(w=at(o,w)),yt(s,w.data,w.strides[0],w.offset)):"correlation"===m.metric&&(m.copy&&(w=at(o,w)),l=e(),wt(s,w.data,w.strides[0],w.offset,l,2,0,l,2,1))),p=t.data,h=t.strides[0],d=w.data,v=w.strides[0],y=w.offset,g=h*(E=vt(f,c,s,p,h,0,d,v,y)),b=a.get(E,0)+1,ht(s,b,p,1,g,d,v,y),j=f(s,p,1,g,d,v,y),r(E,j);return et(t.length,t.data,1,n.centroids.data,1),et(a.length,a.data,1,n.stats.data,1),n}function v(r,i){var n,o,a,p,d,l,v,h,y,g,w;if(arguments.length>1){if(!Xr(r))throw new TypeError("invalid argument. Output argument must be a 1-dimensional ndarray. Value: `"+r+"`.");y=r,h=i}else h=r;if(!Wr(h))throw new TypeError("invalid argument. Must provide a 2-dimensional ndarray. Value: `"+h+"`.");if(h.shape[1]!==s)throw new Error("invalid argument. Number of matrix columns must match centroid dimensions. Expected: "+s+". Actual: "+h.shape[1]+".");if(void 0===y)y=ot(h.shape[0],!1);else if(y.length!==h.shape[0])throw new Error("invalid argument. Output vector length must match the number of data points. Expected: "+h.shape[0]+". Actual: "+y.length+".");if(u)return null;for(a=h.shape[0],m.normalize&&("cosine"===m.metric?(m.copy&&(h=nt(it(a,s,!0),h)),h=gt(h)):"correlation"===m.metric&&(m.copy&&(h=nt(it(a,s,!0),h)),h=bt(h,e()))),o=t.data,l=t.strides[0],n=h.data,p=h.strides[0],d=h.strides[1],v=h.offset,w=0;w<a;w++)g=vt(f,c,s,o,l,0,n,d,v),y.set(w,g),v+=p;return y}}var zt=Tt;export default zt;
//# sourceMappingURL=kmeans.js.map