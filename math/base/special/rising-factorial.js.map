{"version":3,"sources":["@stdlib/math/base/special/rising-factorial/lib/rising_factorial.js","@stdlib/math/base/special/rising-factorial/lib/index.js"],"names":["fallingFactorial","isInteger","__var_0__","isnan","__var_1__","gammaDeltaRatio","__var_2__","risingFactorial","x","n","result","inv","__var_3__","NaN"],"mappings":"0JAsCA,IAOIA,EAPAC,EAAYC,EACZC,EAAQC,EACRC,EAAkBC,EA+CtB,SAASC,EAAiBC,EAAGC,GAC5B,IAAIC,EACAC,EAMJ,OAHMX,IACLA,EAAmBY,GAEfT,EAAOK,KAAQP,EAAWQ,GACvBI,IAEHL,EAAI,GAEHC,EAAI,IACRD,GAAKC,EACLA,GAAKA,EACLE,GAAM,GAEPD,GAAc,EAAFD,GAAQ,EAAM,GAAQT,GAAmBQ,EAAGC,GACnDE,IACJD,EAAS,EAAMA,GAETA,GAEG,IAAND,EACG,EAEG,IAAND,EACCC,EAAI,GACAJ,EAAiBG,EAAE,GAAMC,GAE3B,EAEHD,EAAI,GAAOA,EAAEC,EAAI,GACrBC,EAASL,EAAiB,EAAIG,GAAIC,GACvB,EAAFA,GAASC,EAASA,GAGrB,EAAML,EAAiBG,EAAGC,GClF/B,IAACF,EAAkBL","sourcesContent":["import __var_0__ from '@stdlib/math/base/assert/is-integer';\nimport __var_1__ from '@stdlib/math/base/assert/is-nan';\nimport __var_2__ from '@stdlib/math/base/special/gamma-delta-ratio';\nimport __var_3__ from '@stdlib/math/base/special/falling-factorial';\n/**\n\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*\n*\n* ## Notice\n*\n* The original C++ code and copyright notice are from the [Boost library]{@link http://www.boost.org/doc/libs/1_64_0/boost/math/special_functions/factorials.hpp}. The implementation has been modified for JavaScript.\n*\n* ```text\n* (C) Copyright John Maddock 2006, 2010.\n*\n* Use, modification and distribution are subject to the\n* Boost Software License, Version 1.0. (See accompanying file\n* LICENSE or copy at http://www.boost.org/LICENSE_1_0.txt)\n* ```\n*/\n\n'use strict';\n\n// MODULES //\nvar isInteger = __var_0__;\nvar isnan = __var_1__;\nvar gammaDeltaRatio = __var_2__;\n\n\n// VARIABLES //\n\nvar fallingFactorial;\n\n\n// MAIN //\n\n/**\n* Computes the rising factorial of `x` and `n`.\n*\n* ## Notes\n*\n* -   The rising factorial is defined as\n*\n*     ```tex\n*     \\operatorname{risingFactorial}(x, n) = x (x-1) (x-2) (x-3) \\ldots (x-n+1)\n*     ```\n*\n*     or equivalently\n*\n*     ```tex\n*     \\operatorname{risingFactorial}(x, n) = \\frac{ \\Gamma(x + n) }{ \\Gamma(x) };\n*     ```\n*\n* @param {number} x - first function parameter\n* @param {integer} n - second function parameter\n* @returns {number} function value\n*\n* @example\n* var v = risingFactorial( 0.9, 5 );\n* // returns ~94.766\n*\n* @example\n* var v = risingFactorial( -9.0, 3 );\n* // returns -504.0\n*\n* @example\n* var v = risingFactorial( 0.0, 2 );\n* // returns 0.0\n*\n* @example\n* var v = risingFactorial( 3.0, -2 );\n* // returns 0.5\n*/\nfunction risingFactorial( x, n ) {\n\tvar result;\n\tvar inv;\n\n\t// Lazy-load to avoid undefined reference due to circular dependency...\n\tif ( !fallingFactorial ) {\n\t\tfallingFactorial = __var_3__;\n\t}\n\tif ( isnan( x ) || !isInteger( n ) ) {\n\t\treturn NaN;\n\t}\n\tif ( x < 0.0 ) {\n\t\t// For `x < 0`, we really have a falling factorial, modulo a possible change of sign. Note that the falling factorial isn't defined for negative `n`, so we'll get rid of that case first:\n\t\tif ( n < 0.0 ) {\n\t\t\tx += n;\n\t\t\tn = -n;\n\t\t\tinv = true;\n\t\t}\n\t\tresult = ( (n&1) ? -1.0 : 1.0 ) * fallingFactorial( -x, n );\n\t\tif ( inv ) {\n\t\t\tresult = 1.0 / result;\n\t\t}\n\t\treturn result;\n\t}\n\tif ( n === 0 ) {\n\t\treturn 1.0;\n\t}\n\tif ( x === 0.0 ) {\n\t\tif ( n < 0 ) {\n\t\t\treturn -gammaDeltaRatio( x+1.0, -n );\n\t\t}\n\t\treturn 0.0;\n\t}\n\tif ( x < 1.0 && x+n < 0.0 ) {\n\t\tresult = gammaDeltaRatio( 1.0-x, -n );\n\t\treturn ( n&1 ) ? -result : result;\n\t}\n\t// We don't optimize this for small `n`, because `gammaDeltaRatio` is already optimized for that use case:\n\treturn 1.0 / gammaDeltaRatio( x, n );\n}\n\n\n// EXPORTS //\nexport default risingFactorial;\n","import __var_0__ from './rising_factorial.js';\n/**\n\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n/**\n* Compute the rising factorial.\n*\n* @module @stdlib/math/base/special/rising-factorial\n*\n* @example\n* var risingFactorial = require( '@stdlib/math/base/special/rising-factorial' );\n*\n* var v = risingFactorial( 0.9, 5 );\n* // returns ~94.766\n*\n* v = risingFactorial( -9.0, 3 );\n* // returns -504.0\n*\n* v = risingFactorial( 0.0, 2 );\n* // returns 0.0\n*\n* v = risingFactorial( 3.0, -2 );\n* // returns 0.5\n*/\n\n// MODULES //\nvar risingFactorial = __var_0__;\n\n\n// EXPORTS //\nexport default risingFactorial;\n"]}