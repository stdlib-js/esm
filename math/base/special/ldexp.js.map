{"version":3,"sources":["@stdlib/math/base/special/ldexp/lib/ldexp.js","@stdlib/math/base/special/ldexp/lib/index.js"],"names":["PINF","__var_0__","NINF","__var_1__","BIAS","__var_2__","MAX_EXPONENT","__var_3__","MAX_SUBNORMAL_EXPONENT","__var_4__","MIN_SUBNORMAL_EXPONENT","__var_5__","isnan","__var_6__","isInfinite","__var_7__","copysign","__var_8__","normalize","__var_9__","floatExp","__var_10__","toWords","__var_11__","fromWords","__var_12__","TWO52_INV","CLEAR_EXP_MASK","FRAC","WORDS","ldexp","frac","exp","high","m"],"mappings":"ovBAyCA,IAAIA,EAAOC,EACPC,EAAOC,EACPC,EAAOC,EACPC,EAAeC,EACfC,EAAyBC,EACzBC,EAAyBC,EACzBC,EAAQC,EACRC,EAAaC,EACbC,EAAWC,EACXC,EAAYC,EACZC,EAAWC,EACXC,EAAUC,EACVC,EAAYC,EAMZC,EAAY,qBAGZC,EAAiB,WAGjBC,EAAO,CAAE,EAAK,GAGdC,EAAQ,CAAE,EAAG,GAwCjB,SAASC,EAAOC,EAAMC,GACrB,IAAIC,EACAC,EACJ,OACU,IAATH,GACAnB,EAAOmB,IACPjB,EAAYiB,GAELA,GAGRb,EAAWU,EAAMG,GACjBA,EAAOH,EAAM,GACbI,GAAOJ,EAAM,IAGbI,GAAOZ,EAAUW,IAGNrB,EACHM,EAAU,EAAKe,GAElBC,EAAM1B,EACLyB,EAAO,EACJ7B,EAEDF,GAGHgC,GAAOxB,GACXwB,GAAO,GACPE,EAAIR,GAEJQ,EAAI,EAGLZ,EAASO,EAAOE,GAChBE,EAAOJ,EAAO,GAGdI,GAAQN,EAMDO,EAAIV,EAHXS,GAAUD,EAAI5B,GAAS,GAGKyB,EAAO,MCtGjC,IAACC,EAAQ7B","sourcesContent":["import __var_0__ from '@stdlib/constants/math/float64-pinf';\nimport __var_1__ from '@stdlib/constants/math/float64-ninf';\nimport __var_2__ from '@stdlib/constants/math/float64-exponent-bias';\nimport __var_3__ from '@stdlib/constants/math/float64-max-base2-exponent';\nimport __var_4__ from '@stdlib/constants/math/float64-max-base2-exponent-subnormal';\nimport __var_5__ from '@stdlib/constants/math/float64-min-base2-exponent-subnormal';\nimport __var_6__ from '@stdlib/math/base/assert/is-nan';\nimport __var_7__ from '@stdlib/math/base/assert/is-infinite';\nimport __var_8__ from '@stdlib/math/base/special/copysign';\nimport __var_9__ from '@stdlib/number/float64/base/normalize';\nimport __var_10__ from '@stdlib/number/float64/base/exponent';\nimport __var_11__ from '@stdlib/number/float64/base/to-words';\nimport __var_12__ from '@stdlib/number/float64/base/from-words';\n/**\n\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// NOTES //\n\n/*\n* => ldexp: load exponent (see [The Open Group]{@link http://pubs.opengroup.org/onlinepubs/9699919799/functions/ldexp.html} and [cppreference]{@link http://en.cppreference.com/w/c/numeric/math/ldexp}).\n*/\n\n\n// MODULES //\nvar PINF = __var_0__;\nvar NINF = __var_1__;\nvar BIAS = __var_2__;\nvar MAX_EXPONENT = __var_3__;\nvar MAX_SUBNORMAL_EXPONENT = __var_4__;\nvar MIN_SUBNORMAL_EXPONENT = __var_5__;\nvar isnan = __var_6__;\nvar isInfinite = __var_7__;\nvar copysign = __var_8__;\nvar normalize = __var_9__;\nvar floatExp = __var_10__;\nvar toWords = __var_11__;\nvar fromWords = __var_12__;\n\n\n// VARIABLES //\n\n// 1/(1<<52) = 1/(2**52) = 1/4503599627370496\nvar TWO52_INV = 2.220446049250313e-16;\n\n// Exponent all 0s: 1 00000000000 11111111111111111111 => 2148532223\nvar CLEAR_EXP_MASK = 0x800fffff>>>0; // asm type annotation\n\n// Normalization workspace:\nvar FRAC = [ 0.0, 0.0 ]; // WARNING: not thread safe\n\n// High/low words workspace:\nvar WORDS = [ 0, 0 ]; // WARNING: not thread safe\n\n\n// MAIN //\n\n/**\n* Multiplies a double-precision floating-point number by an integer power of two.\n*\n* @param {number} frac - fraction\n* @param {integer} exp - exponent\n* @returns {number} double-precision floating-point number\n*\n* @example\n* var x = ldexp( 0.5, 3 ); // => 0.5 * 2^3 = 0.5 * 8\n* // returns 4.0\n*\n* @example\n* var x = ldexp( 4.0, -2 ); // => 4 * 2^(-2) = 4 * (1/4)\n* // returns 1.0\n*\n* @example\n* var x = ldexp( 0.0, 20 );\n* // returns 0.0\n*\n* @example\n* var x = ldexp( -0.0, 39 );\n* // returns -0.0\n*\n* @example\n* var x = ldexp( NaN, -101 );\n* // returns NaN\n*\n* @example\n* var x = ldexp( Infinity, 11 );\n* // returns Infinity\n*\n* @example\n* var x = ldexp( -Infinity, -118 );\n* // returns -Infinity\n*/\nfunction ldexp( frac, exp ) {\n\tvar high;\n\tvar m;\n\tif (\n\t\tfrac === 0.0 || // handles +-0\n\t\tisnan( frac ) ||\n\t\tisInfinite( frac )\n\t) {\n\t\treturn frac;\n\t}\n\t// Normalize the input fraction:\n\tnormalize( FRAC, frac );\n\tfrac = FRAC[ 0 ];\n\texp += FRAC[ 1 ];\n\n\t// Extract the exponent from `frac` and add it to `exp`:\n\texp += floatExp( frac );\n\n\t// Check for underflow/overflow...\n\tif ( exp < MIN_SUBNORMAL_EXPONENT ) {\n\t\treturn copysign( 0.0, frac );\n\t}\n\tif ( exp > MAX_EXPONENT ) {\n\t\tif ( frac < 0.0 ) {\n\t\t\treturn NINF;\n\t\t}\n\t\treturn PINF;\n\t}\n\t// Check for a subnormal and scale accordingly to retain precision...\n\tif ( exp <= MAX_SUBNORMAL_EXPONENT ) {\n\t\texp += 52;\n\t\tm = TWO52_INV;\n\t} else {\n\t\tm = 1.0;\n\t}\n\t// Split the fraction into higher and lower order words:\n\ttoWords( WORDS, frac );\n\thigh = WORDS[ 0 ];\n\n\t// Clear the exponent bits within the higher order word:\n\thigh &= CLEAR_EXP_MASK;\n\n\t// Set the exponent bits to the new exponent:\n\thigh |= ((exp+BIAS) << 20);\n\n\t// Create a new floating-point number:\n\treturn m * fromWords( high, WORDS[ 1 ] );\n}\n\n\n// EXPORTS //\nexport default ldexp;\n","import __var_0__ from './ldexp.js';\n/**\n\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n/**\n* Multiply a double-precision floating-point number by an integer power of two.\n*\n* @module @stdlib/math/base/special/ldexp\n*\n* @example\n* var ldexp = require( '@stdlib/math/base/special/ldexp' );\n*\n* var x = ldexp( 0.5, 3 ); // => 0.5 * 2^3 = 0.5 * 8\n* // returns 4.0\n*\n* x = ldexp( 4.0, -2 ); // => 4 * 2^(-2) = 4 * (1/4)\n* // returns 1.0\n*\n* x = ldexp( 0.0, 20 );\n* // returns 0.0\n*\n* x = ldexp( -0.0, 39 );\n* // returns -0.0\n*\n* x = ldexp( NaN, -101 );\n* // returns NaN\n*\n* x = ldexp( Infinity, 11 );\n* // returns Infinity\n*\n* x = ldexp( -Infinity, -118 );\n* // returns -Infinity\n*/\n\n// MODULES //\nvar ldexp = __var_0__;\n\n\n// EXPORTS //\nexport default ldexp;\n"]}