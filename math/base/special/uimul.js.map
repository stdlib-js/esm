{"version":3,"sources":["@stdlib/math/base/special/uimul/lib/main.js","@stdlib/math/base/special/uimul/lib/index.js"],"names":["LOW_WORD_MASK","uimul","a","b","la","lb","__var_0__"],"mappings":"AAwBA,IAAIA,EAAgB,MA+EpB,SAASC,EAAOC,EAAGC,GAClB,IAIIC,EACAC,EAkBJ,QARAD,IARAF,KAAO,GAQEF,KAAkB,IAC3BK,IARAF,KAAO,GAQEH,KAAkB,KAGP,KARbE,IAAI,KAAO,GASHG,EAAOD,GARfD,IAAI,KAAO,IAQa,KAAO,KAGX,EC7FzB,IAACF,EAAQK","sourcesContent":["\n/**\n\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// VARIABLES //\n\n// Define a mask for the least significant 16 bits (low word): 65535 => 0x0000ffff => 00000000000000001111111111111111\nvar LOW_WORD_MASK = 0x0000ffff>>>0; // asm type annotation\n\n\n// MAIN //\n\n/**\n* Performs C-like multiplication of two unsigned 32-bit integers.\n*\n* ## Method\n*\n* -   To emulate C-like multiplication without the aid of 64-bit integers, we recognize that a 32-bit integer can be split into two 16-bit words\n*\n*     ```tex\n*     a = w_h*2^{16} + w_l\n*     ```\n*\n*     where \\\\( w_h \\\\) is the most significant 16 bits and \\\\( w_l \\\\) is the least significant 16 bits. For example, consider the maximum unsigned 32-bit integer \\\\( 2^{32}-1 \\\\)\n*\n*     ```binarystring\n*     11111111111111111111111111111111\n*     ```\n*\n*     The 16-bit high word is then\n*\n*     ```binarystring\n*     1111111111111111\n*     ```\n*\n*     and the 16-bit low word\n*\n*     ```binarystring\n*     1111111111111111\n*     ```\n*\n*     If we cast the high word to 32-bit precision and multiply by \\\\( 2^{16} \\\\) (equivalent to a 16-bit left shift), then the bit sequence is\n*\n*     ```binarystring\n*     11111111111111110000000000000000\n*     ```\n*\n*     Similarly, upon casting the low word to 32-bit precision, the bit sequence is\n*\n*     ```binarystring\n*     00000000000000001111111111111111\n*     ```\n*\n*     From the rules of binary addition, we recognize that adding the two 32-bit values for the high and low words will return our original value \\\\( 2^{32}-1 \\\\).\n*\n* -   Accordingly, the multiplication of two 32-bit integers can be expressed\n*\n*     ```tex\n*     \\begin{align*}\n*     a \\cdot b &= ( a_h \\cdot 2^{16} + a_l) \\cdot ( b_h \\cdot 2^{16} + b_l) \\\\\n*           &= a_l \\cdot b_l + a_h \\cdot b_l \\cdot 2^{16} + a_l \\cdot b_h \\cdot 2^{16} + (a_h \\cdot b_h) \\cdot 2^{32} \\\\\n*           &= a_l \\cdot b_l + (a_h \\cdot b_l + a_l \\cdot b_h) \\cdot 2^{16} + (a_h \\cdot b_h) \\cdot 2^{32}\n*     \\end{align*}\n*     ```\n*\n* -   We note that multiplying (dividing) an integer by \\\\( 2^n \\\\) is equivalent to performing a left (right) shift of \\\\( n \\\\) bits.\n*\n* -   Further, as we want to return an integer of the same precision, for a 32-bit integer, the return value will be modulo \\\\( 2^{32} \\\\). Stated another way, we only care about the low word of a 64-bit result.\n*\n* -   Accordingly, the last term, being evenly divisible by \\\\( 2^{32} \\\\), drops from the equation leaving the remaining two terms as the remainder.\n*\n*     ```tex\n*     a \\cdot b = a_l \\cdot b_l + (a_h \\cdot b_l + a_l \\cdot b_h) << 16\n*     ```\n*\n* -   Lastly, the second term in the above equation contributes to the middle bits and may cause the product to \"overflow\". However, we can disregard (`>>>0`) overflow bits due modulo arithmetic, as discussed earlier with regard to the term involving the partial product of high words.\n*\n*\n* @param {uinteger32} a - integer\n* @param {uinteger32} b - integer\n* @returns {uinteger32} product\n*\n* @example\n* var v = uimul( 10>>>0, 4>>>0 );\n* // returns 40\n*/\nfunction uimul( a, b ) {\n\tvar lbits;\n\tvar mbits;\n\tvar ha;\n\tvar hb;\n\tvar la;\n\tvar lb;\n\n\ta >>>= 0; // asm type annotation\n\tb >>>= 0; // asm type annotation\n\n\t// Isolate the most significant 16-bits:\n\tha = ( a>>>16 )>>>0; // asm type annotation\n\thb = ( b>>>16 )>>>0; // asm type annotation\n\n\t// Isolate the least significant 16-bits:\n\tla = ( a&LOW_WORD_MASK )>>>0; // asm type annotation\n\tlb = ( b&LOW_WORD_MASK )>>>0; // asm type annotation\n\n\t// Compute partial sums:\n\tlbits = ( la*lb )>>>0; // asm type annotation; no integer overflow possible\n\tmbits = ( ((ha*lb) + (la*hb))<<16 )>>>0; // asm type annotation; possible integer overflow\n\n\t// The final `>>>0` converts the intermediate sum to an unsigned integer (possible integer overflow during sum):\n\treturn ( lbits + mbits )>>>0; // asm type annotation\n}\n\n\n// EXPORTS //\nexport default uimul;\n","import __var_0__ from './main.js';\n/**\n\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n/**\n* Perform C-like multiplication of two unsigned 32-bit integers.\n*\n* @module @stdlib/math/base/special/uimul\n*\n* @example\n* var uimul = require( '@stdlib/math/base/special/uimul' );\n*\n* var v = uimul( 10>>>0, 4>>>0 );\n* // returns 40\n*/\n\n// MODULES //\nvar uimul = __var_0__;\n\n\n// EXPORTS //\nexport default uimul;\n"]}