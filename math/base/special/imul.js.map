{"version":3,"sources":["@stdlib/math/base/special/imul/lib/main.js","@stdlib/math/base/special/imul/lib/polyfill.js","@stdlib/math/base/special/imul/lib/index.js"],"names":["imul","Math","LOW_WORD_MASK","a","b","la","lb","__var_0__","polyfill","__var_1__","imul$3"],"mappings":"AAuBA,IAAIA,EAA8B,mBAAdC,KAAKD,KAAwBC,KAAKD,KAAO,KCCzDE,EAAgB,MA+EpB,SAASF,EAAMG,EAAGC,GACjB,IAIIC,EACAC,EAkBJ,QARAD,IARAF,GAAK,GAQID,KAAkB,IAC3BI,IARAF,GAAK,GAQIF,KAAkB,KAGP,KARbC,IAAI,KAAO,GASHG,EAAOD,GARfD,IAAI,KAAO,IAQa,KAAO,GAGb,EC5F1B,IAAIJ,EAAOO,EACPC,EAAWC,EAKM,mBAATT,IACXA,EAAOQ,GAKR,IAAAE,EAAeV","sourcesContent":["\n/**\n\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MAIN //\n\nvar imul = ( typeof Math.imul === 'function' ) ? Math.imul : null; // eslint-disable-line stdlib/no-builtin-math\n\n\n// EXPORTS //\nexport default imul;\n","\n/**\n\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// VARIABLES //\n\n// Define a mask for the least significant 16 bits (low word): 65535 => 0x0000ffff => 00000000000000001111111111111111\nvar LOW_WORD_MASK = 0x0000ffff>>>0; // asm type annotation\n\n\n// MAIN //\n\n/**\n* Performs C-like multiplication of two signed 32-bit integers.\n*\n* ## Method\n*\n* -   To emulate C-like multiplication without the aid of 64-bit integers, we recognize that a 32-bit integer can be split into two 16-bit words\n*\n*     ```tex\n*     a = w_h*2^{16} + w_l\n*     ```\n*\n*     where \\\\( w_h \\\\) is the most significant 16 bits and \\\\( w_l \\\\) is the least significant 16 bits. For example, consider the maximum signed 32-bit integer \\\\( 2^{31}-1 \\\\)\n*\n*     ```binarystring\n*     01111111111111111111111111111111\n*     ```\n*\n*     The 16-bit high word is then\n*\n*     ```binarystring\n*     0111111111111111\n*     ```\n*\n*     and the 16-bit low word\n*\n*     ```binarystring\n*     1111111111111111\n*     ```\n*\n*     If we cast the high word to 32-bit precision and multiply by \\\\( 2^{16} \\\\) (equivalent to a 16-bit left shift), then the bit sequence is\n*\n*     ```binarystring\n*     01111111111111110000000000000000\n*     ```\n*\n*     Similarly, upon casting the low word to 32-bit precision, the bit sequence is\n*\n*     ```binarystring\n*     00000000000000001111111111111111\n*     ```\n*\n*     From the rules of binary addition, we recognize that adding the two 32-bit values for the high and low words will return our original value \\\\( 2^{31}-1 \\\\).\n*\n* -   Accordingly, the multiplication of two 32-bit integers can be expressed\n*\n*     ```tex\n*     \\begin{align*}\n*     a \\cdot b &= ( a_h \\cdot 2^{16} + a_l) \\cdot ( b_h \\cdot 2^{16} + b_l) \\\\\n*           &= a_l \\cdot b_l + a_h \\cdot b_l \\cdot 2^{16} + a_l \\cdot b_h \\cdot 2^{16} + (a_h \\cdot b_h) \\cdot 2^{32} \\\\\n*           &= a_l \\cdot b_l + (a_h \\cdot b_l + a_l \\cdot b_h) \\cdot 2^{16} + (a_h \\cdot b_h) \\cdot 2^{32}\n*     \\end{align*}\n*     ```\n*\n* -   We note that multiplying (dividing) an integer by \\\\( 2^n \\\\) is equivalent to performing a left (right) shift of \\\\( n \\\\) bits.\n*\n* -   Further, as we want to return an integer of the same precision, for a 32-bit integer, the return value will be modulo \\\\( 2^{32} \\\\). Stated another way, we only care about the low word of a 64-bit result.\n*\n* -   Accordingly, the last term, being evenly divisible by \\\\( 2^{32} \\\\), drops from the equation leaving the remaining two terms as the remainder.\n*\n*     ```tex\n*     a \\cdot b = a_l \\cdot b_l + (a_h \\cdot b_l + a_l \\cdot b_h) << 16\n*     ```\n*\n* -   Lastly, the second term in the above equation contributes to the middle bits and may cause the product to \"overflow\". However, we can disregard (`>>>0`) overflow bits due modulo arithmetic, as discussed earlier with regard to the term involving the partial product of high words.\n*\n*\n* @param {integer32} a - integer\n* @param {integer32} b - integer\n* @returns {integer32} product\n*\n* @example\n* var v = imul( -10|0, 4|0 );\n* // returns -40\n*/\nfunction imul( a, b ) {\n\tvar lbits;\n\tvar mbits;\n\tvar ha;\n\tvar hb;\n\tvar la;\n\tvar lb;\n\n\ta |= 0; // asm type annotation\n\tb |= 0; // asm type annotation\n\n\t// Isolate the most significant 16-bits:\n\tha = ( a>>>16 )>>>0; // asm type annotation\n\thb = ( b>>>16 )>>>0; // asm type annotation\n\n\t// Isolate the least significant 16-bits:\n\tla = ( a&LOW_WORD_MASK )>>>0; // asm type annotation\n\tlb = ( b&LOW_WORD_MASK )>>>0; // asm type annotation\n\n\t// Shift by zero (`>>>0`) sets the sign on the high part of the low word (i.e., \"mid-bits\"):\n\tlbits = ( la*lb )>>>0; // asm type annotation; no integer overflow possible\n\tmbits = ( ((ha*lb) + (la*hb))<<16 )>>>0; // asm type annotation; possible integer overflow\n\n\t// The final `|0` converts from an \"unsigned integer\" (possible integer overflow during sum) to a signed integer:\n\treturn ( lbits + mbits )|0; // asm type annotation\n}\n\n\n// EXPORTS //\nexport default imul;\n","import __var_0__ from './main.js';\nimport __var_1__ from './polyfill.js';\n/**\n\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n/**\n* Perform C-like multiplication of two signed 32-bit integers.\n*\n* @module @stdlib/math/base/special/imul\n*\n* @example\n* var imul = require( '@stdlib/math/base/special/imul' );\n*\n* var v = imul( -10|0, 4|0 );\n* // returns -40\n*/\n\n// MODULES //\nvar imul = __var_0__;\nvar polyfill = __var_1__;\n\n\n// MAIN //\n\nif ( typeof imul !== 'function' ) {\n\timul = polyfill;\n}\n\n\n// EXPORTS //\nexport default imul;\n"]}