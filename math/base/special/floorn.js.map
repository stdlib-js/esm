{"version":3,"sources":["@stdlib/math/base/special/floorn/lib/floorn.js","@stdlib/math/base/special/floorn/lib/index.js"],"names":["isnan","__var_0__","isInfinite","__var_1__","pow","__var_2__","abs","__var_3__","floor","__var_4__","MAX_SAFE_INTEGER","__var_5__","MAX_EXP","__var_6__","MIN_EXP","__var_7__","MIN_EXP_SUBNORMAL","__var_8__","NINF","__var_9__","MAX_INT","HUGE","floorn","x","n","s","y","NaN"],"mappings":"yfA+BA,IAAIA,EAAQC,EACRC,EAAaC,EACbC,EAAMC,EACNC,EAAMC,EACNC,EAAQC,EACRC,EAAmBC,EACnBC,EAAUC,EACVC,EAAUC,EACVC,EAAoBC,EACpBC,EAAOC,EAKPC,EAAUV,EAAmB,EAC7BW,EAAO,MA6EX,SAASC,EAAQC,EAAGC,GACnB,IAAIC,EACAC,EACJ,OACC1B,EAAOuB,IACPvB,EAAOwB,IACPtB,EAAYsB,GAELG,IAIPzB,EAAYqB,IAGN,IAANA,GAGAC,EAAIR,GAGFV,EAAKiB,GAAMH,GAAWI,GAAK,EAEtBD,EAGHC,EAAIZ,EACHW,GAAK,EACF,EAEDL,EAGHM,EAAIV,GACRW,EAAIrB,EAAK,KAAQoB,EAAIZ,IAEhBV,EADLwB,EAAKH,EAAEF,EAAQI,GAEPF,EAECf,EAAMkB,GAAGL,EAASI,IAE5BA,EAAIrB,EAAK,IAAOoB,GAEXtB,EADLwB,EAAIH,EAAIE,GAEAF,EAEDf,EAAOkB,GAAMD,GC9HlB,IAACH,EAASrB","sourcesContent":["import __var_0__ from '@stdlib/math/base/assert/is-nan';\nimport __var_1__ from '@stdlib/math/base/assert/is-infinite';\nimport __var_2__ from '@stdlib/math/base/special/pow';\nimport __var_3__ from '@stdlib/math/base/special/abs';\nimport __var_4__ from '@stdlib/math/base/special/floor';\nimport __var_5__ from '@stdlib/constants/math/float64-max-safe-integer';\nimport __var_6__ from '@stdlib/constants/math/float64-max-base10-exponent';\nimport __var_7__ from '@stdlib/constants/math/float64-min-base10-exponent';\nimport __var_8__ from '@stdlib/constants/math/float64-min-base10-exponent-subnormal';\nimport __var_9__ from '@stdlib/constants/math/float64-ninf';\n/**\n\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\nvar isnan = __var_0__;\nvar isInfinite = __var_1__;\nvar pow = __var_2__;\nvar abs = __var_3__;\nvar floor = __var_4__;\nvar MAX_SAFE_INTEGER = __var_5__;\nvar MAX_EXP = __var_6__;\nvar MIN_EXP = __var_7__;\nvar MIN_EXP_SUBNORMAL = __var_8__;\nvar NINF = __var_9__;\n\n\n// VARIABLES //\n\nvar MAX_INT = MAX_SAFE_INTEGER + 1;\nvar HUGE = 1.0e+308;\n\n\n// MAIN //\n\n/**\n* Rounds a numeric value to the nearest multiple of \\\\(10^n\\\\) toward negative infinity.\n*\n* ## Method\n*\n* 1.  If \\\\(|x| <= 2^{53}\\\\) and \\\\(|n| <= 308\\\\), we can use the formula\n*\n*     ```tex\n*     \\operatorname{floorn}(x,n) = \\frac{\\operatorname{floor}(x \\cdot 10^{-n})}{10^{-n}}\n*     ```\n*\n*     which shifts the decimal to the nearest multiple of \\\\(10^n\\\\), performs a standard \\\\(\\mathrm{floor}\\\\) operation, and then shifts the decimal to its original position.\n*\n*     <!-- <note> -->\n*\n*     If \\\\(x \\cdot 10^{-n}\\\\) overflows, \\\\(x\\\\) lacks a sufficient number of decimal digits to have any effect when rounding. Accordingly, the rounded value is \\\\(x\\\\).\n*\n*     <!-- </note> -->\n*\n*     <!-- <note> -->\n*\n*     Note that rescaling \\\\(x\\\\) can result in unexpected behavior. For instance, the result of \\\\(\\operatorname{floorn}(-0.2-0.1,-16)\\\\) is \\\\(-0.3000000000000001\\\\) and not \\\\(-0.3\\\\). While possibly unexpected, this is not a bug. The behavior stems from the fact that most decimal fractions cannot be exactly represented as floating-point numbers. And further, rescaling can lead to slightly different fractional values, which, in turn, affects the result of \\\\(\\mathrm{floor}\\\\).\n*\n*     <!-- </note> -->\n*\n* 2.  If \\\\(n > 308\\\\), we recognize that the maximum absolute double-precision floating-point number is \\\\(\\approx 1.8\\mbox{e}308\\\\) and, thus, the result of rounding any possible negative finite number \\\\(x\\\\) to the nearest \\\\(10^n\\\\) is \\\\(-\\infty\\\\) and any possible positive finite number \\\\(x\\\\) is \\\\(+0\\\\). To ensure consistent behavior with \\\\(\\operatorname{floor}(x)\\\\), if \\\\(x > 0\\\\), the sign of \\\\(x\\\\) is preserved.\n*\n* 3.  If \\\\(n < -324\\\\), \\\\(n\\\\) exceeds the maximum number of possible decimal places (such as with subnormal numbers), and, thus, the rounded value is \\\\(x\\\\).\n*\n* 4.  If \\\\(x > 2^{53}\\\\), \\\\(x\\\\) is **always** an integer (i.e., \\\\(x\\\\) has no decimal digits). If \\\\(n <= 0\\\\), the rounded value is \\\\(x\\\\).\n*\n* 5.  If \\\\(n < -308\\\\), we let \\\\(m = n + 308\\\\) and modify the above formula to avoid overflow.\n*\n*     ```tex\n*     \\operatorname{floorn}(x,n) = \\frac{\\biggl(\\frac{\\operatorname{floor}( (x \\cdot 10^{308}) 10^{-m})}{10^{308}}\\biggr)}{10^{-m}}\n*     ```\n*\n*     If overflow occurs, the rounded value is \\\\(x\\\\).\n*\n*\n* ## Special Cases\n*\n* ```tex\n* \\begin{align*}\n* \\operatorname{floorn}(\\mathrm{NaN}, n) &= \\mathrm{NaN} \\\\\n* \\operatorname{floorn}(x, \\mathrm{NaN}) &= \\mathrm{NaN} \\\\\n* \\operatorname{floorn}(x, \\pm\\infty) &= \\mathrm{NaN} \\\\\n* \\operatorname{floorn}(\\pm\\infty, n) &= \\pm\\infty \\\\\n* \\operatorname{floorn}(\\pm 0, n) &= \\pm 0\n* \\end{align*}\n* ```\n*\n*\n* @param {number} x - input value\n* @param {integer} n - integer power of 10\n* @returns {number} rounded value\n*\n* @example\n* // Round a value to 4 decimal places:\n* var v = floorn( 3.141592653589793, -4 );\n* // returns 3.1415\n*\n* @example\n* // If n = 0, `floorn` behaves like `floor`:\n* var v = floorn( 3.141592653589793, 0 );\n* // returns 3.0\n*\n* @example\n* // Round a value to the nearest thousand:\n* var v = floorn( 12368.0, 3 );\n* // returns 12000.0\n*/\nfunction floorn( x, n ) {\n\tvar s;\n\tvar y;\n\tif (\n\t\tisnan( x ) ||\n\t\tisnan( n ) ||\n\t\tisInfinite( n )\n\t) {\n\t\treturn NaN;\n\t}\n\tif (\n\t\t// Handle infinities...\n\t\tisInfinite( x ) ||\n\n\t\t// Handle +-0...\n\t\tx === 0.0 ||\n\n\t\t// If `n` exceeds the maximum number of feasible decimal places (such as with subnormal numbers), nothing to round...\n\t\tn < MIN_EXP_SUBNORMAL ||\n\n\t\t// If `|x|` is large enough, no decimals to round...\n\t\t( abs( x ) > MAX_INT && n <= 0 )\n\t) {\n\t\treturn x;\n\t}\n\t// The maximum absolute double is ~1.8e308. Accordingly, any possible positive finite `x` rounded to the nearest >=10^309 is infinity and any negative finite `x` is zero.\n\tif ( n > MAX_EXP ) {\n\t\tif ( x >= 0.0 ) {\n\t\t\treturn 0.0; // preserve the sign (same behavior as floor)\n\t\t}\n\t\treturn NINF;\n\t}\n\t// If we overflow, return `x`, as the number of digits to the right of the decimal is too small (i.e., `x` is too large / lacks sufficient fractional precision) for there to be any effect when rounding...\n\tif ( n < MIN_EXP ) {\n\t\ts = pow( 10.0, -(n + MAX_EXP) );\n\t\ty = (x*HUGE) * s; // order of operation matters!\n\t\tif ( isInfinite( y ) ) {\n\t\t\treturn x;\n\t\t}\n\t\treturn ( floor(y)/HUGE ) / s;\n\t}\n\ts = pow( 10.0, -n );\n\ty = x * s;\n\tif ( isInfinite( y ) ) {\n\t\treturn x;\n\t}\n\treturn floor( y ) / s;\n}\n\n\n// EXPORTS //\nexport default floorn;\n","import __var_0__ from './floorn.js';\n/**\n\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n/**\n* Round a numeric value to the nearest multiple of `10^n` toward negative infinity.\n*\n* @module @stdlib/math/base/special/floorn\n*\n* @example\n* var floorn = require( '@stdlib/math/base/special/floorn' );\n*\n* // Round a value to 4 decimal places:\n* var v = floorn( 3.141592653589793, -4 );\n* // returns 3.1415\n*\n* // If n = 0, `floorn` behaves like `floor`:\n* v = floorn( 3.141592653589793, 0 );\n* // returns 3.0\n*\n* // Round a value to the nearest thousand:\n* v = floorn( 12368.0, 3 );\n* // returns 12000.0\n*/\n\n// MODULES //\nvar floorn = __var_0__;\n\n\n// EXPORTS //\nexport default floorn;\n"]}