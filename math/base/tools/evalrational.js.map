{"version":3,"sources":["@stdlib/math/base/tools/evalrational/lib/evalrational.js","@stdlib/math/base/tools/evalrational/lib/factory.js","@stdlib/math/base/tools/evalrational/lib/index.js"],"names":["abs","__var_0__","evalrational","P","Q","x","len","s1","s2","i","length","NaN","factory","f","n","m","Function","setReadOnly","__var_1__","__var_2__"],"mappings":"8GAmCA,IAAIA,EAAMC,EAsCV,SAASC,EAAcC,EAAGC,EAAGC,GAC5B,IAAIC,EACAC,EACAC,EACAC,EAGJ,GAAa,KADbH,EAAMH,EAAEO,QAEP,OAAOC,IAER,GAAKL,IAAQF,EAAEM,OACd,OAAOC,IAER,GAAW,IAANN,GAAqB,IAARC,EACjB,OAAOH,EAAG,GAAMC,EAAG,GAGpB,GAAKJ,EAAKK,IAAO,EAGhB,IAFAE,EAAKJ,EAAGG,EAAI,GACZE,EAAKJ,EAAGE,EAAI,GACNG,EAAIH,EAAI,EAAGG,GAAK,IAAKA,EAC1BF,GAAMF,EACNG,GAAMH,EACNE,GAAMJ,EAAGM,GACTD,GAAMJ,EAAGK,QAMV,IAHAJ,EAAI,EAAMA,EACVE,EAAKJ,EAAG,GACRK,EAAKJ,EAAG,GACFK,EAAI,EAAGA,EAAIH,IAAOG,EACvBF,GAAMF,EACNG,GAAMH,EACNE,GAAMJ,EAAGM,GACTD,GAAMJ,EAAGK,GAGX,OAAOF,EAAKC,ECxFb,IAAIN,EAAeD,EA+BnB,SAASW,EAAST,EAAGC,GACpB,IAAIS,EAEAC,EACAC,EACAN,EAGJ,GAAKN,EAAEO,OAAS,IACf,OAgJD,SAAmBL,GAClB,OAAOH,EAAcC,EAAGC,EAAGC,IArI5B,GATAQ,EAAI,mCAMJA,GAAK,gBAGM,KANXC,EAAIX,EAAEO,QAOLG,GAAK,mBAGD,GAAKC,IAAMV,EAAEM,OACjBG,GAAK,mBAGD,GAAW,IAANC,EAETD,GAAK,UADDV,EAAG,GAAMC,EAAG,GACK,QAGjB,CAYJ,IATAS,GAAK,sBADDV,EAAG,GAAMC,EAAG,GACiB,KAGjCS,GAAK,+BAGLA,GAAK,eACLA,GAAK,QAAUV,EAAG,GAClBY,EAAID,EAAI,EACFL,EAAI,EAAGA,EAAIK,EAAGL,IACnBI,GAAK,MACAJ,EAAIM,IACRF,GAAK,KAENA,GAAKV,EAAGM,GAGT,IAAMA,EAAI,EAAGA,EAAIM,EAAE,EAAGN,IACrBI,GAAK,IAKN,IAHAA,GAAK,IACLA,GAAK,QAAUT,EAAG,GAClBW,EAAID,EAAI,EACFL,EAAI,EAAGA,EAAIK,EAAGL,IACnBI,GAAK,MACAJ,EAAIM,IACRF,GAAK,KAENA,GAAKT,EAAGK,GAGT,IAAMA,EAAI,EAAGA,EAAIM,EAAE,EAAGN,IACrBI,GAAK,IAWN,IATAA,GAAK,IAGLA,GAAK,SAGLA,GAAK,aAELA,GAAK,QAAUV,EADfY,EAAID,EAAI,GAEFL,EAAIM,EAAI,EAAGN,GAAK,EAAGA,IACxBI,GAAK,MACAJ,EAAI,IACRI,GAAK,KAENA,GAAKV,EAAGM,GAGT,IAAMA,EAAI,EAAGA,EAAIM,EAAE,EAAGN,IACrBI,GAAK,IAMN,IAJAA,GAAK,IAGLA,GAAK,QAAUT,EADfW,EAAID,EAAI,GAEFL,EAAIM,EAAI,EAAGN,GAAK,EAAGA,IACxBI,GAAK,MACAJ,EAAI,IACRI,GAAK,KAENA,GAAKT,EAAGK,GAGT,IAAMA,EAAI,EAAGA,EAAIM,EAAE,EAAGN,IACrBI,GAAK,IAENA,GAAK,IAGLA,GAAK,IAGLA,GAAK,gBASN,OANAA,GAAK,IAGLA,GAAK,wCAGE,IAAMG,SAAUH,EAAhB,GCtHR,IAAII,EAAchB,EACdC,EAAegB,EACfN,EAAUO,EAKdF,EAAaf,EAAc,UAAWU","sourcesContent":["import __var_0__ from '@stdlib/math/base/special/abs';\n/**\n\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*\n*\n* ## Notice\n*\n* The original C++ code and copyright notice are from the [Boost library]{@link http://www.boost.org/doc/libs/1_60_0/boost/math/tools/rational.hpp}. The implementation has been modified for JavaScript.\n*\n* ```text\n* (C) Copyright John Maddock 2006.\n*\n* Use, modification and distribution are subject to the\n* Boost Software License, Version 1.0. (See accompanying file\n* LICENSE or copy at http://www.boost.org/LICENSE_1_0.txt)\n* ```\n*/\n\n'use strict';\n\n// MODULES //\nvar abs = __var_0__;\n\n\n// MAIN //\n\n/**\n* Evaluates a rational function, i.e., the ratio of two polynomials described by the coefficients stored in \\\\(P\\\\) and \\\\(Q\\\\).\n*\n* ## Notes\n*\n* -   Coefficients should be sorted in ascending degree.\n* -   The implementation uses [Horner's rule][horners-method] for efficient computation.\n*\n* [horners-method]: https://en.wikipedia.org/wiki/Horner%27s_method\n*\n*\n* @param {NumericArray} P - numerator polynomial coefficients sorted in ascending degree\n* @param {NumericArray} Q - denominator polynomial coefficients sorted in ascending degree\n* @param {number} x - value at which to evaluate the rational function\n* @returns {number} evaluated rational function\n*\n* @example\n* var P = [ -6.0, -5.0 ];\n* var Q = [ 3.0, 0.5 ];\n*\n* var v = evalrational( P, Q, 6.0 ); //  => ( -6*6^0 - 5*6^1 ) / ( 3*6^0 + 0.5*6^1 ) = (-6-30)/(3+3)\n* // returns -6.0\n*\n* @example\n* // 2x^3 + 4x^2 - 5x^1 - 6x^0 => degree 4\n* var P = [ -6.0, -5.0, 4.0, 2.0 ];\n*\n* // 0.5x^1 + 3x^0 => degree 2\n* var Q = [ 3.0, 0.5, 0.0, 0.0 ]; // zero-padded\n*\n* var v = evalrational( P, Q, 6.0 ); // => ( -6*6^0 - 5*6^1 + 4*6^2 + 2*6^3 ) / ( 3*6^0 + 0.5*6^1 + 0*6^2 + 0*6^3 ) = (-6-30+144+432)/(3+3)\n* // returns 90.0\n*/\nfunction evalrational( P, Q, x ) {\n\tvar len;\n\tvar s1;\n\tvar s2;\n\tvar i;\n\n\tlen = P.length;\n\tif ( len === 0 ) {\n\t\treturn NaN;\n\t}\n\tif ( len !== Q.length ) {\n\t\treturn NaN;\n\t}\n\tif ( x === 0.0 || len === 1 ) {\n\t\treturn P[ 0 ] / Q[ 0 ];\n\t}\n\t// Use Horner's method...\n\tif ( abs( x ) <= 1.0 ) {\n\t\ts1 = P[ len-1 ];\n\t\ts2 = Q[ len-1 ];\n\t\tfor ( i = len-2; i >= 0; --i ) {\n\t\t\ts1 *= x;\n\t\t\ts2 *= x;\n\t\t\ts1 += P[ i ];\n\t\t\ts2 += Q[ i ];\n\t\t}\n\t} else {\n\t\tx = 1.0 / x; // use inverse to avoid overflow\n\t\ts1 = P[ 0 ];\n\t\ts2 = Q[ 0 ];\n\t\tfor ( i = 1; i < len; ++i ) {\n\t\t\ts1 *= x;\n\t\t\ts2 *= x;\n\t\t\ts1 += P[ i ];\n\t\t\ts2 += Q[ i ];\n\t\t}\n\t}\n\treturn s1 / s2;\n}\n\n\n// EXPORTS //\nexport default evalrational;\n","import __var_0__ from './evalrational.js';\n/**\n\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\nvar evalrational = __var_0__;\n\n\n// MAIN //\n\n/**\n* Generates a function for evaluating a rational function.\n*\n* ## Notes\n*\n* -   The compiled function uses [Horner's rule][horners-method] for efficient computation.\n*\n* [horners-method]: http://en.wikipedia.org/wiki/Horner%27s_method\n*\n*\n* @param {NumericArray} P - numerator polynomial coefficients sorted in ascending degree\n* @param {NumericArray} Q - denominator polynomial coefficients sorted in ascending degree\n* @returns {Function} function for evaluating a rational function\n*\n* @example\n* var P = [ 20.0, 8.0, 3.0 ];\n* var Q = [ 10.0, 9.0, 1.0 ];\n*\n* var rational = factory( P, Q );\n*\n* var v = rational( 10.0 ); // => (20*10^0 + 8*10^1 + 3*10^2) / (10*10^0 + 9*10^1 + 1*10^2) = (20+80+300)/(10+90+100)\n* // returns 2.0\n*\n* v = rational( 2.0 ); // => (20*2^0 + 8*2^1 + 3*2^2) / (10*2^0 + 9*2^1 + 1*2^2) = (20+16+12)/(10+18+4)\n* // returns 1.5\n*/\nfunction factory( P, Q ) {\n\tvar f;\n\tvar r;\n\tvar n;\n\tvar m;\n\tvar i;\n\n\t// Avoid exceeding maximum stack size on V8 :(. Note that the value of `500` was empirically determined...\n\tif ( P.length > 500 ) {\n\t\treturn rational;\n\t}\n\t// Code generation. Start with the function definition...\n\tf = 'return function evalrational(x){';\n\n\t// Create the function body...\n\tn = P.length;\n\n\t// Declare variables...\n\tf += 'var ax,s1,s2;';\n\n\t// If no coefficients, the function always returns NaN...\n\tif ( n === 0 ) {\n\t\tf += 'return NaN;';\n\t}\n\t// If P and Q have different lengths, the function always returns NaN...\n\telse if ( n !== Q.length ) {\n\t\tf += 'return NaN;';\n\t}\n\t// If P and Q have only one coefficient, the function always returns the ratio of the first coefficients...\n\telse if ( n === 1 ) {\n\t\tr = P[ 0 ] / Q[ 0 ];\n\t\tf += 'return ' + r + ';';\n\t}\n\t// If more than one coefficient, apply Horner's method to both the numerator and denominator...\n\telse {\n\t\t// If `x == 0`, return the ratio of the first coefficients...\n\t\tr = P[ 0 ] / Q[ 0 ];\n\t\tf += 'if(x===0.0){return ' + r + ';}';\n\n\t\t// Compute the absolute value of `x`...\n\t\tf += 'if(x<0.0){ax=-x;}else{ax=x;}';\n\n\t\t// If `abs(x) <= 1`, evaluate the numerator and denominator of the rational function using Horner's method...\n\t\tf += 'if(ax<=1.0){';\n\t\tf += 's1 = ' + P[ 0 ];\n\t\tm = n - 1;\n\t\tfor ( i = 1; i < n; i++ ) {\n\t\t\tf += '+x*';\n\t\t\tif ( i < m ) {\n\t\t\t\tf += '(';\n\t\t\t}\n\t\t\tf += P[ i ];\n\t\t}\n\t\t// Close all the parentheses...\n\t\tfor ( i = 0; i < m-1; i++ ) {\n\t\t\tf += ')';\n\t\t}\n\t\tf += ';';\n\t\tf += 's2 = ' + Q[ 0 ];\n\t\tm = n - 1;\n\t\tfor ( i = 1; i < n; i++ ) {\n\t\t\tf += '+x*';\n\t\t\tif ( i < m ) {\n\t\t\t\tf += '(';\n\t\t\t}\n\t\t\tf += Q[ i ];\n\t\t}\n\t\t// Close all the parentheses...\n\t\tfor ( i = 0; i < m-1; i++ ) {\n\t\t\tf += ')';\n\t\t}\n\t\tf += ';';\n\n\t\t// Close the if statement...\n\t\tf += '}else{';\n\n\t\t// If `abs(x) > 1`, evaluate the numerator and denominator via the inverse to avoid overflow...\n\t\tf += 'x = 1.0/x;';\n\t\tm = n - 1;\n\t\tf += 's1 = ' + P[ m ];\n\t\tfor ( i = m - 1; i >= 0; i-- ) {\n\t\t\tf += '+x*';\n\t\t\tif ( i > 0 ) {\n\t\t\t\tf += '(';\n\t\t\t}\n\t\t\tf += P[ i ];\n\t\t}\n\t\t// Close all the parentheses...\n\t\tfor ( i = 0; i < m-1; i++ ) {\n\t\t\tf += ')';\n\t\t}\n\t\tf += ';';\n\n\t\tm = n - 1;\n\t\tf += 's2 = ' + Q[ m ];\n\t\tfor ( i = m - 1; i >= 0; i-- ) {\n\t\t\tf += '+x*';\n\t\t\tif ( i > 0 ) {\n\t\t\t\tf += '(';\n\t\t\t}\n\t\t\tf += Q[ i ];\n\t\t}\n\t\t// Close all the parentheses...\n\t\tfor ( i = 0; i < m-1; i++ ) {\n\t\t\tf += ')';\n\t\t}\n\t\tf += ';';\n\n\t\t// Close the else statement...\n\t\tf += '}';\n\n\t\t// Return the ratio of the two sums...\n\t\tf += 'return s1/s2;';\n\t}\n\t// Close the function:\n\tf += '}';\n\n\t// Add a source directive for debugging:\n\tf += '//# sourceURL=evalrational.factory.js';\n\n\t// Create the function in the global scope:\n\treturn ( new Function( f ) )(); // eslint-disable-line no-new-func\n\n\t/*\n\t*\tfunction evalrational( x ) {\n\t*\t\tvar ax, s1, s2;\n\t*\t\tif ( x === 0.0 ) {\n\t*\t\t\treturn P[0] / Q[0];\n\t*\t\t}\n\t*\t\tif ( x < 0.0 ) {\n\t*\t\t\tax = -x;\n\t*\t\t} else {\n\t*\t\t\tax = x;\n\t*\t\t}\n\t*\t\tif ( ax <= 1.0 ) {\n\t*\t\t\ts1 = P[0]+x*(P[1]+x*(P[2]+x*(P[3]+...+x*(P[n-2]+x*P[n-1]))));\n\t*\t\t\ts2 = Q[0]+x*(Q[1]+x*(Q[2]+x*(Q[3]+...+x*(Q[n-2]+x*Q[n-1]))));\n\t*\t\t} else {\n\t*\t\t\tx = 1.0/x;\n\t*\t\t\ts1 = P[n-1]+x*(P[n-2]+x*(P[n-3]+x*(P[n-4]+...+x*(P[1]+x*P[0]))));\n\t*\t\t\ts2 = Q[n-1]+x*(Q[n-2]+x*(Q[n-3]+x*(Q[n-4]+...+x*(Q[1]+x*Q[0]))));\n\t*\t\t}\n\t*\t\treturn s1 / s2;\n\t*\t}\n\t*/\n\n\t/**\n\t* Evaluates a rational function.\n\t*\n\t* @private\n\t* @param {number} x - value at which to evaluate a rational function\n\t* @returns {number} evaluated rational function\n\t*/\n\tfunction rational( x ) {\n\t\treturn evalrational( P, Q, x );\n\t}\n}\n\n\n// EXPORTS //\nexport default factory;\n","import __var_0__ from '@stdlib/utils/define-nonenumerable-read-only-property';\nimport __var_1__ from './evalrational.js';\nimport __var_2__ from './factory.js';\n/**\n\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n/**\n* Evaluate a rational function.\n*\n* @module @stdlib/math/base/tools/evalrational\n*\n* @example\n* var evalrational = require( '@stdlib/math/base/tools/evalrational' );\n*\n* // 2x^3 + 4x^2 - 5x^1 - 6x^0 => degree 4\n* var P = [ -6.0, -5.0, 4.0, 2.0 ];\n*\n* // 0.5x^1 + 3x^0 => degree 2\n* var Q = [ 3.0, 0.5, 0.0, 0.0 ]; // zero-padded\n*\n* var v = evalrational( P, Q, 6.0 ); // => ( -6*6^0 - 5*6^1 + 4*6^2 + 2*6^3 ) / ( 3*6^0 + 0.5*6^1 + 0*6^2 + 0*6^3 ) = (-6-30+144+432)/(3+3)\n* // returns 90.0\n*\n* @example\n* var evalrational = require( '@stdlib/math/base/tools/evalrational' );\n*\n* var P = [ 20.0, 8.0, 3.0 ];\n* var Q = [ 10.0, 9.0, 1.0 ];\n*\n* var rational = evalrational.factory( P, Q );\n*\n* var v = rational( 10.0 ); // => (20*10^0 + 8*10^1 + 3*10^2) / (10*10^0 + 9*10^1 + 1*10^2) = (20+80+300)/(10+90+100)\n* // returns 2.0\n*\n* v = rational( 2.0 ); // => (20*2^0 + 8*2^1 + 3*2^2) / (10*2^0 + 9*2^1 + 1*2^2) = (20+16+12)/(10+18+4)\n* // returns 1.5\n*/\n\n// MODULES //\nvar setReadOnly = __var_0__;\nvar evalrational = __var_1__;\nvar factory = __var_2__;\n\n\n// MAIN //\n\nsetReadOnly( evalrational, 'factory', factory );\n\n\n// EXPORTS //\nexport default evalrational;\n"]}