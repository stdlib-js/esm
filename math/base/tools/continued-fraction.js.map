{"version":3,"sources":["@stdlib/math/base/tools/continued-fraction/lib/generators.js","@stdlib/math/base/tools/continued-fraction/lib/basic.js","@stdlib/math/base/tools/continued-fraction/lib/index.js"],"names":["abs","__var_0__","FLOAT32_SMALLEST_NORMAL","__var_1__","EPS","__var_2__","MAX_ITER","continuedFractionA","gen","factor","maxIter","isgenerator","delta","a0","f","C","D","v","next","value","continuedFractionB","continuedFraction","generator","options","opts","eps","arguments","length","tolerance","keep","hasGeneratorSupport","basic","continuedFraction$3"],"mappings":"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","sourcesContent":["import __var_0__ from '@stdlib/math/base/special/abs';\nimport __var_1__ from '@stdlib/constants/math/float32-smallest-normal';\nimport __var_2__ from '@stdlib/constants/math/float64-eps';\n/**\n\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\nvar abs = __var_0__;\nvar FLOAT32_SMALLEST_NORMAL = __var_1__;\nvar EPS = __var_2__;\n\n\n// VARIABLES //\n\nvar MAX_ITER = 1000000;\n\n\n// FUNCTIONS //\n\n/**\n* Evaluates a continued fraction expansion.\n*\n* ```text\n*           a1\n*      ---------------\n*      b1 +     a2\n*           ----------\n*            b2 +   a3\n*                -----\n*                b3 + ...\n* ```\n*\n* @private\n* @param {Function} gen - function giving terms of continued fraction expansion\n* @param {PositiveNumber} factor - further terms are only added as long as factor*result is smaller than the next term\n* @param {PositiveInteger} maxIter - maximum number of iterations\n* @returns {number} evaluated expansion\n*/\nfunction continuedFractionA( gen, factor, maxIter ) {\n\tvar isgenerator;\n\tvar delta;\n\tvar a0;\n\tvar f;\n\tvar C;\n\tvar D;\n\tvar v;\n\n\tisgenerator = typeof gen.next === 'function';\n\tv = ( isgenerator ) ? gen.next().value : gen();\n\tf = v[ 1 ];\n\ta0 = v[ 0 ];\n\tif ( f === 0.0 ) {\n\t\tf = FLOAT32_SMALLEST_NORMAL;\n\t}\n\tC = f;\n\tD = 0;\n\tif ( isgenerator === true ) {\n\t\tdo {\n\t\t\tv = gen.next().value;\n\t\t\tif ( v ) {\n\t\t\t\tD = v[ 1 ] + ( v[ 0 ] * D );\n\t\t\t\tif ( D === 0.0 ) {\n\t\t\t\t\tD = FLOAT32_SMALLEST_NORMAL;\n\t\t\t\t}\n\t\t\t\tC = v[ 1 ] + ( v[ 0 ] / C );\n\t\t\t\tif ( C === 0.0 ) {\n\t\t\t\t\tC = FLOAT32_SMALLEST_NORMAL;\n\t\t\t\t}\n\t\t\t\tD = 1.0 / D;\n\t\t\t\tdelta = C * D;\n\t\t\t\tf *= delta;\n\t\t\t}\n\t\t} while ( ( abs( delta - 1.0 ) > factor ) && --maxIter ); // eslint-disable-line no-plusplus\n\t} else {\n\t\tdo {\n\t\t\tv = gen();\n\t\t\tif ( v ) {\n\t\t\t\tD = v[ 1 ] + ( v[ 0 ] * D );\n\t\t\t\tif ( D === 0.0 ) {\n\t\t\t\t\tD = FLOAT32_SMALLEST_NORMAL;\n\t\t\t\t}\n\t\t\t\tC = v[ 1 ] + ( v[ 0 ] / C );\n\t\t\t\tif ( C === 0.0 ) {\n\t\t\t\t\tC = FLOAT32_SMALLEST_NORMAL;\n\t\t\t\t}\n\t\t\t\tD = 1.0 / D;\n\t\t\t\tdelta = C * D;\n\t\t\t\tf *= delta;\n\t\t\t}\n\t\t} while ( v && ( abs( delta - 1.0 ) > factor ) && --maxIter ); // eslint-disable-line no-plusplus\n\t}\n\treturn a0 / f;\n}\n\n/**\n* Evaluates a continued fraction expansion.\n*\n* ```text\n*      b0 +    a1\n*      ---------------\n*      b1 +     a2\n*           ----------\n*           b2 +   a3\n*                -----\n*                b3 + ...\n* ```\n*\n* @private\n* @param {Function} gen - function giving terms of continued fraction expansion\n* @param {PositiveNumber} factor - further terms are only added as long as factor*result is smaller than the next term\n* @param {PositiveInteger} maxIter - maximum number of iterations\n* @returns {number} evaluated expansion\n*/\nfunction continuedFractionB( gen, factor, maxIter ) {\n\tvar isgenerator;\n\tvar delta;\n\tvar f;\n\tvar C;\n\tvar D;\n\tvar v;\n\n\tisgenerator = typeof gen.next === 'function';\n\tv = ( isgenerator ) ? gen.next().value : gen();\n\tf = v[ 1 ];\n\tif ( f === 0.0 ) {\n\t\tf = FLOAT32_SMALLEST_NORMAL;\n\t}\n\tC = f;\n\tD = 0.0;\n\tif ( isgenerator === true ) {\n\t\tdo {\n\t\t\tv = gen.next().value;\n\t\t\tif ( v ) {\n\t\t\t\tD = v[ 1 ] + ( v[ 0 ] * D );\n\t\t\t\tif ( D === 0.0 ) {\n\t\t\t\t\tD = FLOAT32_SMALLEST_NORMAL;\n\t\t\t\t}\n\t\t\t\tC = v[ 1 ] + ( v[ 0 ] / C );\n\t\t\t\tif ( C === 0.0 ) {\n\t\t\t\t\tC = FLOAT32_SMALLEST_NORMAL;\n\t\t\t\t}\n\t\t\t\tD = 1.0 / D;\n\t\t\t\tdelta = C * D;\n\t\t\t\tf *= delta;\n\t\t\t}\n\t\t} while ( v && ( abs( delta - 1.0 ) > factor ) && --maxIter ); // eslint-disable-line no-plusplus\n\t} else {\n\t\tdo {\n\t\t\tv = gen();\n\t\t\tif ( v ) {\n\t\t\t\tD = v[ 1 ] + ( v[ 0 ] * D );\n\t\t\t\tif ( D === 0.0 ) {\n\t\t\t\t\tD = FLOAT32_SMALLEST_NORMAL;\n\t\t\t\t}\n\t\t\t\tC = v[ 1 ] + ( v[ 0 ] / C );\n\t\t\t\tif ( C === 0.0 ) {\n\t\t\t\t\tC = FLOAT32_SMALLEST_NORMAL;\n\t\t\t\t}\n\t\t\t\tD = 1.0 / D;\n\t\t\t\tdelta = C * D;\n\t\t\t\tf *= delta;\n\t\t\t}\n\t\t} while ( v && ( abs( delta - 1.0 ) > factor ) && --maxIter ); // eslint-disable-line no-plusplus\n\t}\n\treturn f;\n}\n\n\n// MAIN //\n\n/**\n* Evaluates the continued fraction approximation for the supplied series generator using the modified Lentz algorithm.\n*\n* ## References\n*\n* -   Lentz, William J. 1976. \"Generating bessel functions in Mie scattering calculations using continued fractions.\" _Applied Optics_ 15 (3): 668–71. doi:[10.1364/AO.15.000668](https://doi.org/10.1364/AO.15.000668).\n*\n* @param {Function} generator - function returning terms of continued fraction expansion\n* @param {Object} [options] - function options\n* @param {PositiveInteger} [options.maxIter=1000] - maximum number of iterations\n* @param {PositiveNumber} [options.tolerance=2.22e-16] - further terms are only added as long as the next term is greater than current term times the tolerance\n* @param {boolean} [options.keep=false] - whether to keep the leading b term\n* @returns {number} value of continued fraction\n*\n* @example\n* // Continued fraction for (e-1)^(-1):\n* var gen = generator();\n* var out = continuedFraction( gen );\n* // returns ~0.582\n*\n* function* generator() {\n*    var i = 0;\n*    while ( true ) {\n*        i++;\n*        yield [ i, i ];\n*    }\n* }\n*/\nfunction continuedFraction( generator, options ) {\n\tvar maxIter;\n\tvar opts;\n\tvar eps;\n\n\topts = {};\n\tif ( arguments.length > 1 ) {\n\t\topts = options;\n\t}\n\tmaxIter = opts.maxIter || MAX_ITER;\n\teps = opts.tolerance || EPS;\n\n\tif ( opts.keep ) {\n\t\treturn continuedFractionB( generator, eps, maxIter );\n\t}\n\treturn continuedFractionA( generator, eps, maxIter );\n}\n\n\n// EXPORTS //\nexport default continuedFraction;\n","import __var_0__ from '@stdlib/math/base/special/abs';\nimport __var_1__ from '@stdlib/constants/math/float64-eps';\nimport __var_2__ from '@stdlib/constants/math/float32-smallest-normal';\n/**\n\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\nvar abs = __var_0__;\nvar EPS = __var_1__;\nvar FLOAT32_SMALLEST_NORMAL = __var_2__;\n\n\n// VARIABLES //\n\nvar MAX_ITER = 1000000;\n\n\n// FUNCTIONS //\n\n/**\n* Evaluates a continued fraction expansion.\n*\n* ```text\n*           a1\n*      ---------------\n*      b1 +     a2\n*           ----------\n*            b2 +   a3\n*                -----\n*                b3 + ...\n* ```\n*\n* @private\n* @param {Function} gen - function giving terms of continued fraction expansion\n* @param {PositiveNumber} factor - further terms are only added as long as factor*result is smaller than the next term\n* @param {PositiveInteger} maxIter - maximum number of iterations\n* @returns {number} evaluated expansion\n*/\nfunction continuedFractionA( gen, factor, maxIter ) {\n\tvar delta;\n\tvar a0;\n\tvar C;\n\tvar D;\n\tvar f;\n\tvar v;\n\n\tv = gen();\n\tf = v[ 1 ];\n\ta0 = v[ 0 ];\n\tif ( f === 0 ) {\n\t\tf = FLOAT32_SMALLEST_NORMAL;\n\t}\n\tC = f;\n\tD = 0.0;\n\n\tdo {\n\t\tv = gen();\n\t\tif ( v ) {\n\t\t\tD = v[ 1 ] + ( v[ 0 ] * D );\n\t\t\tif ( D === 0.0 ) {\n\t\t\t\tD = FLOAT32_SMALLEST_NORMAL;\n\t\t\t}\n\t\t\tC = v[ 1 ] + ( v[ 0 ] / C );\n\t\t\tif ( C === 0.0 ) {\n\t\t\t\tC = FLOAT32_SMALLEST_NORMAL;\n\t\t\t}\n\t\t\tD = 1.0 / D;\n\t\t\tdelta = C * D;\n\t\t\tf *= delta;\n\t\t}\n\t} while ( v && ( abs( delta - 1.0 ) > factor ) && --maxIter ); // eslint-disable-line no-plusplus\n\n\treturn a0 / f;\n}\n\n/**\n* Evaluates a continued fraction expansion.\n*\n* ```text\n*      b0 +   a1\n*      ---------------\n*      b1 +   a2\n*           ----------\n*           b2 +   a3\n*                -----\n*                b3 + ...\n* ```\n*\n* @private\n* @param {Function} gen - function giving terms of continued fraction expansion\n* @param {PositiveNumber} factor - further terms are only added as long as factor*result is smaller than the next term\n* @param {PositiveInteger} maxIter - maximum number of iterations\n* @returns {number} evaluated expansion\n*/\nfunction continuedFractionB( gen, factor, maxIter ) {\n\tvar delta;\n\tvar C;\n\tvar D;\n\tvar f;\n\tvar v;\n\n\tv = gen();\n\tf = v[ 1 ];\n\tif ( f === 0.0 ) {\n\t\tf = FLOAT32_SMALLEST_NORMAL;\n\t}\n\tC = f;\n\tD = 0.0;\n\tdo {\n\t\tv = gen();\n\t\tif ( v ) {\n\t\t\tD = v[ 1 ] + ( v[ 0 ] * D );\n\t\t\tif ( D === 0.0 ) {\n\t\t\t\tD = FLOAT32_SMALLEST_NORMAL;\n\t\t\t}\n\t\t\tC = v[ 1 ] + ( v[ 0 ] / C );\n\t\t\tif ( C === 0.0 ) {\n\t\t\t\tC = FLOAT32_SMALLEST_NORMAL;\n\t\t\t}\n\t\t\tD = 1.0 / D;\n\t\t\tdelta = C * D;\n\t\t\tf *= delta;\n\t\t}\n\t} while ( v && ( abs( delta - 1.0 ) > factor ) && --maxIter ); // eslint-disable-line no-plusplus\n\treturn f;\n}\n\n\n// MAIN //\n\n/**\n* Evaluates the continued fraction approximation for the supplied series generator using the modified Lentz algorithm.\n*\n* ## References\n*\n* -   Lentz, William J. 1976. \"Generating bessel functions in Mie scattering calculations using continued fractions.\" _Applied Optics_ 15 (3): 668–71. doi:[10.1364/AO.15.000668](https://doi.org/10.1364/AO.15.000668).\n*\n* @param {Function} generator - function returning terms of continued fraction expansion\n* @param {Object} [options] - function options\n* @param {PositiveInteger} [options.maxIter=1000000] - maximum number of iterations\n* @param {PositiveNumber} [options.tolerance=2.22e-16] - further terms are only added as long as the next term is greater than current term times the tolerance\n* @param {boolean} [options.keep=false] - whether to keep the leading b term\n* @returns {number} value of continued fraction\n*\n* @example\n* // Continued fraction for (e-1)^(-1):\n* var gen = generator()\n* var out = continuedFraction( gen );\n* // returns ~0.582\n*\n* function generator() {\n*    var i = 0;\n*    return function() {\n*        i++;\n*        return [ i, i ];\n*    };\n* }\n*/\nfunction continuedFraction( generator, options ) {\n\tvar maxIter;\n\tvar opts;\n\tvar eps;\n\n\topts = {};\n\tif ( arguments.length > 1 ) {\n\t\topts = options;\n\t}\n\teps = opts.tolerance || EPS;\n\tmaxIter = opts.maxIter || MAX_ITER;\n\n\tif ( opts.keep ) {\n\t\treturn continuedFractionB( generator, eps, maxIter );\n\t}\n\treturn continuedFractionA( generator, eps, maxIter );\n}\n\n\n// EXPORTS //\nexport default continuedFraction;\n","import __var_0__ from '@stdlib/assert/has-generator-support';\nimport __var_1__ from './generators.js';\nimport __var_2__ from './basic.js';\n/**\n\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n/**\n* Calculate a continued fraction approximation.\n*\n* @module @stdlib/math/base/tools/continued-fraction\n*\n* @example\n* var continuedFraction = require( '@stdlib/math/base/tools/continued-fraction' );\n*\n* // Continued fraction for (e-1)^(-1):\n* var gen = generator()\n* var out = continuedFraction( gen );\n* // returns ~0.582\n*\n* function generator() {\n*    var i = 0;\n*    return function() {\n*        i++;\n*        return [ i, i ];\n*    };\n* }\n*/\n\n// MODULES //\nvar hasGeneratorSupport = __var_0__;\nvar generator = __var_1__;\nvar basic = __var_2__;\n\n\n// MAIN //\n\nvar continuedFraction;\nif ( hasGeneratorSupport() ) {\n\tcontinuedFraction = generator;\n} else {\n\tcontinuedFraction = basic;\n}\n\n\n// EXPORTS //\nexport default continuedFraction;\n"]}