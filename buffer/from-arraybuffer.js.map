{"version":3,"sources":["@stdlib/buffer/from-arraybuffer/lib/node_version.js","@stdlib/buffer/from-arraybuffer/lib/has_from.js","@stdlib/buffer/from-arraybuffer/lib/main.js","@stdlib/buffer/from-arraybuffer/lib/polyfill.js","@stdlib/buffer/from-arraybuffer/lib/index.js"],"names":["NODE_VERSION","__var_0__","MAJOR","parseInt","split","isFunction","Buffer","__var_1__","version","__var_2__","bool","from","isArrayBuffer","isNonNegativeInteger","isPrimitive","__var_3__","fromArrayBuffer","buf","byteOffset","length","offset","len","TypeError","arguments","byteLength","RangeError","Uint8Array","fromArray","__var_4__","__var_5__","arraybuffer2buffer","hasFrom","main","polyfill","arraybuffer2buffer$1"],"mappings":"mRAsBA,IAAIA,EAAeC,EAKfC,EALeD,EAKYE,SALZF,EAKmCG,MAAO,KAAO,GAAK,KAAQ,ECH7EC,EAAaJ,EACbK,EAASC,EACTC,EAAUC,EAKVC,EAAOL,EAAYC,EAAOK,OAAUH,GAAW,ECN/CI,EAAgBX,EAChBY,EAAuBN,EAAUO,YACjCR,EAASG,EACTD,EAAUO,EAwCd,SAASC,EAAiBC,EAAKC,EAAYC,GAC1C,IAAIC,EACAC,EACJ,IAAMT,EAAeK,GACpB,MAAM,IAAIK,UAAW,oEAAsEL,EAAM,KAElG,GAAKM,UAAUJ,OAAS,EAAI,CAC3B,IAAMN,EAAsBK,GAC3B,MAAM,IAAII,UAAW,4EAA8EJ,EAAa,MAEjH,GAAKA,EAAaD,EAAIO,WACrB,MAAM,IAAIC,WAAY,2GAA6GP,EAAa,MAGjJ,GADAE,EAASF,EACJK,UAAUJ,OAAS,EAAI,CAC3B,IAAMN,EAAsBM,GAC3B,MAAM,IAAIG,UAAW,0EAA4EH,EAAS,MAE3G,GAAKA,EAASF,EAAIO,WACjB,MAAM,IAAIC,WAAY,yGAA2GN,EAAS,MAE3IE,EAAMF,OAENE,EAAMJ,EAAIO,WAAaJ,OAGxBA,EAAS,EACTC,EAAMJ,EAAIO,WAGX,OAAa,IAARH,GAAab,EAAU,EACpBF,EAAOK,KAAM,IAEdL,EAAOK,KAAMM,EAAKG,EAAQC,GC1ElC,IAAIT,EAAgBX,EAChBY,EAAuBN,EAAUO,YACjCR,EAASG,EACTiB,EAAaX,EACbY,EAAYC,EACZpB,EAAUqB,EAyCd,SAASb,EAAiBC,EAAKC,EAAYC,GAC1C,IAAIE,EACJ,IAAMT,EAAeK,GACpB,MAAM,IAAIK,UAAW,oEAAsEL,EAAM,KAElG,GAAKM,UAAUJ,OAAS,EAAI,CAC3B,IAAMN,EAAsBK,GAC3B,MAAM,IAAII,UAAW,4EAA8EJ,EAAa,MAEjH,GAAKA,EAAaD,EAAIO,WACrB,MAAM,IAAIC,WAAY,2GAA6GP,EAAa,MAEjJ,GAAKK,UAAUJ,OAAS,EAAI,CAC3B,IAAMN,EAAsBM,GAC3B,MAAM,IAAIG,UAAW,0EAA4EH,EAAS,MAE3G,GAAKA,EAASF,EAAIO,WACjB,MAAM,IAAIC,WAAY,yGAA2GN,EAAS,MAE3IE,EAAMF,OAENE,EAAMJ,EAAIO,WAAaN,EAExB,OAAOS,EAAW,IAAID,EAAYT,EAAKC,EAAYG,IAEpD,OAAKb,EAAU,EACPmB,EAAW,IAAID,EAAYT,IAGX,IAAnBA,EAAIO,WACD,IAAIlB,EAAQ,IAEb,IAAIA,EAAQW,GCnEpB,IAOIa,EAPAC,EAAU9B,EACV+B,EAAOzB,EACP0B,EAAWxB,EAcfyB,EAPCJ,EADIC,EACiBC,EAEAC","sourcesContent":["import __var_0__ from '@stdlib/process/node-version';\n/**\n\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\nvar NODE_VERSION = __var_0__;\n\n\n// MAIN //\n\nvar MAJOR = ( NODE_VERSION ) ? parseInt( NODE_VERSION.split( '.' )[ 0 ], 10 ) : -1;\n\n\n// EXPORTS //\nexport default MAJOR;\n","import __var_0__ from '@stdlib/assert/is-function';\nimport __var_1__ from '@stdlib/buffer/ctor';\nimport __var_2__ from './node_version.js';\n/**\n\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\nvar isFunction = __var_0__;\nvar Buffer = __var_1__;\nvar version = __var_2__;\n\n\n// MAIN //\n\nvar bool = isFunction( Buffer.from ) && version >= 5;\n\n\n// EXPORTS //\nexport default bool;\n","import __var_0__ from '@stdlib/assert/is-arraybuffer';\nimport __var_1__ from '@stdlib/assert/is-nonnegative-integer';\nimport __var_2__ from '@stdlib/buffer/ctor';\nimport __var_3__ from './node_version.js';\n/**\n\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\nvar isArrayBuffer = __var_0__;\nvar isNonNegativeInteger = __var_1__.isPrimitive;\nvar Buffer = __var_2__;\nvar version = __var_3__;\n\n\n// MAIN //\n\n/**\n* Allocates a buffer from an `ArrayBuffer`.\n*\n* ## Notes\n*\n* The behavior of this function varies across Node.js versions due to changes in the underlying Node.js APIs:\n*\n* -   `<6.0.0`: if provided an empty ArrayBuffer, the function returns an empty Buffer which is **not** an ArrayBuffer view.\n* -   otherwise, the function returns a view of an ArrayBuffer without copying the underlying memory.\n*\n*\n* @param {ArrayBuffer} buf - ArrayBuffer instance\n* @param {NonNegativeInteger} [byteOffset=0] - index specifying the location of the first buffer byte\n* @param {NonNegativeInteger} [length=buf.byteLength] - number of buffer bytes\n* @throws {TypeError} first argument must be an ArrayBuffer\n* @throws {TypeError} second argument must be a nonnegative integer\n* @throws {RangeError} second argument must not exceed number of bytes in input ArrayBuffer\n* @throws {TypeError} last argument must be a nonnegative integer\n* @throws {RangeError} last argument must not exceed number of bytes in input ArrayBuffer\n* @returns {Buffer} new `Buffer` instance\n*\n* @example\n* var ArrayBuffer = require( '@stdlib/array/buffer' );\n* var ab = new ArrayBuffer( 10 );\n*\n* var buf = fromArrayBuffer( ab );\n* // returns <Buffer>\n*\n* @example\n* var ArrayBuffer = require( '@stdlib/array/buffer' );\n* var ab = new ArrayBuffer( 10 );\n*\n* var buf = fromArrayBuffer( ab, 2, 4 );\n* // returns <Buffer>\n*/\nfunction fromArrayBuffer( buf, byteOffset, length ) {\n\tvar offset;\n\tvar len;\n\tif ( !isArrayBuffer( buf ) ) {\n\t\tthrow new TypeError( 'invalid argument. First argument must be an ArrayBuffer. Value: `' + buf + '`' );\n\t}\n\tif ( arguments.length > 1 ) {\n\t\tif ( !isNonNegativeInteger( byteOffset ) ) {\n\t\t\tthrow new TypeError( 'invalid argument. Second argument must be a nonnegative integer. Value: `' + byteOffset + '`.' );\n\t\t}\n\t\tif ( byteOffset > buf.byteLength ) {\n\t\t\tthrow new RangeError( 'invalid argument. Second argument must not exceed the number of bytes in the input ArrayBuffer. Value: `' + byteOffset + '`.' );\n\t\t}\n\t\toffset = byteOffset;\n\t\tif ( arguments.length > 2 ) {\n\t\t\tif ( !isNonNegativeInteger( length ) ) {\n\t\t\t\tthrow new TypeError( 'invalid argument. Last argument must be a nonnegative integer. Value: `' + length + '`.' );\n\t\t\t}\n\t\t\tif ( length > buf.byteLength ) {\n\t\t\t\tthrow new RangeError( 'invalid argument. Last argument must not exceed the number of bytes in the input ArrayBuffer. Value: `' + length + '`.' );\n\t\t\t}\n\t\t\tlen = length;\n\t\t} else {\n\t\t\tlen = buf.byteLength - offset;\n\t\t}\n\t} else {\n\t\toffset = 0;\n\t\tlen = buf.byteLength;\n\t}\n\t// Address Node v5.x where providing an empty ArrayBuffer throws an error:\n\tif ( len === 0 && version < 6 ) {\n\t\treturn Buffer.from( [] );\n\t}\n\treturn Buffer.from( buf, offset, len );\n}\n\n\n// EXPORTS //\nexport default fromArrayBuffer;\n","import __var_0__ from '@stdlib/assert/is-arraybuffer';\nimport __var_1__ from '@stdlib/assert/is-nonnegative-integer';\nimport __var_2__ from '@stdlib/buffer/ctor';\nimport __var_3__ from '@stdlib/array/uint8';\nimport __var_4__ from '@stdlib/buffer/from-array';\nimport __var_5__ from './node_version.js';\n/**\n\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\nvar isArrayBuffer = __var_0__;\nvar isNonNegativeInteger = __var_1__.isPrimitive;\nvar Buffer = __var_2__;\nvar Uint8Array = __var_3__;\nvar fromArray = __var_4__;\nvar version = __var_5__;\n\n\n// MAIN //\n\n/**\n* Allocates a buffer from an `ArrayBuffer`.\n*\n* ## Notes\n*\n* The behavior of this function varies across Node.js versions due to changes in the underlying Node.js APIs:\n*\n* -   `<3.0.0`: the function copies ArrayBuffer bytes to a new Buffer instance.\n* -   `>=3.0.0`: if provided a byte offset, the function copies `ArrayBuffer` bytes to a new `Buffer` instance; otherwise, the function returns a view of an `ArrayBuffer` without copying the underlying memory.\n* -   `<6.0.0`: if provided an empty ArrayBuffer, the function returns an empty Buffer which is **not** an ArrayBuffer view.\n*\n*\n* @param {ArrayBuffer} buf - ArrayBuffer instance\n* @param {NonNegativeInteger} [byteOffset=0] - index specifying the location of the first buffer byte\n* @param {NonNegativeInteger} [length=buf.byteLength] - number of buffer bytes\n* @throws {TypeError} first argument must be an ArrayBuffer\n* @throws {TypeError} second argument must be a nonnegative integer\n* @throws {RangeError} second argument must not exceed number of bytes in input ArrayBuffer\n* @throws {TypeError} last argument must be a nonnegative integer\n* @throws {RangeError} last argument must not exceed number of bytes in input ArrayBuffer\n* @returns {Buffer} new `Buffer` instance\n*\n* @example\n* var ArrayBuffer = require( '@stdlib/array/buffer' );\n* var ab = new ArrayBuffer( 10 );\n*\n* var buf = fromArrayBuffer( ab );\n* // returns <Buffer>\n*\n* @example\n* var ArrayBuffer = require( '@stdlib/array/buffer' );\n* var ab = new ArrayBuffer( 10 );\n*\n* var buf = fromArrayBuffer( ab, 2, 4 );\n* // returns <Buffer>\n*/\nfunction fromArrayBuffer( buf, byteOffset, length ) {\n\tvar len;\n\tif ( !isArrayBuffer( buf ) ) {\n\t\tthrow new TypeError( 'invalid argument. First argument must be an ArrayBuffer. Value: `' + buf + '`' );\n\t}\n\tif ( arguments.length > 1 ) {\n\t\tif ( !isNonNegativeInteger( byteOffset ) ) {\n\t\t\tthrow new TypeError( 'invalid argument. Second argument must be a nonnegative integer. Value: `' + byteOffset + '`.' );\n\t\t}\n\t\tif ( byteOffset > buf.byteLength ) {\n\t\t\tthrow new RangeError( 'invalid argument. Second argument must not exceed the number of bytes in the input ArrayBuffer. Value: `' + byteOffset + '`.' );\n\t\t}\n\t\tif ( arguments.length > 2 ) {\n\t\t\tif ( !isNonNegativeInteger( length ) ) {\n\t\t\t\tthrow new TypeError( 'invalid argument. Last argument must be a nonnegative integer. Value: `' + length + '`.' );\n\t\t\t}\n\t\t\tif ( length > buf.byteLength ) {\n\t\t\t\tthrow new RangeError( 'invalid argument. Last argument must not exceed the number of bytes in the input ArrayBuffer. Value: `' + length + '`.' );\n\t\t\t}\n\t\t\tlen = length;\n\t\t} else {\n\t\t\tlen = buf.byteLength - byteOffset;\n\t\t}\n\t\treturn fromArray( new Uint8Array( buf, byteOffset, len ) );\n\t}\n\tif ( version < 3 ) {\n\t\treturn fromArray( new Uint8Array( buf ) );\n\t}\n\t// Address Node <= v5.x where providing an empty ArrayBuffer throws an error:\n\tif ( buf.byteLength === 0 ) {\n\t\treturn new Buffer( [] ); // eslint-disable-line no-buffer-constructor\n\t}\n\treturn new Buffer( buf ); // eslint-disable-line no-buffer-constructor\n}\n\n\n// EXPORTS //\nexport default fromArrayBuffer;\n","import __var_0__ from './has_from.js';\nimport __var_1__ from './main.js';\nimport __var_2__ from './polyfill.js';\n/**\n\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n/**\n* Allocate a buffer from an `ArrayBuffer`.\n*\n* @module @stdlib/buffer/from-arraybuffer\n*\n* @example\n* var ArrayBuffer = require( '@stdlib/array/buffer' );\n* var arraybuffer2buffer = require( '@stdlib/buffer/from-arraybuffer' );\n*\n* var ab = new ArrayBuffer( 10 );\n* var buf = arraybuffer2buffer( ab );\n* // returns <Buffer>\n*/\n\n// MODULES //\nvar hasFrom = __var_0__;\nvar main = __var_1__;\nvar polyfill = __var_2__;\n\n\n// MAIN //\n\nvar arraybuffer2buffer;\nif ( hasFrom ) {\n\tarraybuffer2buffer = main;\n} else {\n\tarraybuffer2buffer = polyfill;\n}\n\n\n// EXPORTS //\nexport default arraybuffer2buffer;\n"]}