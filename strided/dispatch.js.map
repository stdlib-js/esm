{"version":3,"sources":["@stdlib/strided/dispatch/lib/index_of_types.js","@stdlib/strided/dispatch/lib/main.js","@stdlib/strided/dispatch/lib/index.js"],"names":["indexOfTypes","N","M","x","strideX1","strideX2","offsetX","y","strideY","offsetY","ix","iy","i","j","isNonNegativeInteger","__var_0__","isPrimitive","isPositiveInteger","__var_1__","isInteger","__var_2__","isFunctionArray","__var_3__","isFunction","__var_4__","isStringArray","__var_5__","primitives","isArrayLikeObject","__var_6__","abs","__var_7__","dtype","__var_8__","__var_9__","dispatch","fcns","types","data","nargs","nin","nout","strideArgs","hasOffsets","narrays","nfcns","iout","fcn","TypeError","Error","length","strides","offsets","arrays","dtypes","shape","argc","idx","v","f","arguments","push","RangeError","slice"],"mappings":"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","sourcesContent":["\n/**\n\n*\n* Copyright (c) 2020 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n/**\n* Returns the first row index at which a given one-dimensional array of types can be found in a two-dimensional reference array of types (or `-1` if not found).\n*\n* ## Notes\n*\n* -   The intended use case for this function is for type dispatch (i.e., given a set of array data types, find a matching interface according the interface's accepted array data types).\n* -   The function assumes that `x` is stored in row-major order.\n* -   The function assumes that the number of indexed elements in `y` equals the number of columns in `x`.\n* -   The function returns a row index. To convert to a linear index, multiply `strideX1` by the return value.\n*\n* @private\n* @param {NonNegativeInteger} N - number of rows in `x` (size of first dimension)\n* @param {NonNegativeInteger} M - number of columns in `x` (size of second dimension)\n* @param {ArrayLikeObject} x - input two-dimensional reference array\n* @param {integer} strideX1 - `x` stride length along first dimension\n* @param {integer} strideX2 - `x` stride length along second dimension\n* @param {NonNegativeInteger} offsetX - `x` starting index\n* @param {ArrayLikeObject} y - search array\n* @param {integer} strideY - `y` stride length\n* @param {NonNegativeInteger} offsetY - `y` starting index\n* @returns {integer} row index (if found) and `-1` otherwise\n*\n* @example\n* // Define a reference array to search:\n* var types = [\n*     'float64', 'float64', 'float64',\n*     'float32', 'float32', 'float32',\n*     'uint32', 'uint32', 'float64',\n*     'int32', 'int32', 'float64',\n*     'uint16', 'uint16', 'float64',\n*     'int16', 'int16', 'float64',\n*     'uint8', 'uint8', 'float64',\n*     'int8', 'int8', 'float64'\n* ];\n*\n* // Define reference array dimensions:\n* var N = 8; // rows\n* var M = 3; // columns\n*\n* // Define a search array:\n* y1 = [\n*     'float32', 'float32', 'float32',\n* ];\n*\n* // Find the list of types:\n* var r1 = indexOfTypes( N, M, types, M, 1, 0, y1, 1, 0 );\n* // returns 1\n*\n// Define a search array:\n* y2 = [\n*     'float32', 'float32', 'float64',\n* ];\n*\n* // Find the list of types:\n* var r2 = indexOfTypes( N, M, types, M, 1, 0, y2, 1, 0 );\n* // returns -1\n*/\nfunction indexOfTypes( N, M, x, strideX1, strideX2, offsetX, y, strideY, offsetY ) { // eslint-disable-line max-len\n\tvar ix;\n\tvar iy;\n\tvar i;\n\tvar j;\n\n\t// Search for the first row which matches `y`...\n\tix = offsetX;\n\tfor ( i = 0; i < N; i++ ) {\n\t\tiy = offsetY;\n\t\tfor ( j = 0; j < M; j++ ) {\n\t\t\tif ( x[ ix+(j*strideX2) ] !== y[ iy ] ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tiy += strideY;\n\t\t}\n\t\t// If we successfully iterated over all columns, then that means we've found a match...\n\t\tif ( j === M ) {\n\t\t\treturn i;\n\t\t}\n\t\tix += strideX1;\n\t}\n\treturn -1;\n}\n\n\n// EXPORTS //\nexport default indexOfTypes;\n","import __var_0__ from '@stdlib/assert/is-nonnegative-integer';\nimport __var_1__ from '@stdlib/assert/is-positive-integer';\nimport __var_2__ from '@stdlib/assert/is-integer';\nimport __var_3__ from '@stdlib/assert/is-function-array';\nimport __var_4__ from '@stdlib/assert/is-function';\nimport __var_5__ from '@stdlib/assert/is-string-array';\nimport __var_6__ from '@stdlib/assert/is-array-like-object';\nimport __var_7__ from '@stdlib/math/base/special/abs';\nimport __var_8__ from '@stdlib/ndarray/base/buffer-dtype';\nimport __var_9__ from './index_of_types.js';\n/**\n\n*\n* Copyright (c) 2020 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\nvar isNonNegativeInteger = __var_0__.isPrimitive;\nvar isPositiveInteger = __var_1__;\nvar isInteger = __var_2__.isPrimitive;\nvar isFunctionArray = __var_3__;\nvar isFunction = __var_4__;\nvar isStringArray = __var_5__.primitives;\nvar isArrayLikeObject = __var_6__;\nvar abs = __var_7__;\nvar dtype = __var_8__;\nvar indexOfTypes = __var_9__;\n\n\n// MAIN //\n\n/**\n* Returns a strided array function interface which performs multiple dispatch.\n*\n* @param {(FunctionArray|Function)} fcns - list of strided array functions\n* @param {StringArray} types - one-dimensional list of strided array argument data types\n* @param {(ArrayLikeObject|null)} data - strided array function data (e.g., callbacks)\n* @param {PositiveInteger} nargs - total number of strided array function interface arguments (including strides and offsets)\n* @param {NonNegativeInteger} nin - number of input strided arrays\n* @param {NonNegativeInteger} nout - number of output strided arrays\n* @throws {TypeError} first argument must be either a function or an array of functions\n* @throws {TypeError} second argument must be an array of strings\n* @throws {TypeError} third argument must be an array-like object or `null`\n* @throws {Error} third and first arguments must have the same number of elements\n* @throws {TypeError} fourth argument must be a positive integer\n* @throws {TypeError} fifth argument must be a nonnegative integer\n* @throws {TypeError} sixth argument must be a nonnegative integer\n* @throws {Error} fourth argument must be compatible with the specified number of input and output arrays\n* @throws {Error} number of types must match the number of functions times the total number of array arguments for each function\n* @throws {Error} interface must accept at least one strided input and/or output array\n* @returns {Function} strided array function interface\n*\n* @example\n* var unary = require( '@stdlib/strided/base/unary' );\n* var abs = require( '@stdlib/math/base/special/abs' );\n* var Float64Array = require( '@stdlib/array/float64' );\n*\n* var types = [\n*     'float64', 'float64'\n* ];\n*\n* var data = [\n*     abs\n* ];\n*\n* var strided = dispatch( unary, types, data, 5, 1, 1 );\n*\n* // ...\n*\n* var x = new Float64Array( [ -1.0, -2.0, -3.0, -4.0, -5.0 ] );\n* var y = new Float64Array( [ 0.0, 0.0, 0.0, 0.0, 0.0 ] );\n*\n* strided( x.length, x, 1, y, 1 );\n* // y => <Float64Array>[ 1.0, 2.0, 3.0, 4.0, 5.0 ]\n*/\nfunction dispatch( fcns, types, data, nargs, nin, nout ) {\n\tvar strideArgs;\n\tvar hasOffsets;\n\tvar narrays;\n\tvar nfcns;\n\tvar iout;\n\tvar fcn;\n\n\tif ( isFunction( fcns ) ) {\n\t\tfcn = fcns;\n\t} else if ( !isFunctionArray( fcns ) ) {\n\t\tthrow new TypeError( 'invalid argument. First argument must be either a function or an array of functions. Value: `' + fcns + '`.' );\n\t}\n\tif ( !isStringArray( types ) ) {\n\t\tthrow new TypeError( 'invalid argument. Second argument must be an array of strings. Value: `' + types + '`.' );\n\t}\n\tif ( !isArrayLikeObject( data ) && data !== null ) {\n\t\tthrow new TypeError( 'invalid argument. Third argument must be an array-like object or `null`. Value: `' + data + '`.' );\n\t}\n\tif ( !isPositiveInteger( nargs ) ) {\n\t\tthrow new TypeError( 'invalid argument. Fourth argument must be a positive integer. Value: `' + nargs + '`.' );\n\t}\n\tif ( !isNonNegativeInteger( nin ) ) {\n\t\tthrow new TypeError( 'invalid argument. Fifth argument must be a nonnegative integer. Value: `' + nin + '`.' );\n\t}\n\tif ( !isNonNegativeInteger( nout ) ) {\n\t\tthrow new TypeError( 'invalid argument. Sixth argument must be a nonnegative integer. Value: `' + nout + '`.' );\n\t}\n\tnarrays = nin + nout;\n\tif ( narrays === 0 ) {\n\t\tthrow new Error( 'invalid arguments. Interface must accept at least one strided input and/or output array. Based on the provided arguments, `nin+nout` equals `0`.' );\n\t}\n\tif ( fcn ) {\n\t\tnfcns = types.length / narrays;\n\t\tif ( !isInteger( nfcns ) ) {\n\t\t\tthrow new Error( 'invalid argument. Unexpected number of types. A type must be specified for each strided input and output array for each provided strided array function.' );\n\t\t}\n\t} else {\n\t\tnfcns = fcns.length;\n\t\tif ( types.length !== nfcns*narrays ) {\n\t\t\tthrow new Error( 'invalid argument. Unexpected number of types. A type must be specified for each strided input and output array for each provided strided array function.' );\n\t\t}\n\t}\n\tif ( data && data.length !== nfcns ) {\n\t\tthrow new Error( 'invalid argument. The third argument must have the same number of elements as the first argument.' );\n\t}\n\t// Determine whether the strided array interface includes offsets:\n\tif ( (narrays*2)+1 === nargs ) {\n\t\thasOffsets = false;\n\t} else if ( (narrays*3)+1 === nargs ) {\n\t\thasOffsets = true;\n\t} else {\n\t\tthrow new Error( 'invalid argument. Fourth argument is incompatible with the number of strided input and output arrays.' );\n\t}\n\t// Determine the \"stride\" for accessing related arguments:\n\tif ( hasOffsets ) {\n\t\tstrideArgs = 3;\n\t} else {\n\t\tstrideArgs = 2;\n\t}\n\t// Compute the index of the first output strided array argument:\n\tiout = ( nin*strideArgs ) + 1;\n\n\treturn dispatcher;\n\n\t/**\n\t* Strided array function interface which performs multiple dispatch.\n\t*\n\t* @private\n\t* @param {integer} N - number of indexed elements\n\t* @param {ArrayLikeObject} x - strided array\n\t* @param {integer} strideX - index increment for `x`\n\t* @param {...(ArrayLikeObject|integer|NonNegativeInteger)} args - array arguments (arrays, strides, and offsets)\n\t* @throws {Error} insufficient arguments\n\t* @throws {Error} too many arguments\n\t* @throws {TypeError} first argument must be an integer\n\t* @throws {TypeError} input array strides must be integers\n\t* @throws {TypeError} output array strides must be integers\n\t* @throws {TypeError} input array offsets must be nonnegative integers\n\t* @throws {TypeError} output array offsets must be nonnegative integers\n\t* @throws {TypeError} input array arguments must be array-like objects\n\t* @throws {TypeError} output array arguments must be array-like objects\n\t* @throws {RangeError} input array arguments must have sufficient elements based on the associated stride and the number of indexed elements\n\t* @throws {RangeError} output array arguments must have sufficient elements based on the associated stride and the number of indexed elements\n\t* @throws {TypeError} unable to resolve a strided array function supporting the provided array argument data types\n\t* @returns {(ArrayLikeObject|Array<ArrayLikeObject>|void)} destination array(s)\n\t*/\n\tfunction dispatcher() {\n\t\tvar strides;\n\t\tvar offsets;\n\t\tvar arrays;\n\t\tvar dtypes;\n\t\tvar shape;\n\t\tvar argc;\n\t\tvar idx;\n\t\tvar N;\n\t\tvar v;\n\t\tvar f;\n\t\tvar i;\n\t\tvar j;\n\n\t\targc = arguments.length;\n\t\tif ( argc !== nargs ) {\n\t\t\tif ( argc < nargs ) {\n\t\t\t\tthrow new Error( 'invalid invocation. Insufficient arguments.' );\n\t\t\t}\n\t\t\tthrow new Error( 'invalid invocation. Too many arguments.' );\n\t\t}\n\t\tN = arguments[ 0 ];\n\t\tif ( !isInteger( N ) ) {\n\t\t\tthrow new TypeError( 'invalid argument. First argument must be an integer.' );\n\t\t}\n\t\tshape = [ N ];\n\n\t\t// Strides for both input and output strided arrays are every `strideArgs` arguments beginning from the third argument...\n\t\tstrides = [];\n\t\tfor ( i = 2; i < nargs; i += strideArgs ) {\n\t\t\tv = arguments[ i ];\n\t\t\tif ( !isInteger( v ) ) {\n\t\t\t\tif ( i < iout ) {\n\t\t\t\t\tthrow new TypeError( 'invalid argument. Input array stride argument must be an integer.' );\n\t\t\t\t} else {\n\t\t\t\t\tthrow new TypeError( 'invalid argument. Output array stride argument must be an integer.' );\n\t\t\t\t}\n\t\t\t}\n\t\t\tstrides.push( v );\n\t\t}\n\t\tif ( hasOffsets ) {\n\t\t\t// Offsets for both input and output strided arrays are every `strideArgs` arguments beginning from the fourth argument...\n\t\t\toffsets = [];\n\t\t\tfor ( i = 3; i < nargs; i += strideArgs ) {\n\t\t\t\tv = arguments[ i ];\n\t\t\t\tif ( !isNonNegativeInteger( v ) ) {\n\t\t\t\t\tif ( i < iout ) {\n\t\t\t\t\t\tthrow new TypeError( 'invalid argument. Input array offset argument must be a nonnegative integer.' );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new TypeError( 'invalid argument. Output array offset argument must be a nonnegative integer.' );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\toffsets.push( v );\n\t\t\t}\n\t\t}\n\t\t// Input and output strided arrays are every `strideArgs` arguments beginning from the second argument...\n\t\tarrays = [];\n\t\tdtypes = [];\n\t\tfor ( i = 1; i < nargs; i += strideArgs ) {\n\t\t\tv = arguments[ i ];\n\t\t\tif ( !isArrayLikeObject( v ) ) {\n\t\t\t\tif ( i < iout ) {\n\t\t\t\t\tthrow new TypeError( 'invalid argument. Input array argument must be an array-like object.' );\n\t\t\t\t} else {\n\t\t\t\t\tthrow new TypeError( 'invalid argument. Output array argument must be an array-like object.' );\n\t\t\t\t}\n\t\t\t}\n\t\t\tj = (i-1) / strideArgs;\n\t\t\tif ( hasOffsets ) {\n\t\t\t\tidx = offsets[ j ] + ( (N-1)*strides[j] );\n\t\t\t\tif ( N > 0 && (idx < 0 || idx >= v.length) ) {\n\t\t\t\t\tif ( i < iout ) {\n\t\t\t\t\t\tthrow new RangeError( 'invalid argument. Input array argument has insufficient elements based on the associated stride and the number of indexed elements.' );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new RangeError( 'invalid argument. Output array argument has insufficient elements based on the associated stride and the number of indexed elements.' );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if ( (N-1)*abs(strides[j]) >= v.length ) {\n\t\t\t\tif ( i < iout ) {\n\t\t\t\t\tthrow new RangeError( 'invalid argument. Input array argument has insufficient elements based on the associated stride and the number of indexed elements.' );\n\t\t\t\t} else {\n\t\t\t\t\tthrow new RangeError( 'invalid argument. Output array argument has insufficient elements based on the associated stride and the number of indexed elements.' );\n\t\t\t\t}\n\t\t\t}\n\t\t\tarrays.push( v );\n\t\t\tdtypes.push( dtype( v ) );\n\t\t}\n\t\t// Resolve the strided array function satisfying the input array types:\n\t\tidx = indexOfTypes( nfcns, narrays, types, narrays, 1, 0, dtypes, 1, 0 ); // eslint-disable-line max-len\n\n\t\t// Check whether we were able to successfully resolve a strided array function:\n\t\tif ( idx < 0 ) {\n\t\t\tthrow new TypeError( 'invalid arguments. Unable to resolve a strided array function supporting the provided array argument data types.' );\n\t\t}\n\t\t// Retrieve the strided array function:\n\t\tif ( fcn ) {\n\t\t\tf = fcn;\n\t\t} else {\n\t\t\tf = fcns[ idx ];\n\t\t}\n\t\t// Evaluate the strided array function:\n\t\tif ( data ) {\n\t\t\tif ( hasOffsets ) {\n\t\t\t\tf( arrays, shape, strides, offsets, data[ idx ] );\n\t\t\t} else {\n\t\t\t\tf( arrays, shape, strides, data[ idx ] );\n\t\t\t}\n\t\t} else if ( hasOffsets ) {\n\t\t\tf( arrays, shape, strides, offsets );\n\t\t} else {\n\t\t\tf( arrays, shape, strides );\n\t\t}\n\t\tif ( nout === 1 ) {\n\t\t\treturn arrays[ narrays-1 ];\n\t\t}\n\t\tif ( nout === 0 ) {\n\t\t\treturn;\n\t\t}\n\t\treturn arrays.slice( nin );\n\t}\n}\n\n\n// EXPORTS //\nexport default dispatch;\n","import __var_0__ from './main.js';\n/**\n\n*\n* Copyright (c) 2020 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n/**\n* Create a strided array function interface which performs multiple dispatch.\n*\n* @module @stdlib/strided/dispatch\n*\n* @example\n* var dispatch = require( '@stdlib/strided/dispatch' );\n* var unary = require( '@stdlib/strided/base/unary' );\n* var abs = require( '@stdlib/math/base/special/abs' );\n* var Float64Array = require( '@stdlib/array/float64' );\n*\n* var types = [\n*     'float64', 'float64'\n* ];\n*\n* var data = [\n*     abs\n* ];\n*\n* var strided = dispatch( unary, types, data, 5, 1, 1 );\n*\n* // ...\n*\n* var x = new Float64Array( [ -1.0, -2.0, -3.0, -4.0, -5.0 ] );\n* var y = new Float64Array( [ 0.0, 0.0, 0.0, 0.0, 0.0 ] );\n*\n* strided( x.length, x, 1, y, 1 );\n* // y => <Float64Array>[ 1.0, 2.0, 3.0, 4.0, 5.0 ]\n*/\n\n// MODULES //\nvar dispatch = __var_0__;\n\n\n// EXPORTS //\nexport default dispatch;\n"]}