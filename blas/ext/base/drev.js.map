{"version":3,"sources":["@stdlib/blas/ext/base/drev/lib/drev.js","@stdlib/blas/ext/base/drev/lib/ndarray.js","@stdlib/blas/ext/base/drev/lib/index.js"],"names":["floor","__var_0__","M","drev","N","x","stride","tmp","ix","iy","m","n","i","offset","setReadOnly","__var_1__","ndarray","__var_2__"],"mappings":"gIAsBA,IAAIA,EAAQC,EAKRC,EAAI,EAqBR,SAASC,EAAMC,EAAGC,EAAGC,GACpB,IAAIC,EACAC,EACAC,EACAC,EACAC,EACAC,EAEJ,GAAKR,GAAK,EACT,OAAOC,EAKR,GAHAM,EAAIX,EAAOI,EAAE,GAGG,IAAXE,EAAe,CAKnB,GAHAG,EAAKL,EAAI,GADTM,EAAIC,EAAIT,GAIC,EACR,IAAMM,EAAK,EAAGA,EAAKE,EAAGF,IACrBD,EAAMF,EAAGG,GACTH,EAAGG,GAAOH,EAAGI,GACbJ,EAAGI,GAAOF,EACVE,GAAM,EAGR,GAAKE,EAAIT,EACR,OAAOG,EAER,IAAMG,EAAKE,EAAGF,EAAKG,EAAGH,GAAMN,EAC3BK,EAAMF,EAAGG,GACTH,EAAGG,GAAOH,EAAGI,GACbJ,EAAGI,GAAOF,EAEVA,EAAMF,EAAGG,EAAG,GACZH,EAAGG,EAAG,GAAMH,EAAGI,EAAG,GAClBJ,EAAGI,EAAG,GAAMF,EAEZA,EAAMF,EAAGG,EAAG,GACZH,EAAGG,EAAG,GAAMH,EAAGI,EAAG,GAClBJ,EAAGI,EAAG,GAAMF,EAEZE,GAAMP,EAEP,OAAOG,EAQR,IADAI,GAJCD,EADIF,EAAS,GACP,EAAEF,GAAKE,EAER,IAEMF,EAAE,GAAGE,EACXM,EAAI,EAAGA,EAAID,EAAGC,IACnBL,EAAMF,EAAGG,GACTH,EAAGG,GAAOH,EAAGI,GACbJ,EAAGI,GAAOF,EACVC,GAAMF,EACNG,GAAMH,EAEP,OAAOD,ECtFR,IAAIL,EAAQC,EAKRC,EAAI,EAsBR,SAASC,EAAMC,EAAGC,EAAGC,EAAQO,GAC5B,IAAIN,EACAC,EACAC,EACAC,EACAC,EACAC,EAEJ,GAAKR,GAAK,EACT,OAAOC,EAMR,GAJAM,EAAIX,EAAOI,EAAE,GACbI,EAAKK,EAGW,IAAXP,EAAe,CAKnB,GAHAG,EAAKD,EAAKJ,EAAI,GADdM,EAAIC,EAAIT,GAIC,EACR,IAAMU,EAAI,EAAGA,EAAIF,EAAGE,IACnBL,EAAMF,EAAGG,GACTH,EAAGG,GAAOH,EAAGI,GACbJ,EAAGI,GAAOF,EACVC,GAAMF,EACNG,GAAMH,EAGR,GAAKK,EAAIT,EACR,OAAOG,EAER,IAAMO,EAAIF,EAAGE,EAAID,EAAGC,GAAKV,EACxBK,EAAMF,EAAGG,GACTH,EAAGG,GAAOH,EAAGI,GACbJ,EAAGI,GAAOF,EAEVA,EAAMF,EAAGG,EAAG,GACZH,EAAGG,EAAG,GAAMH,EAAGI,EAAG,GAClBJ,EAAGI,EAAG,GAAMF,EAEZA,EAAMF,EAAGG,EAAG,GACZH,EAAGG,EAAG,GAAMH,EAAGI,EAAG,GAClBJ,EAAGI,EAAG,GAAMF,EAEZC,GAAMN,EACNO,GAAMP,EAEP,OAAOG,EAGR,IADAI,EAAKD,GAAOJ,EAAE,GAAGE,EACXM,EAAI,EAAGA,EAAID,EAAGC,IACnBL,EAAMF,EAAGG,GACTH,EAAGG,GAAOH,EAAGI,GACbJ,EAAGI,GAAOF,EACVC,GAAMF,EACNG,GAAMH,EAEP,OAAOD,ECnFR,IAAIS,EAAcb,EACdE,EAAOY,EACPC,EAAUC,EAKdH,EAAaX,EAAM,UAAWa","sourcesContent":["import __var_0__ from '@stdlib/math/base/special/floor';\n/**\n\n*\n* Copyright (c) 2020 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\nvar floor = __var_0__;\n\n\n// VARIABLES //\n\nvar M = 3;\n\n\n// MAIN //\n\n/**\n* Reverses a double-precision floating-point strided array in-place.\n*\n* @param {PositiveInteger} N - number of indexed elements\n* @param {Float64Array} x - input array\n* @param {integer} stride - index increment\n* @returns {Float64Array} input array\n*\n* @example\n* var Float64Array = require( '@stdlib/array/float64' );\n*\n* var x = new Float64Array( [ -2.0, 1.0, 3.0, -5.0, 4.0, 0.0, -1.0, -3.0 ] );\n*\n* drev( x.length, x, 1 );\n* // x => <Float64Array>[ -3.0, -1.0, 0.0, 4.0, -5.0, 3.0, 1.0, -2.0 ]\n*/\nfunction drev( N, x, stride ) {\n\tvar tmp;\n\tvar ix;\n\tvar iy;\n\tvar m;\n\tvar n;\n\tvar i;\n\n\tif ( N <= 0 ) {\n\t\treturn x;\n\t}\n\tn = floor( N/2 );\n\n\t// Use loop unrolling if the stride is equal to `1`...\n\tif ( stride === 1 ) {\n\t\tm = n % M;\n\t\tiy = N - 1;\n\n\t\t// If we have a remainder, run a clean-up loop...\n\t\tif ( m > 0 ) {\n\t\t\tfor ( ix = 0; ix < m; ix++ ) {\n\t\t\t\ttmp = x[ ix ];\n\t\t\t\tx[ ix ] = x[ iy ];\n\t\t\t\tx[ iy ] = tmp;\n\t\t\t\tiy -= 1;\n\t\t\t}\n\t\t}\n\t\tif ( n < M ) {\n\t\t\treturn x;\n\t\t}\n\t\tfor ( ix = m; ix < n; ix += M ) {\n\t\t\ttmp = x[ ix ];\n\t\t\tx[ ix ] = x[ iy ];\n\t\t\tx[ iy ] = tmp;\n\n\t\t\ttmp = x[ ix+1 ];\n\t\t\tx[ ix+1 ] = x[ iy-1 ];\n\t\t\tx[ iy-1 ] = tmp;\n\n\t\t\ttmp = x[ ix+2 ];\n\t\t\tx[ ix+2 ] = x[ iy-2 ];\n\t\t\tx[ iy-2 ] = tmp;\n\n\t\t\tiy -= M;\n\t\t}\n\t\treturn x;\n\t}\n\tif ( stride < 0 ) {\n\t\tix = (1-N) * stride;\n\t} else {\n\t\tix = 0;\n\t}\n\tiy = ix + ((N-1)*stride);\n\tfor ( i = 0; i < n; i++ ) {\n\t\ttmp = x[ ix ];\n\t\tx[ ix ] = x[ iy ];\n\t\tx[ iy ] = tmp;\n\t\tix += stride;\n\t\tiy -= stride;\n\t}\n\treturn x;\n}\n\n\n// EXPORTS //\nexport default drev;\n","import __var_0__ from '@stdlib/math/base/special/floor';\n/**\n\n*\n* Copyright (c) 2020 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\nvar floor = __var_0__;\n\n\n// VARIABLES //\n\nvar M = 3;\n\n\n// MAIN //\n\n/**\n* Reverses a double-precision floating-point strided array in-place.\n*\n* @param {PositiveInteger} N - number of indexed elements\n* @param {Float64Array} x - input array\n* @param {integer} stride - index increment\n* @param {NonNegativeInteger} offset - starting index\n* @returns {Float64Array} input array\n*\n* @example\n* var Float64Array = require( '@stdlib/array/float64' );\n*\n* var x = new Float64Array( [ 1.0, -2.0, 3.0, -4.0, 5.0, -6.0 ] );\n*\n* drev( 3, x, 1, x.length-3 );\n* // x => <Float64Array>[ 1.0, -2.0, 3.0, -6.0, 5.0, -4.0 ]\n*/\nfunction drev( N, x, stride, offset ) {\n\tvar tmp;\n\tvar ix;\n\tvar iy;\n\tvar m;\n\tvar n;\n\tvar i;\n\n\tif ( N <= 0 ) {\n\t\treturn x;\n\t}\n\tn = floor( N/2 );\n\tix = offset;\n\n\t// Use loop unrolling if the stride is equal to `1`...\n\tif ( stride === 1 ) {\n\t\tm = n % M;\n\t\tiy = ix + N - 1;\n\n\t\t// If we have a remainder, run a clean-up loop...\n\t\tif ( m > 0 ) {\n\t\t\tfor ( i = 0; i < m; i++ ) {\n\t\t\t\ttmp = x[ ix ];\n\t\t\t\tx[ ix ] = x[ iy ];\n\t\t\t\tx[ iy ] = tmp;\n\t\t\t\tix += stride;\n\t\t\t\tiy -= stride;\n\t\t\t}\n\t\t}\n\t\tif ( n < M ) {\n\t\t\treturn x;\n\t\t}\n\t\tfor ( i = m; i < n; i += M ) {\n\t\t\ttmp = x[ ix ];\n\t\t\tx[ ix ] = x[ iy ];\n\t\t\tx[ iy ] = tmp;\n\n\t\t\ttmp = x[ ix+1 ];\n\t\t\tx[ ix+1 ] = x[ iy-1 ];\n\t\t\tx[ iy-1 ] = tmp;\n\n\t\t\ttmp = x[ ix+2 ];\n\t\t\tx[ ix+2 ] = x[ iy-2 ];\n\t\t\tx[ iy-2 ] = tmp;\n\n\t\t\tix += M;\n\t\t\tiy -= M;\n\t\t}\n\t\treturn x;\n\t}\n\tiy = ix + ((N-1)*stride);\n\tfor ( i = 0; i < n; i++ ) {\n\t\ttmp = x[ ix ];\n\t\tx[ ix ] = x[ iy ];\n\t\tx[ iy ] = tmp;\n\t\tix += stride;\n\t\tiy -= stride;\n\t}\n\treturn x;\n}\n\n\n// EXPORTS //\nexport default drev;\n","import __var_0__ from '@stdlib/utils/define-nonenumerable-read-only-property';\nimport __var_1__ from './drev.js';\nimport __var_2__ from './ndarray.js';\n/**\n\n*\n* Copyright (c) 2020 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\nvar setReadOnly = __var_0__;\nvar drev = __var_1__;\nvar ndarray = __var_2__;\n\n\n// MAIN //\n\nsetReadOnly( drev, 'ndarray', ndarray );\n\n\n// EXPORTS //\nexport default drev;\n"]}