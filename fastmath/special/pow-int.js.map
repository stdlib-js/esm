{"version":3,"sources":["@stdlib/fastmath/special/pow-int/lib/pow.js","@stdlib/fastmath/special/pow-int/lib/index.js"],"names":["isnan","__var_0__","PINF","__var_1__","ZERO","ONE","pow","x","y","v","NaN"],"mappings":"wGAuBA,IAAIA,EAAQC,EACRC,EAAOC,EAKPC,EAAO,EACPC,EAAM,EAsIV,SAASC,EAAKC,EAAGC,GAChB,IAAIC,EAEJ,GAAKT,EAAOO,GACX,OAAOG,IAGR,GAAKF,EAAIJ,EAAO,CAEf,GADAI,GAAKA,EACM,IAAND,EAEJ,OADAA,EAAI,EAAMA,GACHC,EAAIH,KAAUA,EAEbE,EAGDL,EAERK,EAAI,EAAMA,OAGN,GAAKC,IAAMJ,EACf,OAAO,EAGR,IADAK,EAAI,EACID,IAAMJ,IAENI,EAAIH,KAAUA,IACpBI,GAAKF,GAENA,GAAKA,EACLC,IAAMH,EAEP,OAAOI,ECpJL,IAACH,EAAML","sourcesContent":["import __var_0__ from '@stdlib/math/base/assert/is-nan';\nimport __var_1__ from '@stdlib/constants/math/float64-pinf';\n/**\n\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\nvar isnan = __var_0__;\nvar PINF = __var_1__;\n\n\n// VARIABLES //\n\nvar ZERO = 0|0; // asm type annotation\nvar ONE = 1|0; // asm type annotation\n\n\n// MAIN //\n\n/**\n* Evaluates the exponential function.\n*\n* ## Method\n*\n* -   The exponential function is given by\n*\n*     ```tex\n*     z = x^y\n*     ```\n*\n*     where \\\\(x\\\\) is the base and \\\\(y\\\\) the exponent.\n*\n* -   First observe that a naive approach for exponentiation\n*\n*     ```tex\n*     5^5 = 5 \\cdot 5 \\cdot 5 \\cdot 5 \\cdot 5\n*     ```\n*\n*     requires \\\\(y-1\\\\) multiplications.\n*\n* -   We can reduce the number of multiplications by first computing \\\\(x2 = x \\cdot x\\\\).\n*\n*     ```tex\n*     5^5 = x2 \\cdot x2 \\cdot x\n*     ```\n*\n*     thus requiring only three multiplications.\n*\n* -   This observation may be generalized, such that, for a positive exponent \\\\(y\\\\),\n*\n*     ```tex\n*     x^y = \\begin{cases}\n*           x (x^2)^{\\frac{y-1}{2}}, & \\text{if $y$ is odd} \\\\\n*           (x^2)^{\\frac{y}{2}}, & \\text{if $y$ is even}\n*     \\end{cases}\n*     ```\n*\n* -   Note that the above generalization only involves powers of two. For example, in our working example, the powers are \\\\(1\\\\) and \\\\(4\\\\). To determine these powers, we observe that integer values, when stored in binary format, are simply sums of powers of two. For example, the integer \\\\(5\\\\) has the bit sequence\n*\n*     ```binarystring\n*     00000000000000000000000000000101\n*     ```\n*\n*     where \\\\(101\\\\) translates to\n*\n*     ```tex\n*     2^2 + 2^0 = 4 + 1 = 5\n*     ```\n*\n*     Thus, rather conveniently, the powers of two needed for exponentiation are easily derived from the binary representation of the integer exponent.\n*\n* -   The previous observation lends itself readily to an iterative exponentiation algorithm, referred to as **right-to-left binary exponentiation**. The algorithm is as follows:\n*\n*     ```text\n*     1. Examine the least significant bit to determine if we have a power of 2.\n*     2. If yes, compute an intermediate result.\n*     3. Square the base.\n*     4. Shift off the least significant bit (LSB).\n*     5. If the exponent is greater than 0, repeat steps 1-4.\n*     6. Return the intermediate result.\n*     ```\n*\n*     For example, consider \\\\(5^5 = 3125\\\\).\n*\n*     ```text\n*     Initialization: r = 1\n*     Iteration 1: y = 101 => r = 1*5, x = 5*5 = 25\n*     Iteration 2: y = 10 => x = 25*25 = 625\n*     Iteration 3: y = 1 => r = 5*625 = 3125, x = 625*625\n*     Return: r\n*     ```\n*\n*\n* ## Notes\n*\n* -   The above algorithm involves \\\\(\\lfloor \\log_2(y) \\rfloor\\\\) square operations and at most \\\\(\\lfloor \\log_2(y) \\rfloor\\\\) multiplications.\n*\n* -   The above algorithm may not return precise results due to an accumulation of error. For example,\n*\n*     ```javascript\n*     var y = pow( 10.0, 308 );\n*     // returns 1.0000000000000006e+308\n*     // expected 1.0e+308\n*     ```\n*\n*     If we compare the bit sequence of the returned value\n*\n*     ```binarystring\n*     0111111111100001110011001111001110000101111010111100100010100011\n*     ```\n*\n*     with the expected value\n*\n*     ```binarystring\n*     0111111111100001110011001111001110000101111010111100100010100000\n*     ```\n*\n*     we observe that the returned value differs in its last two bits.\n*\n*\n* @param {number} x - base\n* @param {integer32} y - exponent\n* @returns {number} function value\n*\n* @example\n* var v = pow( 2.0, 3 );\n* // returns 8.0\n*\n* @example\n* var v = pow( 3.14, 0 );\n* // returns 1.0\n*\n* @example\n* var v = pow( 2.0, -2 );\n* // returns 0.25\n*\n* @example\n* var v = pow( 0.0, 0 );\n* // returns 1.0\n*\n* @example\n* var v = pow( -3.14, 1 );\n* // returns -3.14\n*\n* @example\n* var v = pow( NaN, 0 );\n* // returns NaN\n*/\nfunction pow( x, y ) {\n\tvar v;\n\n\tif ( isnan( x ) ) {\n\t\treturn NaN;\n\t}\n\t// If the exponent is negative, use the reciprocal...\n\tif ( y < ZERO ) {\n\t\ty = -y;\n\t\tif ( x === 0.0 ) {\n\t\t\tx = 1.0 / x; // +-infinity\n\t\t\tif ( ( y & ONE ) === ONE ) {\n\t\t\t\t// Exponent is odd, so `x` keeps its sign:\n\t\t\t\treturn x;\n\t\t\t}\n\t\t\t// Exponent is even, so result is always positive:\n\t\t\treturn PINF;\n\t\t}\n\t\tx = 1.0 / x;\n\t}\n\t// If the exponent is zero, the result is always unity...\n\telse if ( y === ZERO ) {\n\t\treturn 1.0;\n\t}\n\tv = 1;\n\twhile ( y !== ZERO ) {\n\t\t// Check the least significant bit (LSB) to determine if \"on\" (if so, we have a power of 2)...\n\t\tif ( ( y & ONE ) === ONE ) {\n\t\t\tv *= x;\n\t\t}\n\t\tx *= x; // possible overflow\n\t\ty >>= ONE;\n\t}\n\treturn v;\n}\n\n\n// EXPORTS //\nexport default pow;\n","import __var_0__ from './pow.js';\n/**\n\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n/**\n* Evaluate the exponential function.\n*\n* @module @stdlib/fastmath/special/pow-int\n*\n* @example\n* var pow = require( '@stdlib/fastmath/special/pow-int' );\n*\n* var v = pow( 2.0, 3 );\n* // returns 8.0\n*\n* v = pow( 3.14, 0 );\n* // returns 1.0\n*\n* v = pow( 2.0, -2 );\n* // returns 0.25\n*\n* v = pow( 0.0, 0 );\n* // returns 1.0\n*\n* v = pow( -3.14, 1 );\n* // returns -3.14\n*\n* v = pow( NaN, 0 );\n* // returns NaN\n*/\n\n// MODULES //\nvar pow = __var_0__;\n\n\n// EXPORTS //\nexport default pow;\n"]}