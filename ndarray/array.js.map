{"version":3,"sources":["@stdlib/ndarray/array/lib/is_array_like_object.js","@stdlib/ndarray/array/lib/cast_buffer.js","@stdlib/ndarray/array/lib/copy_view.js","@stdlib/ndarray/array/lib/expand_shape.js","@stdlib/ndarray/array/lib/expand_strides.js","@stdlib/ndarray/array/lib/main.js","@stdlib/ndarray/array/lib/index.js"],"names":["PINF","__var_0__","isInteger","__var_1__","isArrayLikeObject","value","length","bufferCtors","allocUnsafe","castBuffer","buffer","len","dtype","ctor","out","i","push","copyView","arr","get","expandShape","ndims","shape","ndmin","abs","expandStrides","strides","order","N","s","j","hasOwnProp","isObject","isBoolean","__var_2__","isPrimitive","isArray","__var_3__","isNonNegativeInteger","__var_4__","isndarrayLike","__var_5__","shape2strides","__var_6__","strides2offset","__var_7__","strides2order","__var_8__","numel","__var_9__","__var_10__","mctor","__var_11__","isDataType","__var_12__","isOrder","__var_13__","isCastingMode","__var_14__","isAllowedCast","__var_15__","createBuffer","__var_16__","getType","__var_17__","arrayShape","__var_18__","flattenArray","__var_19__","__var_20__","defaults","__var_21__","__var_22__","__var_23__","__var_24__","__var_25__","array","options","offset","btype","nopts","opts","FLG","arguments","TypeError","casting","flatten","Error","codegen","mode","submode","copy","RangeError","data"],"mappings":"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","sourcesContent":["import __var_0__ from '@stdlib/constants/math/float64-pinf';\nimport __var_1__ from '@stdlib/math/base/assert/is-integer';\n/**\n\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\nvar PINF = __var_0__;\nvar isInteger = __var_1__;\n\n\n// MAIN //\n\n/**\n* Tests (loosely) if an input value is an array-like object.\n*\n* @private\n* @param {*} value - value to test\n* @returns {boolean} boolean indicating if an input value is an array-like object\n*\n* @example\n* var bool = isArrayLikeObject( [] );\n* // returns true\n*\n* @example\n* var bool = isArrayLikeObject( '' );\n* // returns false\n*/\nfunction isArrayLikeObject( value ) {\n\treturn (\n\t\ttypeof value === 'object' &&\n\t\tvalue !== null &&\n\t\ttypeof value.length === 'number' &&\n\t\tisInteger( value.length ) &&\n\t\tvalue.length >= 0 &&\n\t\tvalue.length < PINF\n\t);\n}\n\n\n// EXPORTS //\nexport default isArrayLikeObject;\n","import __var_0__ from '@stdlib/ndarray/base/buffer-ctors';\nimport __var_1__ from '@stdlib/buffer/alloc-unsafe';\n/**\n\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\nvar bufferCtors = __var_0__;\nvar allocUnsafe = __var_1__;\n\n\n// MAIN //\n\n/**\n* Casts buffer elements by copying those elements to a buffer of another data type.\n*\n* @private\n* @param {(Array|TypedArray|Buffer)} buffer - input buffer\n* @param {NonNegativeInteger} len - number of elements to cast\n* @param {string} dtype - data type\n* @returns {(Array|TypedArray|Buffer)} output buffer\n*\n* @example\n* var b = castBuffer( [ 1.0, 2.0, 3.0 ], 3, 'float64' );\n* // returns <Float64Array>[ 1.0, 2.0, 3.0 ]\n*/\nfunction castBuffer( buffer, len, dtype ) {\n\tvar ctor;\n\tvar out;\n\tvar i;\n\n\tctor = bufferCtors( dtype );\n\tif ( dtype === 'generic') {\n\t\tout = [];\n\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\tout.push( buffer[ i ] );\n\t\t}\n\t} else if ( dtype === 'binary' ) {\n\t\tout = allocUnsafe( len );\n\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\tout[ i ] = buffer[ i ];\n\t\t}\n\t} else {\n\t\tout = new ctor( len );\n\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\tout[ i ] = buffer[ i ];\n\t\t}\n\t}\n\treturn out;\n}\n\n\n// EXPORTS //\nexport default castBuffer;\n","import __var_0__ from '@stdlib/ndarray/base/buffer-ctors';\nimport __var_1__ from '@stdlib/buffer/alloc-unsafe';\n/**\n\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\nvar bufferCtors = __var_0__;\nvar allocUnsafe = __var_1__;\n\n\n// MAIN //\n\n/**\n* Copies an ndarray view to a data buffer.\n*\n* @private\n* @param {ndarray} arr - input ndarray\n* @param {string} dtype - data type\n* @returns {(Array|TypedArray|Buffer)} output data buffer\n*\n* @example\n* var ndarray = require( '@stdlib/ndarray/ctor' );\n*\n* var vector = ndarray( 'generic', 1 );\n*\n* var buffer = [ 1.0, 2.0, 3.0 ];\n* var shape = [ 3 ];\n* var strides = [ -1 ];\n* var vec = vector( buffer, shape, strides, 2, 'row-major' );\n*\n* var b = copyView( vec, 'float64' );\n* // returns <Float64Array>[ 3.0, 2.0, 1.0 ]\n*/\nfunction copyView( arr, dtype ) {\n\tvar ctor;\n\tvar len;\n\tvar out;\n\tvar i;\n\n\tctor = bufferCtors( dtype );\n\tlen = arr.length;\n\tif ( dtype === 'generic') {\n\t\tout = [];\n\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\tout.push( arr.get( i ) );\n\t\t}\n\t} else if ( dtype === 'binary' ) {\n\t\tout = allocUnsafe( len );\n\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\tout[ i ] = arr.get( i );\n\t\t}\n\t} else {\n\t\tout = new ctor( len );\n\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\tout[ i ] = arr.get( i );\n\t\t}\n\t}\n\treturn out;\n}\n\n\n// EXPORTS //\nexport default copyView;\n","\n/**\n\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MAIN //\n\n/**\n* Prepends singleton dimensions in order to satisfy a minimum number of dimensions.\n*\n* @private\n* @param {NonNegativeInteger} ndims - number of dimensions\n* @param {Array} shape - array dimensions\n* @param {NonNegativeInteger} ndmin - minimum number of dimensions\n* @returns {Array} output shape array\n*/\nfunction expandShape( ndims, shape, ndmin ) {\n\tvar out;\n\tvar i;\n\n\tout = [];\n\tfor ( i = 0; i < ndmin-ndims; i++ ) {\n\t\tout.push( 1 );\n\t}\n\tfor ( i = 0; i < ndims; i++ ) {\n\t\tout.push( shape[ i ] );\n\t}\n\treturn out;\n}\n\n\n// EXPORTS //\nexport default expandShape;\n","import __var_0__ from '@stdlib/math/base/special/abs';\n/**\n\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\nvar abs = __var_0__;\n\n\n// MAIN //\n\n/**\n* Expands a strides array to accommodate an expanded array shape (i.e., an array shape with prepended singleton dimensions).\n*\n* @private\n* @param {NonNegativeInteger} ndims - number of dimensions\n* @param {Array} shape - expanded array shape\n* @param {Array} strides - strides array\n* @param {string} order - memory layout order\n* @returns {Array} output strides array\n*\n* @example\n* var out = expandStrides( 4, [ 1, 1, 2, 2 ], [ 1, 2 ], 'column-major' );\n* // returns [ 1, 1, 1, 2 ]\n*\n* @example\n* var out = expandStrides( 4, [ 1, 1, 2, 2 ], [ 2, 1 ], 'row-major' );\n* // returns [ 4, 4, 2, 1 ]\n*/\nfunction expandStrides( ndims, shape, strides, order ) {\n\tvar out;\n\tvar N;\n\tvar s;\n\tvar i;\n\tvar j;\n\n\tN = strides.length;\n\tj = ndims - N;\n\tout = [];\n\tif ( order === 'row-major' ) {\n\t\ts = abs( strides[ 0 ] ) * shape[ j ]; // at `j` is the size of the first non-prepended dimension\n\t\tfor ( i = 0; i < j; i++ ) {\n\t\t\tout.push( s );\n\t\t}\n\t\tfor ( i = 0; i < N; i++ ) {\n\t\t\tout.push( strides[ i ] );\n\t\t}\n\t} else { // column-major\n\t\tfor ( i = 0; i < j; i++ ) {\n\t\t\tout.push( 1 );\n\t\t}\n\t\tfor ( i = 0; i < N; i++ ) {\n\t\t\tout.push( strides[ i ] );\n\t\t}\n\t}\n\treturn out;\n}\n\n\n// EXPORTS //\nexport default expandStrides;\n","import __var_0__ from '@stdlib/assert/has-own-property';\nimport __var_1__ from '@stdlib/assert/is-plain-object';\nimport __var_2__ from '@stdlib/assert/is-boolean';\nimport __var_3__ from '@stdlib/assert/is-array';\nimport __var_4__ from '@stdlib/assert/is-nonnegative-integer';\nimport __var_5__ from '@stdlib/assert/is-ndarray-like';\nimport __var_6__ from '@stdlib/ndarray/base/shape2strides';\nimport __var_7__ from '@stdlib/ndarray/base/strides2offset';\nimport __var_8__ from '@stdlib/ndarray/base/strides2order';\nimport __var_9__ from '@stdlib/ndarray/base/numel';\nimport __var_10__ from '@stdlib/ndarray/ctor';\nimport __var_11__ from '@stdlib/ndarray/memoized-ctor';\nimport __var_12__ from '@stdlib/ndarray/base/assert/is-data-type';\nimport __var_13__ from '@stdlib/ndarray/base/assert/is-order';\nimport __var_14__ from '@stdlib/ndarray/base/assert/is-casting-mode';\nimport __var_15__ from '@stdlib/ndarray/base/assert/is-allowed-data-type-cast';\nimport __var_16__ from '@stdlib/ndarray/base/buffer';\nimport __var_17__ from '@stdlib/ndarray/base/buffer-dtype';\nimport __var_18__ from '@stdlib/array/shape';\nimport __var_19__ from '@stdlib/utils/flatten-array';\nimport __var_20__ from './is_array_like_object.js';\nimport __var_21__ from './defaults.json';\nimport __var_22__ from './cast_buffer.js';\nimport __var_23__ from './copy_view.js';\nimport __var_24__ from './expand_shape.js';\nimport __var_25__ from './expand_strides.js';\n/**\n\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\nvar hasOwnProp = __var_0__;\nvar isObject = __var_1__;\nvar isBoolean = __var_2__.isPrimitive;\nvar isArray = __var_3__;\nvar isNonNegativeInteger = __var_4__.isPrimitive;\nvar isndarrayLike = __var_5__;\nvar shape2strides = __var_6__;\nvar strides2offset = __var_7__;\nvar strides2order = __var_8__;\nvar numel = __var_9__;\nvar ctor = __var_10__;\nvar mctor = __var_11__;\nvar isDataType = __var_12__;\nvar isOrder = __var_13__;\nvar isCastingMode = __var_14__;\nvar isAllowedCast = __var_15__;\nvar createBuffer = __var_16__;\nvar getType = __var_17__;\nvar arrayShape = __var_18__;\nvar flattenArray = __var_19__;\nvar isArrayLikeObject = __var_20__;\nvar defaults = __var_21__;\nvar castBuffer = __var_22__;\nvar copyView = __var_23__;\nvar expandShape = __var_24__;\nvar expandStrides = __var_25__;\n\n\n// MAIN //\n\n/**\n* Returns a multidimensional array.\n*\n* @param {(ArrayLikeObject|TypedArrayLike|Buffer|ndarrayLike)} [buffer] - data source\n* @param {Options} [options] - function options\n* @param {(ArrayLikeObject|TypedArrayLike|Buffer|ndarrayLike)} [options.buffer] - data source\n* @param {string} [options.dtype=\"float64\"] - underlying storage data type (if the input data is not of the same type, this option specifies the data type to which to cast the input data)\n* @param {string} [options.order=\"row-major\"] - specifies the memory layout of the array as either row-major (C-style) or column-major (Fortran-style)\n* @param {NonNegativeIntegerArray} [options.shape] - array shape\n* @param {boolean} [options.codegen=true] - boolean indicating whether to use code generation\n* @param {string} [options.mode=\"throw\"] - specifies how to handle indices which exceed array dimensions\n* @param {StringArray} [options.submode=[\"throw\"]] - specifies how to handle subscripts which exceed array dimensions on a per dimension basis\n* @param {boolean} [options.copy=false] - boolean indicating whether to copy source data to a new data buffer\n* @param {boolean} [options.flatten=true] - boolean indicating whether to automatically flatten generic array data sources\n* @param {NonNegativeInteger} [options.ndmin=0] - minimum number of dimensions\n* @param {string} [options.casting=\"safe\"] - casting rule used to determine what constitutes an acceptable cast\n* @throws {TypeError} options argument must be an object\n* @throws {TypeError} must provide valid options\n* @throws {Error} must provide either an array shape, data source, or both\n* @throws {Error} invalid cast\n* @throws {RangeError} data source must be compatible with specified meta data\n* @returns {ndarray} ndarray instance\n*\n* @example\n* var arr = array( [ [ 1, 2 ], [ 3, 4 ] ] );\n* // returns <ndarray>\n*\n* var v = arr.get( 0, 0 );\n* // returns 1\n*\n* @example\n* var opts = {\n*     'dtype': 'generic',\n*     'flatten': false\n* };\n*\n* var arr = array( [ [ 1, 2 ], [ 3, 4 ] ], opts );\n* // returns <ndarray>\n*\n* var v = arr.get( 0 );\n* // returns [ 1, 2 ]\n*\n* @example\n* var Float64Array = require( '@stdlib/array/float64' );\n*\n* var opts = {\n*     'shape': [ 2, 2 ]\n* };\n*\n* var arr = array( new Float64Array( [ 1.0, 2.0, 3.0, 4.0 ] ), opts );\n* // returns <ndarray>\n*\n* var v = arr.get( 0, 0 );\n* // returns 1.0\n*/\nfunction array() {\n\tvar ndarray;\n\tvar options;\n\tvar strides;\n\tvar buffer;\n\tvar offset;\n\tvar order;\n\tvar dtype;\n\tvar btype;\n\tvar shape;\n\tvar ndims;\n\tvar nopts;\n\tvar opts;\n\tvar len;\n\tvar ord;\n\tvar FLG;\n\n\tif ( arguments.length === 1 ) {\n\t\tif ( isArrayLikeObject( arguments[ 0 ] ) ) {\n\t\t\tbuffer = arguments[ 0 ];\n\t\t\toptions = {};\n\t\t} else {\n\t\t\toptions = arguments[ 0 ];\n\t\t\tif ( !isObject( options ) ) {\n\t\t\t\tthrow new TypeError( 'invalid argument. Must provide either a valid data source, options argument, or both. Value: `' + options + '`.' );\n\t\t\t}\n\t\t\tif ( hasOwnProp( options, 'buffer' ) ) {\n\t\t\t\tbuffer = options.buffer;\n\t\t\t\tif ( !isArrayLikeObject( buffer ) ) { // weak test\n\t\t\t\t\tthrow new TypeError( 'invalid option. `buffer` option must be an array-like object, typed-array-like, a Buffer, or an ndarray. Option: `' + buffer + '`.' );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tbuffer = arguments[ 0 ];\n\t\tif ( !isArrayLikeObject( buffer ) ) { // weak test\n\t\t\tthrow new TypeError( 'invalid option. Data source must be an array-like object, typed-array-like, a Buffer, or an ndarray. Value: `' + buffer + '`.' );\n\t\t}\n\t\toptions = arguments[ 1 ];\n\t\tif ( !isObject( options ) ) {\n\t\t\tthrow new TypeError( 'invalid argument. Options argument must be an object. Value: `' + options + '`.' );\n\t\t}\n\t\t// Note: we ignore whether `options` has a `buffer` property\n\t}\n\tif ( buffer ) {\n\t\tif ( isndarrayLike( buffer ) ) {\n\t\t\tbtype = buffer.dtype;\n\t\t\tFLG = true;\n\t\t} else {\n\t\t\tbtype = getType( buffer );\n\t\t\tFLG = false;\n\t\t}\n\t}\n\tnopts = {};\n\topts = {};\n\n\t// Validate some options before others...\n\tif ( hasOwnProp( options, 'casting' ) ) {\n\t\topts.casting = options.casting;\n\t\tif ( !isCastingMode( opts.casting ) ) {\n\t\t\tthrow new TypeError( 'invalid option. `casting` option must be a recognized casting mode. Option: `' + opts.casting + '`.' );\n\t\t}\n\t} else {\n\t\topts.casting = defaults.casting;\n\t}\n\tif ( hasOwnProp( options, 'flatten' ) ) {\n\t\topts.flatten = options.flatten;\n\t\tif ( !isBoolean( opts.flatten ) ) {\n\t\t\tthrow new TypeError( 'invalid option. `flatten` option must be a boolean. Option: `' + opts.flatten + '`.' );\n\t\t}\n\t} else {\n\t\topts.flatten = defaults.flatten;\n\t}\n\tif ( hasOwnProp( options, 'ndmin' ) ) {\n\t\topts.ndmin = options.ndmin;\n\t\tif ( !isNonNegativeInteger( opts.ndmin ) ) {\n\t\t\tthrow new TypeError( 'invalid option. `ndmin` option must be a nonnegative integer. Option: `' + opts.ndmin + '`.' );\n\t\t}\n\t\t// TODO: validate that minimum number of dimensions does not exceed the maximum number of possible dimensions (in theory, infinite; in practice, determined by max array length; see https://github.com/stdlib-js/stdlib/blob/ac350059877c036640775d6b30d0e98e840d07cf/lib/node_modules/%40stdlib/ndarray/ctor/lib/main.js#L57)\n\t} else {\n\t\topts.ndmin = defaults.ndmin;\n\t}\n\n\t// Validate the remaining options...\n\tif ( hasOwnProp( options, 'dtype' ) ) {\n\t\tdtype = options.dtype;\n\t\tif ( !isDataType( dtype ) ) {\n\t\t\tthrow new TypeError( 'invalid option. `dtype` option must be a recognized data type. Option: `' + dtype + '`.' );\n\t\t}\n\t\tif ( btype && !isAllowedCast( btype, dtype, opts.casting ) ) {\n\t\t\tthrow new Error( 'invalid option. Data type cast is not allowed. Casting mode: `' + opts.casting + '`. From: `' + btype + '`. To: `' + dtype + '`.' );\n\t\t}\n\t} else if ( btype ) {\n\t\t// TODO: reconcile difference in behavior when provided a generic array and no `dtype` option. Currently, we cast here, but do not allow casting a generic array (by default) when explicitly providing a `dtype` option.\n\n\t\t// Only cast generic array data sources when not provided an ndarray...\n\t\tif ( !FLG && btype === 'generic' ) {\n\t\t\tdtype = defaults.dtype;\n\t\t} else {\n\t\t\tdtype = btype;\n\t\t}\n\t} else {\n\t\tdtype = defaults.dtype;\n\t}\n\tif ( hasOwnProp( options, 'order' ) ) {\n\t\torder = options.order;\n\t\tif ( order === 'any' || order === 'same' ) {\n\t\t\tif ( FLG ) {\n\t\t\t\t// If the user indicated that \"any\" order suffices (meaning the user does not care about ndarray order), then we use the default order, unless the input ndarray is either unequivocally \"row-major\" or \"column-major\" or configured as such....\n\t\t\t\tif ( order === 'any' ) {\n\t\t\t\t\t// Compute the layout order in order to ascertain whether an ndarray can be considered both \"row-major\" and \"column-major\":\n\t\t\t\t\tord = strides2order( buffer.strides );\n\n\t\t\t\t\t// If the ndarray can be considered both \"row-major\" and \"column-major\", then use the default order; otherwise, use the ndarray's stated layout order...\n\t\t\t\t\tif ( ord === 'both' ) {\n\t\t\t\t\t\torder = defaults.order;\n\t\t\t\t\t} else {\n\t\t\t\t\t\torder = buffer.order;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Otherwise, use the same order as the provided ndarray...\n\t\t\t\telse if ( order === 'same' ) {\n\t\t\t\t\torder = buffer.order;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\torder = defaults.order;\n\t\t\t}\n\t\t} else if ( !isOrder( order ) ) {\n\t\t\tthrow new TypeError( 'invalid option. `order` option must be a recognized order. Option: `' + order + '`.' );\n\t\t}\n\t} else {\n\t\torder = defaults.order;\n\t}\n\tif ( hasOwnProp( options, 'codegen' ) ) {\n\t\tnopts.codegen = options.codegen;\n\t} else {\n\t\tnopts.codegen = defaults.codegen;\n\t}\n\tif ( hasOwnProp( options, 'mode' ) ) {\n\t\tnopts.mode = options.mode;\n\t} else {\n\t\tnopts.mode = defaults.mode;\n\t}\n\tif ( hasOwnProp( options, 'submode' ) ) {\n\t\tnopts.submode = options.submode;\n\t} else {\n\t\tnopts.submode = [ nopts.mode ];\n\t}\n\tif ( hasOwnProp( options, 'copy' ) ) {\n\t\topts.copy = options.copy;\n\t\tif ( !isBoolean( opts.copy ) ) {\n\t\t\tthrow new TypeError( 'invalid option. `copy` option must be a boolean. Option: `' + opts.copy + '`.' );\n\t\t}\n\t} else {\n\t\topts.copy = defaults.copy;\n\t}\n\t// If not provided a shape, infer from a provided data source...\n\tif ( hasOwnProp( options, 'shape' ) ) {\n\t\tshape = options.shape;\n\t\tif ( !isArrayLikeObject( shape ) ) { // weak test\n\t\t\tthrow new TypeError( 'invalid option. `shape` option must be an array-like object containing nonnegative integers. Option: `' + shape + '`.' );\n\t\t}\n\t\tndims = shape.length;\n\t\tlen = numel( shape );\n\t} else if ( buffer ) {\n\t\tif ( FLG ) {\n\t\t\tshape = buffer.shape;\n\t\t\tndims = buffer.ndims;\n\t\t\tlen = buffer.length;\n\t\t} else if ( opts.flatten && isArray( buffer ) ) {\n\t\t\tshape = arrayShape( buffer );\n\t\t\tndims = shape.length;\n\t\t\tlen = numel( shape );\n\t\t} else {\n\t\t\tndims = 1;\n\t\t\tlen = buffer.length;\n\t\t\tshape = [ len ]; // assume a 1-dimensional array (vector)\n\t\t}\n\t} else {\n\t\tthrow new Error( 'invalid arguments. Must provide either a data source, array shape, or both.' );\n\t}\n\t// Adjust the array shape to satisfy the minimum number of dimensions...\n\tif ( ndims < opts.ndmin ) {\n\t\tshape = expandShape( ndims, shape, opts.ndmin );\n\t\tndims = opts.ndmin;\n\t}\n\t// If not provided a data buffer, create it; otherwise, see if we need to cast a provided data buffer to another data type or perform a copy...\n\tif ( FLG ) {\n\t\tif ( buffer.length !== len ) {\n\t\t\tthrow new RangeError( 'invalid arguments. Array shape is incompatible with provided data source. Number of data source elements does not match array shape.' );\n\t\t}\n\t\tif ( btype !== dtype || opts.copy ) {\n\t\t\tbuffer = copyView( buffer, dtype );\n\t\t} else {\n\t\t\tstrides = buffer.strides;\n\t\t\toffset = buffer.offset;\n\t\t\tbuffer = buffer.data;\n\t\t\tif ( strides.length < ndims ) {\n\t\t\t\t// Account for augmented dimensions (note: expanding the strides array to account for prepended singleton dimensions does **not** affect the index offset):\n\t\t\t\tstrides = expandStrides( ndims, shape, strides, order );\n\t\t\t}\n\t\t}\n\t} else if ( buffer ) {\n\t\tif ( btype === 'generic' && opts.flatten ) {\n\t\t\tbuffer = flattenArray( buffer );\n\t\t}\n\t\tif ( buffer.length !== len ) {\n\t\t\tthrow new RangeError( 'invalid arguments. Array shape is incompatible with provided data source. Number of data source elements does not match array shape.' );\n\t\t}\n\t\tif ( btype !== dtype || opts.copy ) {\n\t\t\tbuffer = castBuffer( buffer, len, dtype );\n\t\t}\n\t} else {\n\t\tbuffer = createBuffer( dtype, len );\n\t}\n\t// If we have yet to determine array strides, we assume that we can compute the strides, along with the index offset, for a **contiguous** data source based solely on the array shape and specified memory layout order...\n\tif ( strides === void 0 ) {\n\t\tstrides = shape2strides( shape, order );\n\t\toffset = strides2offset( shape, strides );\n\t}\n\t// Use a heuristic to avoid memoization of highly-specialized ndarray constructors, thus effectively introducing \"fast\" and \"slow\" ndarray construction paths...\n\tif ( nopts.submode.length < 3 ) {\n\t\tndarray = mctor( dtype, ndims, nopts );\n\t\treturn new ndarray( buffer, shape, strides, offset, order );\n\t}\n\tndarray = ctor( dtype, ndims, nopts );\n\treturn new ndarray( buffer, shape, strides, offset, order );\n}\n\n\n// EXPORTS //\nexport default array;\n","import __var_0__ from './main.js';\n/**\n\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n/**\n* Multidimensional array.\n*\n* @module @stdlib/ndarray/array\n*\n* @example\n* var array = require( '@stdlib/ndarray/array' );\n*\n* var arr = array( [ [ 1, 2 ], [ 3, 4 ] ] );\n* // returns <ndarray>\n*\n* var v = arr.get( 0, 0 );\n* // returns 1\n*\n* @example\n* var array = require( '@stdlib/ndarray/array' );\n*\n* var opts = {\n*     'dtype': 'generic',\n*     'flatten': false\n* };\n*\n* var arr = array( [ [ 1, 2 ], [ 3, 4 ] ], opts );\n* // returns <ndarray>\n*\n* var v = arr.get( 0 );\n* // returns [ 1, 2 ]\n*\n* @example\n* var Float64Array = require( '@stdlib/array/float64' );\n* var array = require( '@stdlib/ndarray/array' );\n*\n* var opts = {\n*     'shape': [ 2, 2 ]\n* };\n*\n* var arr = array( new Float64Array( [ 1.0, 2.0, 3.0, 4.0 ] ), opts );\n* // returns <ndarray>\n*\n* var v = arr.get( 0, 0 );\n* // returns 1.0\n*/\n\n// MODULES //\nvar array = __var_0__;\n\n\n// EXPORTS //\nexport default array;\n"]}