// This file is a part of stdlib. License is Apache-2.0: http://www.apache.org/licenses/LICENSE-2.0
import e from"./../assert/has-own-property.js";import r from"./../assert/is-plain-object.js";import o from"./../assert/is-boolean.js";import t from"./../assert/is-array.js";import i from"./../assert/is-nonnegative-integer.js";import n from"./../assert/is-ndarray-like.js";import a from"./base/shape2strides.js";import s from"./base/strides2offset.js";import p from"./base/strides2order.js";import f from"./base/numel.js";import m from"./ctor.js";import d from"./memoized-ctor.js";import l from"./base/assert/is-data-type.js";import u from"./base/assert/is-order.js";import c from"./base/assert/is-casting-mode.js";import h from"./base/assert/is-allowed-data-type-cast.js";import g from"./base/buffer.js";import y from"./base/buffer-dtype.js";import b from"./../array/shape.js";import w from"./../utils/flatten-array.js";import v from"./../constants/math/float64-pinf.js";import j from"./../math/base/assert/is-integer.js";import E from"./base/buffer-ctors.js";import T from"./../buffer/alloc-unsafe.js";import O from"./../math/base/special/abs.js";var k=v,z=j;function V(e){return"object"==typeof e&&null!==e&&"number"==typeof e.length&&z(e.length)&&e.length>=0&&e.length<k}var A="safe",B=!0,D=!1,M="float64",N=!0,P="throw",R=0,x="row-major",C={casting:A,codegen:B,copy:D,dtype:M,flatten:N,mode:P,ndmin:R,order:x},F=E,q=T;function G(e,r,o){var t,i,n;if(t=F(o),"generic"===o)for(i=[],n=0;n<r;n++)i.push(e[n]);else if("binary"===o)for(i=q(r),n=0;n<r;n++)i[n]=e[n];else for(i=new t(r),n=0;n<r;n++)i[n]=e[n];return i}var H=E,I=T;function J(e,r){var o,t,i,n;if(o=H(r),t=e.length,"generic"===r)for(i=[],n=0;n<t;n++)i.push(e.get(n));else if("binary"===r)for(i=I(t),n=0;n<t;n++)i[n]=e.get(n);else for(i=new o(t),n=0;n<t;n++)i[n]=e.get(n);return i}function K(e,r,o){var t,i;for(t=[],i=0;i<o-e;i++)t.push(1);for(i=0;i<e;i++)t.push(r[i]);return t}var L=O;function Q(e,r,o,t){var i,n,a,s,p;if(p=e-(n=o.length),i=[],"row-major"===t){for(a=L(o[0])*r[p],s=0;s<p;s++)i.push(a);for(s=0;s<n;s++)i.push(o[s])}else{for(s=0;s<p;s++)i.push(1);for(s=0;s<n;s++)i.push(o[s])}return i}var S=e,U=r,W=o.isPrimitive,X=t,Y=i.isPrimitive,Z=n,$=a,_=s,ee=p,re=f,oe=m,te=d,ie=l,ne=u,ae=c,se=h,pe=g,fe=y,me=b,de=w,le=V,ue=C,ce=G,he=J,ge=K,ye=Q;function be(){var e,r,o,t,i,n,a,s,p,f,m,d,l;if(1===arguments.length)if(le(arguments[0]))o=arguments[0],e={};else{if(!U(e=arguments[0]))throw new TypeError("invalid argument. Must provide either a valid data source, options argument, or both. Value: `"+e+"`.");if(S(e,"buffer")&&(o=e.buffer,!le(o)))throw new TypeError("invalid option. `buffer` option must be an array-like object, typed-array-like, a Buffer, or an ndarray. Option: `"+o+"`.")}else{if(!le(o=arguments[0]))throw new TypeError("invalid option. Data source must be an array-like object, typed-array-like, a Buffer, or an ndarray. Value: `"+o+"`.");if(!U(e=arguments[1]))throw new TypeError("invalid argument. Options argument must be an object. Value: `"+e+"`.")}if(o&&(Z(o)?(a=o.dtype,l=!0):(a=fe(o),l=!1)),f={},m={},S(e,"casting")){if(m.casting=e.casting,!ae(m.casting))throw new TypeError("invalid option. `casting` option must be a recognized casting mode. Option: `"+m.casting+"`.")}else m.casting=ue.casting;if(S(e,"flatten")){if(m.flatten=e.flatten,!W(m.flatten))throw new TypeError("invalid option. `flatten` option must be a boolean. Option: `"+m.flatten+"`.")}else m.flatten=ue.flatten;if(S(e,"ndmin")){if(m.ndmin=e.ndmin,!Y(m.ndmin))throw new TypeError("invalid option. `ndmin` option must be a nonnegative integer. Option: `"+m.ndmin+"`.")}else m.ndmin=ue.ndmin;if(S(e,"dtype")){if(n=e.dtype,!ie(n))throw new TypeError("invalid option. `dtype` option must be a recognized data type. Option: `"+n+"`.");if(a&&!se(a,n,m.casting))throw new Error("invalid option. Data type cast is not allowed. Casting mode: `"+m.casting+"`. From: `"+a+"`. To: `"+n+"`.")}else n=a&&(l||"generic"!==a)?a:ue.dtype;if(S(e,"order")){if("any"===(i=e.order)||"same"===i)l?"any"===i?i="both"===ee(o.strides)?ue.order:o.order:"same"===i&&(i=o.order):i=ue.order;else if(!ne(i))throw new TypeError("invalid option. `order` option must be a recognized order. Option: `"+i+"`.")}else i=ue.order;if(S(e,"codegen")?f.codegen=e.codegen:f.codegen=ue.codegen,S(e,"mode")?f.mode=e.mode:f.mode=ue.mode,S(e,"submode")?f.submode=e.submode:f.submode=[f.mode],S(e,"copy")){if(m.copy=e.copy,!W(m.copy))throw new TypeError("invalid option. `copy` option must be a boolean. Option: `"+m.copy+"`.")}else m.copy=ue.copy;if(S(e,"shape")){if(s=e.shape,!le(s))throw new TypeError("invalid option. `shape` option must be an array-like object containing nonnegative integers. Option: `"+s+"`.");p=s.length,d=re(s)}else{if(!o)throw new Error("invalid arguments. Must provide either a data source, array shape, or both.");l?(s=o.shape,p=o.ndims,d=o.length):m.flatten&&X(o)?(p=(s=me(o)).length,d=re(s)):(p=1,s=[d=o.length])}if(p<m.ndmin&&(s=ge(p,s,m.ndmin),p=m.ndmin),l){if(o.length!==d)throw new RangeError("invalid arguments. Array shape is incompatible with provided data source. Number of data source elements does not match array shape.");a!==n||m.copy?o=he(o,n):(r=o.strides,t=o.offset,o=o.data,r.length<p&&(r=ye(p,s,r,i)))}else if(o){if("generic"===a&&m.flatten&&(o=de(o)),o.length!==d)throw new RangeError("invalid arguments. Array shape is incompatible with provided data source. Number of data source elements does not match array shape.");(a!==n||m.copy)&&(o=ce(o,d,n))}else o=pe(n,d);return void 0===r&&(r=$(s,i),t=_(s,r)),f.submode.length<3?new(te(n,p,f))(o,s,r,t,i):new(oe(n,p,f))(o,s,r,t,i)}var we=be;export default we;
//# sourceMappingURL=array.js.map