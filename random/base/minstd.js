// This file is a part of stdlib. License is Apache-2.0: http://www.apache.org/licenses/LICENSE-2.0
import e from"./../../utils/define-nonenumerable-read-only-property.js";import t from"./../../utils/define-nonenumerable-read-only-accessor.js";import n from"./../../utils/define-nonenumerable-read-write-accessor.js";import r from"./../../assert/has-own-property.js";import i from"./../../assert/is-plain-object.js";import o from"./../../assert/is-boolean.js";import a from"./../../assert/is-collection.js";import s from"./../../assert/is-positive-integer.js";import f from"./../../assert/is-int32array.js";import l from"./../../constants/math/int32-max.js";import m from"./../../array/int32.js";import p from"./../../blas/base/gcopy.js";import u from"./../../array/to-json.js";import E from"./../../math/base/special/floor.js";var h=l,g=E,c=h-1;function b(){return 0|g(1+c*Math.random())}var d=e,y=t,w=n,v=r,T=i,M=o.isPrimitive,j=a,N=s.isPrimitive,_=f,L=l,O=m,R=p,A=u,P=b,S=L-1|0,x=L-1|0,B=16807,Y=1,I=2,X=2,J=4,V=5;function k(e,t){var n;return n=t?"option":"argument",e.length<V+1?new RangeError("invalid "+n+". `state` array has insufficient length."):e[0]!==Y?new RangeError("invalid "+n+". `state` array has an incompatible schema version. Expected: "+Y+". Actual: "+e[0]+"."):e[1]!==I?new RangeError("invalid "+n+". `state` array has an incompatible number of sections. Expected: "+I+". Actual: "+e[1]+"."):1!==e[X]?new RangeError("invalid "+n+". `state` array has an incompatible state length. Expected: "+1..toString()+". Actual: "+e[X]+"."):e[J]!==e.length-V?new RangeError("invalid "+n+". `state` array length is incompatible with seed section length. Expected: "+(e.length-V)+". Actual: "+e[J]+"."):null}function z(e){var t,n,r,i,o,a;if(r={},arguments.length){if(!T(e))throw new TypeError("invalid argument. Options argument must be an object. Value: `"+e+"`.");if(v(e,"copy")&&(r.copy=e.copy,!M(e.copy)))throw new TypeError("invalid option. `copy` option must be a boolean. Option: `"+e.copy+"`.");if(v(e,"state")){if(n=e.state,r.state=!0,!_(n))throw new TypeError("invalid option. `state` option must be an Int32Array. Option: `"+n+"`.");if(a=k(n,!0))throw a;!1===r.copy?t=n:(t=new O(n.length),R(n.length,n,1,t,1)),n=new O(t.buffer,t.byteOffset+(X+1)*t.BYTES_PER_ELEMENT,1),i=new O(t.buffer,t.byteOffset+(J+1)*t.BYTES_PER_ELEMENT,n[J])}if(void 0===i)if(v(e,"seed"))if(i=e.seed,r.seed=!0,N(i)){if(i>x)throw new RangeError("invalid option. `seed` option must be a positive integer less than the maximum signed 32-bit integer. Option: `"+i+"`.");i|=0}else{if(!(j(i)&&i.length>0))throw new TypeError("invalid option. `seed` option must be either a positive integer less than the maximum signed 32-bit integer or an array-like object containing integer values less than the maximum signed 32-bit integer. Option: `"+i+"`.");o=i.length,(t=new O(V+o))[0]=Y,t[1]=I,t[X]=1,t[J]=o,R.ndarray(o,i,1,0,t,1,J+1),n=new O(t.buffer,t.byteOffset+(X+1)*t.BYTES_PER_ELEMENT,1),i=new O(t.buffer,t.byteOffset+(J+1)*t.BYTES_PER_ELEMENT,o),n[0]=i[0]}else i=0|P()}else i=0|P();return void 0===n&&((t=new O(V+1))[0]=Y,t[1]=I,t[X]=1,t[J]=1,t[J+1]=i,n=new O(t.buffer,t.byteOffset+(X+1)*t.BYTES_PER_ELEMENT,1),i=new O(t.buffer,t.byteOffset+(J+1)*t.BYTES_PER_ELEMENT,1),n[0]=i[0]),d(h,"NAME","minstd"),y(h,"seed",s),y(h,"seedLength",f),w(h,"state",p,u),y(h,"stateLength",l),y(h,"byteLength",m),d(h,"toJSON",E),d(h,"MIN",1),d(h,"MAX",L-1),d(h,"normalized",g),d(g,"NAME",h.NAME),y(g,"seed",s),y(g,"seedLength",f),w(g,"state",p,u),y(g,"stateLength",l),y(g,"byteLength",m),d(g,"toJSON",E),d(g,"MIN",(h.MIN-1)/S),d(g,"MAX",(h.MAX-1)/S),h;function s(){var e=t[J];return R(e,i,1,new O(e),1)}function f(){return t[J]}function l(){return t.length}function m(){return t.byteLength}function p(){var e=t.length;return R(e,t,1,new O(e),1)}function u(e){var o;if(!_(e))throw new TypeError("invalid argument. Must provide an Int32Array. Value: `"+e+"`.");if(o=k(e,!1))throw o;!1===r.copy?r.state&&e.length===t.length?R(e.length,e,1,t,1):(t=e,r.state=!0):(e.length!==t.length&&(t=new O(e.length)),R(e.length,e,1,t,1)),n=new O(t.buffer,t.byteOffset+(X+1)*t.BYTES_PER_ELEMENT,1),i=new O(t.buffer,t.byteOffset+(J+1)*t.BYTES_PER_ELEMENT,t[J])}function E(){var e={type:"PRNG"};return e.name=h.NAME,e.state=A(t),e.params=[],e}function h(){var e=0|n[0];return e=B*e%L|0,n[0]=e,0|e}function g(){return(h()-1)/S}}var G=z,q=b,C=G({seed:q()}),D=e,F=C,H=z;D(F,"factory",H);export default F;
//# sourceMappingURL=minstd.js.map