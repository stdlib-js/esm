{"version":3,"sources":["@stdlib/utils/async/group-by/lib/validate.js","@stdlib/utils/async/group-by/lib/limit.js","@stdlib/utils/async/group-by/lib/factory.js","@stdlib/utils/async/group-by/lib/group_by.js","@stdlib/utils/async/group-by/lib/index.js"],"names":["isObject","__var_0__","hasOwnProp","__var_1__","isBoolean","__var_2__","isPrimitive","isPositiveInteger","__var_3__","indexOf","__var_4__","returns","validate","opts","options","thisArg","series","TypeError","limit","join","logger","debug","collection","indicator","done","maxIndex","count","flg","lim","len","idx","out","i","length","next","v","j","cb","error","group","clbk","push","JSON","stringify","call","message","isFunction","isCollection","PINF","factory","err","f","arguments","groupByAsync","result","setReadOnly"],"mappings":"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","sourcesContent":["import __var_0__ from '@stdlib/assert/is-plain-object';\nimport __var_1__ from '@stdlib/assert/has-own-property';\nimport __var_2__ from '@stdlib/assert/is-boolean';\nimport __var_3__ from '@stdlib/assert/is-positive-integer';\nimport __var_4__ from '@stdlib/utils/index-of';\n/**\n\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\nvar isObject = __var_0__;\nvar hasOwnProp = __var_1__;\nvar isBoolean = __var_2__.isPrimitive;\nvar isPositiveInteger = __var_3__.isPrimitive;\nvar indexOf = __var_4__;\n\n\n// VARIABLES //\n\nvar returns = [ 'values', 'indices', '*' ];\n\n\n// MAIN //\n\n/**\n* Validates function options.\n*\n* @private\n* @param {Object} opts - destination object\n* @param {Options} options - function options\n* @param {*} [options.thisArg] - execution context\n* @param {PositiveInteger} [options.limit] - maximum number of pending invocations at any one time\n* @param {boolean} [options.series] - boolean indicating whether to wait for a previous invocation to complete before invoking a provided function for the next element in a collection\n* @param {string} [options.returns] - output format\n* @returns {(Error|null)} null or an error object\n*\n* @example\n* var opts = {};\n* var options = {\n*     'thisArg': {},\n*     'series': false,\n*     'limit': 10,\n*     'returns': '*'\n* };\n* var err = validate( opts, options );\n* if ( err ) {\n*     throw err;\n* }\n*/\nfunction validate( opts, options ) {\n\tif ( !isObject( options ) ) {\n\t\treturn new TypeError( 'invalid argument. Options must be an object. Value: `' + options + '`.' );\n\t}\n\tif ( hasOwnProp( options, 'thisArg' ) ) {\n\t\topts.thisArg = options.thisArg;\n\t}\n\tif ( hasOwnProp( options, 'series' ) ) {\n\t\topts.series = options.series;\n\t\tif ( !isBoolean( opts.series ) ) {\n\t\t\treturn new TypeError( 'invalid option. `series` option must be a boolean primitive. Option: `' + opts.series + '`.' );\n\t\t}\n\t}\n\tif ( hasOwnProp( options, 'limit' ) ) {\n\t\topts.limit = options.limit;\n\t\tif ( !isPositiveInteger( opts.limit ) ) {\n\t\t\treturn new TypeError( 'invalid option. `limit` option must be a positive integer. Option: `' + opts.limit + '`.' );\n\t\t}\n\t}\n\tif ( hasOwnProp( options, 'returns' ) ) {\n\t\topts.returns = options.returns;\n\t\tif ( indexOf( returns, opts.returns ) === -1 ) {\n\t\t\treturn new TypeError( 'invalid option. `returns` option must be one of the following: \"' + returns.join( '\", \"' ) + '\". Option: `' + opts.returns + '`.' );\n\t\t}\n\t}\n\treturn null;\n}\n\n\n// EXPORTS //\nexport default validate;\n","import __var_0__ from '@stdlib/vendor/debug.js';\nimport __var_1__ from '@stdlib/assert/has-own-property';\n/**\n\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\nvar logger = __var_0__;\nvar hasOwnProp = __var_1__;\n\n\n// VARIABLES //\n\nvar debug = logger( 'group-by-async:limit' );\n\n\n// MAIN //\n\n/**\n* Invokes an indicator function once for each element in a collection, limiting the number of concurrently pending functions.\n*\n* ## Notes\n*\n* -   We need to cache the collection value to prevent the edge case where, during the invocation of the indicator function, the element at index `i` is swapped for some other value. For some, that might be a feature; here, we take the stance that one should be less clever.\n* -   Checking for an \"own\" property is necessary to guard against the edge case where an indicator function returns a group identifier which matches a method or property on the `Object` prototype.\n*\n*\n* @private\n* @param {Collection} collection - input collection\n* @param {Options} opts - function options\n* @param {*} [opts.thisArg] - execution context\n* @param {PositiveInteger} [opts.limit] - maximum number of pending function invocations\n* @param {string} [options.returns] - output format\n* @param {Function} indicator - indicator function\n* @param {Callback} done - function to invoke upon completion or upon encountering an error\n* @returns {void}\n*/\nfunction limit( collection, opts, indicator, done ) {\n\tvar maxIndex;\n\tvar count;\n\tvar flg;\n\tvar lim;\n\tvar len;\n\tvar idx;\n\tvar out;\n\tvar i;\n\n\tlen = collection.length;\n\tdebug( 'Collection length: %d', len );\n\n\tout = {};\n\tif ( len === 0 ) {\n\t\tdebug( 'Finished processing a collection.' );\n\t\treturn done( null, out );\n\t}\n\tif ( len < opts.limit ) {\n\t\tlim = len;\n\t} else {\n\t\tlim = opts.limit;\n\t}\n\tdebug( 'Concurrency limit: %d', lim );\n\tdebug( 'Number of arguments: %d', indicator.length );\n\n\tmaxIndex = len - 1;\n\tcount = 0;\n\tidx = -1;\n\tfor ( i = 0; i < lim; i++ ) {\n\t\t// This guard is necessary to protect against synchronous functions which exhaust all collection elements...\n\t\tif ( idx < maxIndex ) {\n\t\t\tnext(); // eslint-disable-line callback-return\n\t\t}\n\t}\n\t/**\n\t* Callback to invoke a provided function for the next element in a collection.\n\t*\n\t* @private\n\t*/\n\tfunction next() {\n\t\tvar v;\n\t\tvar j;\n\n\t\tidx += 1;\n\t\tj = idx;\n\t\tv = collection[ j ];\n\n\t\tdebug( 'Collection element %d: %s.', j, JSON.stringify( v ) );\n\t\tif ( indicator.length === 2 ) {\n\t\t\tindicator.call( opts.thisArg, v, cb );\n\t\t} else if ( indicator.length === 3 ) {\n\t\t\tindicator.call( opts.thisArg, v, j, cb );\n\t\t} else {\n\t\t\tindicator.call( opts.thisArg, v, j, collection, cb );\n\t\t}\n\t\t/**\n\t\t* Callback invoked once a provided function finishes processing a collection element.\n\t\t*\n\t\t* @private\n\t\t* @param {*} [error] - error\n\t\t* @param {*} [group] - group\n\t\t* @returns {void}\n\t\t*/\n\t\tfunction cb( error, group ) {\n\t\t\tif ( flg ) {\n\t\t\t\t// Prevent further processing of collection elements:\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif ( error ) {\n\t\t\t\tflg = true;\n\t\t\t\treturn clbk( error );\n\t\t\t}\n\t\t\tdebug( 'Collection element %d group: %s.', j, group );\n\n\t\t\t// Default is to return values...\n\t\t\tif ( opts.returns === 'indices' ) {\n\t\t\t\tif ( hasOwnProp( out, group ) ) {\n\t\t\t\t\tout[ group ].push( j );\n\t\t\t\t} else {\n\t\t\t\t\tout[ group ] = [ j ];\n\t\t\t\t}\n\t\t\t} else if ( opts.returns === '*' ) {\n\t\t\t\tif ( hasOwnProp( out, group ) ) {\n\t\t\t\t\tout[ group ].push( [ j, v ] );\n\t\t\t\t} else {\n\t\t\t\t\tout[ group ] = [ [ j, v ] ];\n\t\t\t\t}\n\t\t\t} else if ( hasOwnProp( out, group ) ) {\n\t\t\t\tout[ group ].push( v );\n\t\t\t} else {\n\t\t\t\tout[ group ] = [ v ];\n\t\t\t}\n\t\t\tclbk();\n\t\t}\n\t}\n\n\t/**\n\t* Callback invoked once ready to process the next collection element.\n\t*\n\t* @private\n\t* @param {*} [error] - error\n\t* @returns {void}\n\t*/\n\tfunction clbk( error ) {\n\t\tif ( error ) {\n\t\t\tdebug( 'Encountered an error: %s', error.message );\n\t\t\treturn done( error );\n\t\t}\n\t\tcount += 1;\n\t\tdebug( 'Processed %d of %d collection elements.', count, len );\n\t\tif ( idx < maxIndex ) {\n\t\t\treturn next();\n\t\t}\n\t\tif ( count === len ) {\n\t\t\tdebug( 'Finished processing a collection.' );\n\t\t\treturn done( null, out );\n\t\t}\n\t}\n}\n\n\n// EXPORTS //\nexport default limit;\n","import __var_0__ from '@stdlib/assert/is-function';\nimport __var_1__ from '@stdlib/assert/is-collection';\nimport __var_2__ from '@stdlib/constants/math/float64-pinf';\nimport __var_3__ from './validate.js';\nimport __var_4__ from './limit.js';\n/**\n\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\nvar isFunction = __var_0__;\nvar isCollection = __var_1__;\nvar PINF = __var_2__;\nvar validate = __var_3__;\nvar limit = __var_4__;\n\n\n// MAIN //\n\n/**\n* Returns a function for grouping values according to an indicator function.\n*\n* ## Notes\n*\n* -   This function does **not** guarantee that execution is asynchronous. To do so, wrap the `done` callback in a function which either executes at the end of the current stack (e.g., `nextTick`) or during a subsequent turn of the event loop (e.g., `setImmediate`, `setTimeout`).\n*\n*\n* @param {Options} [options] - function options\n* @param {*} [options.thisArg] - execution context\n* @param {PositiveInteger} [options.limit] - maximum number of pending invocations at any one time\n* @param {boolean} [options.series=false] - boolean indicating whether to wait for a previous invocation to complete before invoking a provided function for the next element in a collection\n* @param {string} [options.returns=\"values\"] - if `values`, values are returned; if `indices`, indices are returned; if `*`, both indices and values are returned\n* @param {Function} indicator - indicator function specifying which group an element in the input collection belongs to\n* @throws {TypeError} options argument must be an object\n* @throws {TypeError} must provide valid options\n* @throws {TypeError} last argument must be a function\n* @returns {Function} function which invokes the indicator function once for each element in a collection\n*\n* @example\n* var readFile = require( '@stdlib/fs/read-file' );\n*\n* function indicator( file, next ) {\n*     var opts = {\n*         'encoding': 'utf8'\n*     };\n*     readFile( file, opts, onFile );\n*\n*     function onFile( error ) {\n*         if ( error ) {\n*             return next( null, 'nonreadable' );\n*         }\n*         next( null, 'readable' );\n*     }\n* }\n*\n* var opts = {\n*     'series': true\n* };\n*\n* // Create a `groupByAsync` function which invokes the indicator function for each collection element sequentially:\n* var groupByAsync = factory( opts, indicator );\n*\n* // Create a collection over which to iterate:\n* var files = [\n*     './beep.js',\n*     './boop.js'\n* ];\n*\n* // Define a callback which handles results:\n* function done( error, result ) {\n*     if ( error ) {\n*         throw error;\n*     }\n*     console.log( result );\n* }\n*\n* // Try to read each element in `files`:\n* groupByAsync( files, done );\n*/\nfunction factory( options, indicator ) {\n\tvar opts;\n\tvar err;\n\tvar f;\n\n\topts = {};\n\tif ( arguments.length > 1 ) {\n\t\terr = validate( opts, options );\n\t\tif ( err ) {\n\t\t\tthrow err;\n\t\t}\n\t\tf = indicator;\n\t} else {\n\t\tf = options;\n\t}\n\tif ( !isFunction( f ) ) {\n\t\tthrow new TypeError( 'invalid argument. Last argument must be a function. Value: `'+f+'`.' );\n\t}\n\tif ( opts.series ) {\n\t\topts.limit = 1;\n\t} else if ( !opts.limit ) {\n\t\topts.limit = PINF;\n\t}\n\treturn groupByAsync;\n\n\t/**\n\t* Invokes an indicator function for each element in a collection.\n\t*\n\t* @private\n\t* @param {Collection} collection - input collection\n\t* @param {Callback} done - function to invoke upon completion\n\t* @throws {TypeError} first argument must be a collection\n\t* @throws {TypeError} last argument must be a function\n\t* @returns {void}\n\t*/\n\tfunction groupByAsync( collection, done ) {\n\t\tif ( !isCollection( collection ) ) {\n\t\t\tthrow new TypeError( 'invalid argument. First argument must be a collection. Value: `'+collection+'.`' );\n\t\t}\n\t\tif ( !isFunction( done ) ) {\n\t\t\tthrow new TypeError( 'invalid argument. Last argument must be a function. Value: `'+done+'`.' );\n\t\t}\n\t\treturn limit( collection, opts, f, clbk );\n\n\t\t/**\n\t\t* Callback invoked upon completion.\n\t\t*\n\t\t* @private\n\t\t* @param {*} [error] - error\n\t\t* @param {Object} result - group-by result\n\t\t* @returns {void}\n\t\t*/\n\t\tfunction clbk( error, result ) {\n\t\t\tif ( error ) {\n\t\t\t\treturn done( error );\n\t\t\t}\n\t\t\tdone( null, result );\n\t\t}\n\t}\n}\n\n\n// EXPORTS //\nexport default factory;\n","import __var_0__ from './factory.js';\n/**\n\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\nvar factory = __var_0__;\n\n\n// MAIN //\n\n/**\n* Groups values according to an indicator function.\n*\n* ## Notes\n*\n* -   This function does **not** guarantee that execution is asynchronous. To do so, wrap the `done` callback in a function which either executes at the end of the current stack (e.g., `nextTick`) or during a subsequent turn of the event loop (e.g., `setImmediate`, `setTimeout`).\n*\n*\n* @param {Collection} collection - input collection\n* @param {Options} [options] - function options\n* @param {*} [options.thisArg] - execution context\n* @param {PositiveInteger} [options.limit] - maximum number of pending invocations at any one time\n* @param {boolean} [options.series=false] - boolean indicating whether to wait for a previous invocation to complete before invoking a provided function for the next element in a collection\n* @param {string} [options.returns=\"values\"] - if `values`, values are returned; if `indices`, indices are returned; if `*`, both indices and values are returned\n* @param {Function} indicator - indicator function specifying which group an element in the input collection belongs to\n* @param {Callback} done - function to invoke upon completion\n* @throws {TypeError} first argument must be a collection\n* @throws {TypeError} options argument must be an object\n* @throws {TypeError} must provide valid options\n* @throws {TypeError} second-to-last argument must be a function\n* @throws {TypeError} last argument must be a function\n* @returns {void}\n*\n* @example\n* var readFile = require( '@stdlib/fs/read-file' );\n*\n* function done( error, result ) {\n*     if ( error ) {\n*         throw error;\n*     }\n*     console.log( result );\n* }\n*\n* function indicator( file, next ) {\n*     var opts = {\n*         'encoding': 'utf8'\n*     };\n*     readFile( file, opts, onFile );\n*\n*     function onFile( error ) {\n*         if ( error ) {\n*             return next( null, 'nonreadable' );\n*         }\n*         next( null, 'readable' );\n*     }\n* }\n*\n* var files = [\n*     './beep.js',\n*     './boop.js'\n* ];\n*\n* groupByAsync( files, indicator, done );\n*/\nfunction groupByAsync( collection, options, indicator, done ) {\n\tif ( arguments.length < 4 ) {\n\t\treturn factory( options )( collection, indicator );\n\t}\n\tfactory( options, indicator )( collection, done );\n}\n\n\n// EXPORTS //\nexport default groupByAsync;\n","import __var_0__ from '@stdlib/utils/define-nonenumerable-read-only-property';\nimport __var_1__ from './group_by.js';\nimport __var_2__ from './factory.js';\n/**\n\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n/**\n* Group values according to an indicator function.\n*\n* @module @stdlib/utils/async/group-by\n*\n* @example\n* var readFile = require( '@stdlib/fs/read-file' );\n* var groupByAsync = require( '@stdlib/utils/async/group-by' );\n*\n* var files = [\n*     './beep.js',\n*     './boop.js'\n* ];\n*\n* function done( error, result ) {\n*     if ( error ) {\n*         throw error;\n*     }\n*     console.log( result );\n* }\n*\n* function indicator( file, next ) {\n*     var opts = {\n*         'encoding': 'utf8'\n*     };\n*     readFile( file, opts, onFile );\n*\n*     function onFile( error ) {\n*         if ( error ) {\n*             return next( null, 'nonreadable' );\n*         }\n*         next( null, 'readable' );\n*     }\n* }\n*\n* groupByAsync( files, indicator, done );\n*/\n\n// MODULES //\nvar setReadOnly = __var_0__;\nvar groupByAsync = __var_1__;\nvar factory = __var_2__;\n\n\n// MAIN //\n\nsetReadOnly( groupByAsync, 'factory', factory );\n\n\n// EXPORTS //\nexport default groupByAsync;\n"]}