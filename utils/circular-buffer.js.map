{"version":3,"sources":["@stdlib/utils/circular-buffer/lib/main.js","@stdlib/utils/circular-buffer/lib/index.js"],"names":["isCollection","__var_0__","isPositiveInteger","__var_1__","isPrimitive","isNonNegativeInteger","__var_2__","setReadOnly","__var_3__","setReadOnlyAccessor","__var_4__","iteratorSymbol","__var_5__","MAX_ITERATIONS","__var_6__","CircularBuffer","buffer","i","this","_buffer","push","TypeError","_length","length","_count","_i","prototype","niters","iter","self","FLG","N","n","arguments","next","end","factory","done","value","iterator","v","out","k","type","data","toArray"],"mappings":"oWA8BA,IAAIA,EAAeC,EACfC,EAAoBC,EAAUC,YAC9BC,EAAuBC,EAAUF,YACjCG,EAAcC,EACdC,EAAsBC,EACtBC,EAAiBC,EACjBC,EAAiBC,EA8BrB,SAASC,EAAgBC,GACxB,IAAIC,EACJ,KAAOC,gBAAgBH,GACtB,OAAO,IAAIA,EAAgBC,GAE5B,GAAKd,EAAmBc,GAEvB,IADAE,KAAKC,QAAU,GACTF,EAAI,EAAGA,EAAID,EAAQC,IACxBC,KAAKC,QAAQC,KAAM,OAEd,CAAA,IAAKpB,EAAcgB,GAGzB,MAAM,IAAIK,UAAW,0JAA4JL,EAAS,MAF1LE,KAAKC,QAAUH,EAOhB,OAHAE,KAAKI,QAAUJ,KAAKC,QAAQI,OAC5BL,KAAKM,OAAS,EACdN,KAAKO,IAAM,EACJP,KA+BRX,EAAaQ,EAAeW,UAAW,SAAS,WAG/C,OAFAR,KAAKM,OAAS,EACdN,KAAKO,IAAM,EACJP,QAyBRT,EAAqBM,EAAeW,UAAW,SAAS,WACvD,OAAOR,KAAKM,UA2Bbf,EAAqBM,EAAeW,UAAW,QAAQ,WACtD,OAAOR,KAAKM,SAAWN,KAAKI,WA0C7Bf,EAAaQ,EAAeW,UAAW,YAAY,SAAmBC,GACrE,IAAIC,EACAC,EACAC,EACAC,EACAC,EACAf,EAEJ,GAAKgB,UAAUV,OAAS,CACvB,IAAMlB,EAAsBsB,GAC3B,MAAM,IAAIN,UAAW,iEAAmEM,EAAS,MAElGI,EAAIJ,OAEJI,EAAIlB,EAeL,OAbAgB,EAAOX,KAGPD,EAAIC,KAAKO,GACTO,EAAI,EAIJzB,EADAqB,EAAO,GACY,OAAQM,GAC3B3B,EAAaqB,EAAM,SAAUO,GACxBxB,GACJJ,EAAaqB,EAAMjB,EAAgByB,GAE7BR,EAQP,SAASM,IAGR,OADAF,GAAK,EACAF,GAAOE,EAAID,EACR,CACNM,MAAQ,GAILR,EAAKL,SAAWK,EAAKP,SACzBQ,GAAM,EACC,CACNO,MAAQ,KAGVpB,GAAKA,EAAE,GAAKY,EAAKP,QACV,CACNgB,MAAST,EAAKV,QAASF,GACvBoB,MAAQ,IAaV,SAASF,EAAKG,GAEb,OADAR,GAAM,EACDG,UAAUV,OACP,CACNe,MAASA,EACTD,MAAQ,GAGH,CACNA,MAAQ,GAUV,SAASD,IACR,OAAOP,EAAKU,SAAUR,OAkBxBtB,EAAqBM,EAAeW,UAAW,UAAU,WACxD,OAAOR,KAAKI,WA4Bbf,EAAaQ,EAAeW,UAAW,QAAQ,SAAeY,GAC7D,IAAIE,EAMJ,OAHAtB,KAAKO,IAAMP,KAAKO,GAAG,GAAKP,KAAKI,QAGxBJ,KAAKM,OAASN,KAAKI,SACvBJ,KAAKC,QAASD,KAAKO,IAAOa,OAC1BpB,KAAKM,QAAU,KAIhBgB,EAAItB,KAAKC,QAASD,KAAKO,IACvBP,KAAKC,QAASD,KAAKO,IAAOa,EACnBE,MAwBRjC,EAAaQ,EAAeW,UAAW,WAAW,WACjD,IAAIe,EACAC,EACAzB,EAGJ,IADAwB,EAAM,GACAxB,EAAI,EAAGA,GAAKC,KAAKM,OAAQP,IAE9ByB,GAAKxB,KAAKO,GAAGR,GAAKC,KAAKM,OACvBiB,EAAIrB,KAAMF,KAAKC,QAASuB,IAEzB,OAAOD,KA4BRlC,EAAaQ,EAAeW,UAAW,UAAU,WAChD,IAAIe,EAAM,CACVE,KAAW,mBAGX,OAFAF,EAAIlB,OAASL,KAAKI,QAClBmB,EAAIG,KAAO1B,KAAK2B,UACTJ,KCjYL,IAAC1B,EAAiBd","sourcesContent":["import __var_0__ from '@stdlib/assert/is-collection';\nimport __var_1__ from '@stdlib/assert/is-positive-integer';\nimport __var_2__ from '@stdlib/assert/is-nonnegative-integer';\nimport __var_3__ from '@stdlib/utils/define-nonenumerable-read-only-property';\nimport __var_4__ from '@stdlib/utils/define-nonenumerable-read-only-accessor';\nimport __var_5__ from '@stdlib/symbol/iterator';\nimport __var_6__ from '@stdlib/constants/math/float64-max';\n/**\n\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable no-restricted-syntax, no-invalid-this */\n\n'use strict';\n\n// MODULES //\nvar isCollection = __var_0__;\nvar isPositiveInteger = __var_1__.isPrimitive;\nvar isNonNegativeInteger = __var_2__.isPrimitive;\nvar setReadOnly = __var_3__;\nvar setReadOnlyAccessor = __var_4__;\nvar iteratorSymbol = __var_5__;\nvar MAX_ITERATIONS = __var_6__;\n\n\n// MAIN //\n\n/**\n* Circular buffer constructor.\n*\n* @constructor\n* @param {(PositiveInteger|Collection)} buffer - buffer size or an array-like object to use as the underlying buffer\n* @throws {TypeError} must provide either a valid buffer size or an array-like object\n* @returns {CircularBuffer} circular buffer instance\n*\n* @example\n* var b = new CircularBuffer( 3 );\n*\n* // Fill the buffer...\n* var v = b.push( 'foo' );\n* // returns undefined\n*\n* v = b.push( 'bar' );\n* // returns undefined\n*\n* v = b.push( 'beep' );\n* // returns undefined\n*\n* // Add another value to the buffer and return the removed element:\n* v = b.push( 'boop' );\n* // returns 'foo'\n*/\nfunction CircularBuffer( buffer ) {\n\tvar i;\n\tif ( !(this instanceof CircularBuffer) ) {\n\t\treturn new CircularBuffer( buffer );\n\t}\n\tif ( isPositiveInteger( buffer ) ) {\n\t\tthis._buffer = [];\n\t\tfor ( i = 0; i < buffer; i++ ) {\n\t\t\tthis._buffer.push( 0.0 ); // initialize with zeros, but could be any value (we're just ensuring a contiguous block of memory)\n\t\t}\n\t} else if ( isCollection( buffer ) ) {\n\t\tthis._buffer = buffer;\n\t} else {\n\t\tthrow new TypeError( 'invalid argument. Must provide either a valid buffer size (positive integer) or an array-like object which can serve as the underlying buffer. Value: `' + buffer + '`.' );\n\t}\n\tthis._length = this._buffer.length;\n\tthis._count = 0;\n\tthis._i = -1;\n\treturn this;\n}\n\n/**\n* Clears the buffer.\n*\n* @name clear\n* @memberof CircularBuffer.prototype\n* @type {Function}\n* @returns {CircularBuffer} circular buffer instance\n*\n* @example\n* var b = new CircularBuffer( 2 );\n*\n* // Add values to the buffer:\n* b.push( 'foo' );\n* b.push( 'bar' );\n* b.push( 'beep' );\n* b.push( 'boop' );\n*\n* // Get the number of elements currently in the buffer:\n* var n = b.count;\n* // returns 2\n*\n* // Clear the buffer:\n* b.clear();\n*\n* // Get the number of buffer values:\n* n = b.count;\n* // returns 0\n*/\nsetReadOnly( CircularBuffer.prototype, 'clear', function clear() {\n\tthis._count = 0;\n\tthis._i = -1; // NOTE: this ensures that we always fill the buffer starting at index `0`.\n\treturn this;\n});\n\n/**\n* Number of elements currently in the buffer.\n*\n* @name count\n* @memberof CircularBuffer.prototype\n* @type {NonNegativeInteger}\n*\n* @example\n* var b = new CircularBuffer( 4 );\n*\n* // Get the value count:\n* var n = b.count;\n* // returns 0\n*\n* // Add values to the buffer:\n* b.push( 'foo' );\n* b.push( 'bar' );\n*\n* // Get the value count:\n* n = b.count;\n* // returns 2\n*/\nsetReadOnlyAccessor( CircularBuffer.prototype, 'count', function get() {\n\treturn this._count;\n});\n\n/**\n* Boolean indicating whether a circular buffer is full.\n*\n* @name full\n* @memberof CircularBuffer.prototype\n* @type {boolean}\n*\n* @example\n* var b = new CircularBuffer( 3 );\n*\n* // Determine if the buffer is full:\n* var bool = b.full;\n* // returns false\n*\n* // Add values to the buffer:\n* b.push( 'foo' );\n* b.push( 'bar' );\n* b.push( 'beep' );\n* b.push( 'boop' );\n*\n* // Determine if the buffer is full:\n* bool = b.full;\n* // returns true\n*/\nsetReadOnlyAccessor( CircularBuffer.prototype, 'full', function get() {\n\treturn this._count === this._length;\n});\n\n/**\n* Returns an iterator for iterating over a circular buffer.\n*\n* ## Notes\n*\n* -   An iterator does not iterate over partially full buffers.\n*\n* @name iterator\n* @memberof CircularBuffer.prototype\n* @type {Function}\n* @param {NonNegativeInteger} [niters] - number of iterations\n* @throws {TypeError} must provide a nonnegative integer\n* @returns {Iterator} iterator\n*\n* @example\n* var b = new CircularBuffer( 3 );\n*\n* // Add values to the buffer:\n* b.push( 'foo' );\n* b.push( 'bar' );\n* b.push( 'beep' );\n* b.push( 'boop' );\n*\n* // Create an iterator:\n* var it = b.iterator( b.length );\n*\n* // Iterate over the buffer...\n* var v = it.next().value;\n* // returns 'bar'\n*\n* v = it.next().value;\n* // returns 'beep'\n*\n* v = it.next().value;\n* // returns 'boop'\n*\n* var bool = it.next().done;\n* // returns true\n*/\nsetReadOnly( CircularBuffer.prototype, 'iterator', function iterator( niters ) {\n\tvar iter;\n\tvar self;\n\tvar FLG;\n\tvar N;\n\tvar n;\n\tvar i;\n\n\tif ( arguments.length ) {\n\t\tif ( !isNonNegativeInteger( niters ) ) {\n\t\t\tthrow new TypeError( 'invalid argument. Must provide a nonnegative integer. Value: `' + niters + '`.' );\n\t\t}\n\t\tN = niters;\n\t} else {\n\t\tN = MAX_ITERATIONS;\n\t}\n\tself = this;\n\n\t// Initialize the iteration index and counter:\n\ti = this._i;\n\tn = 0;\n\n\t// Create an iterator protocol-compliant object:\n\titer = {};\n\tsetReadOnly( iter, 'next', next );\n\tsetReadOnly( iter, 'return', end );\n\tif ( iteratorSymbol ) {\n\t\tsetReadOnly( iter, iteratorSymbol, factory );\n\t}\n\treturn iter;\n\n\t/**\n\t* Returns an iterator protocol-compliant object containing the next iterated value.\n\t*\n\t* @private\n\t* @returns {Object} iterator protocol-compliant object\n\t*/\n\tfunction next() {\n\t\t/* eslint-disable no-underscore-dangle */\n\t\tn += 1;\n\t\tif ( FLG || n > N ) {\n\t\t\treturn {\n\t\t\t\t'done': true\n\t\t\t};\n\t\t}\n\t\t// If the buffer is only partially full, don't allow iteration over \"undefined\" elements (this ensures similar behavior with `toArray()`)...\n\t\tif ( self._count !== self._length ) {\n\t\t\tFLG = true;\n\t\t\treturn {\n\t\t\t\t'done': true\n\t\t\t};\n\t\t}\n\t\ti = (i+1) % self._length;\n\t\treturn {\n\t\t\t'value': self._buffer[ i ],\n\t\t\t'done': false\n\t\t};\n\n\t\t/* eslint-enable no-underscore-dangle */\n\t}\n\n\t/**\n\t* Finishes an iterator.\n\t*\n\t* @private\n\t* @param {*} [value] - value to return\n\t* @returns {Object} iterator protocol-compliant object\n\t*/\n\tfunction end( value ) {\n\t\tFLG = true;\n\t\tif ( arguments.length ) {\n\t\t\treturn {\n\t\t\t\t'value': value,\n\t\t\t\t'done': true\n\t\t\t};\n\t\t}\n\t\treturn {\n\t\t\t'done': true\n\t\t};\n\t}\n\n\t/**\n\t* Returns a new iterator.\n\t*\n\t* @private\n\t* @returns {Iterator} iterator\n\t*/\n\tfunction factory() {\n\t\treturn self.iterator( N );\n\t}\n});\n\n/**\n* Circular buffer length (capacity).\n*\n* @name length\n* @memberof CircularBuffer.prototype\n* @type {NonNegativeInteger}\n*\n* @example\n* var b = new CircularBuffer( 4 );\n*\n* // Get the buffer capacity:\n* var len = b.length;\n* // returns 4\n*/\nsetReadOnlyAccessor( CircularBuffer.prototype, 'length', function get() {\n\treturn this._length;\n});\n\n/**\n* Adds a value to the circular buffer.\n*\n* @name push\n* @memberof CircularBuffer.prototype\n* @type {Function}\n* @returns {(*|void)} removed element or undefined\n*\n* @example\n* var b = new CircularBuffer( 3 );\n*\n* // Fill the buffer:\n* var v = b.push( 'foo' );\n* // returns undefined\n*\n* v = b.push( 'bar' );\n* // returns undefined\n*\n* v = b.push( 'beep' );\n* // returns undefined\n*\n* // Add another value to the buffer and return the removed element:\n* v = b.push( 'boop' );\n* // returns 'foo'\n*/\nsetReadOnly( CircularBuffer.prototype, 'push', function push( value ) {\n\tvar v;\n\n\t// Compute the next buffer index:\n\tthis._i = (this._i+1) % this._length;\n\n\t// Check if we are still filling the buffer...\n\tif ( this._count < this._length ) {\n\t\tthis._buffer[ this._i ] = value;\n\t\tthis._count += 1;\n\t\treturn;\n\t}\n\t// Replace an existing buffer element...\n\tv = this._buffer[ this._i ];\n\tthis._buffer[ this._i ] = value;\n\treturn v;\n});\n\n/**\n* Returns an array of circular buffer values.\n*\n* @name toArray\n* @memberof CircularBuffer.prototype\n* @type {Function}\n* @returns {Array} circular buffer values\n*\n* @example\n* var b = new CircularBuffer( 3 );\n*\n* // Add values to the buffer:\n* b.push( 'foo' );\n* b.push( 'bar' );\n* b.push( 'beep' );\n* b.push( 'boop' );\n*\n* // Get an array of buffer values:\n* var vals = b.toArray();\n* // returns [ 'bar', 'beep', 'boop' ]\n*/\nsetReadOnly( CircularBuffer.prototype, 'toArray', function toArray() {\n\tvar out;\n\tvar k;\n\tvar i;\n\n\tout = [];\n\tfor ( i = 1; i <= this._count; i++ ) {\n\t\t// Note: in a full buffer, `count == length`; in a partially full buffer, we need to ensure we always start at index `0`\n\t\tk = (this._i+i) % this._count;\n\t\tout.push( this._buffer[ k ] );\n\t}\n\treturn out;\n});\n\n/**\n* Serializes a circular buffer as JSON.\n*\n* ## Notes\n*\n* -   `JSON.stringify()` implicitly calls this method when stringifying a `CircularBuffer` instance.\n*\n* @name toJSON\n* @memberof CircularBuffer.prototype\n* @type {Function}\n* @returns {Object} serialized circular buffer\n*\n* @example\n* var b = new CircularBuffer( 3 );\n*\n* // Add values to the buffer:\n* b.push( 'foo' );\n* b.push( 'bar' );\n* b.push( 'beep' );\n* b.push( 'boop' );\n*\n* // Serialize to JSON:\n* var o = b.toJSON();\n* // returns { 'type': 'circular-buffer', 'length': 3, 'data': [ 'bar', 'beep', 'boop' ] }\n*/\nsetReadOnly( CircularBuffer.prototype, 'toJSON', function toJSON() {\n\tvar out = {};\n\tout.type = 'circular-buffer';\n\tout.length = this._length;\n\tout.data = this.toArray();\n\treturn out;\n});\n\n\n// EXPORTS //\nexport default CircularBuffer;\n","import __var_0__ from './main.js';\n/**\n\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n/**\n* Circular buffer.\n*\n* @module @stdlib/utils/circular-buffer\n*\n* @example\n* var CircularBuffer = require( '@stdlib/utils/circular-buffer' );\n*\n* var b = new CircularBuffer( 3 );\n*\n* // Fill the buffer...\n* var v = b.push( 'foo' );\n* // returns undefined\n*\n* v = b.push( 'bar' );\n* // returns undefined\n*\n* v = b.push( 'beep' );\n* // returns undefined\n*\n* // Add another value to the buffer and return the removed element:\n* v = b.push( 'boop' );\n* // returns 'foo'\n*/\n\n// MODULES //\nvar CircularBuffer = __var_0__;\n\n\n// EXPORTS //\nexport default CircularBuffer;\n"]}