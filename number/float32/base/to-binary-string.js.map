{"version":3,"sources":["@stdlib/number/float32/base/to-binary-string/lib/div2.js","@stdlib/number/float32/base/to-binary-string/lib/mult2.js","@stdlib/number/float32/base/to-binary-string/lib/main.js","@stdlib/number/float32/base/to-binary-string/lib/index.js"],"names":["floor","__var_0__","div2","x","y","str","MAX_ITER","MAX_BITS","mult2","i","j","PINF","NINF","__var_1__","BIAS","__var_2__","abs","__var_3__","__var_4__","rpad","__var_5__","lpad","__var_6__","repeat","__var_7__","__var_8__","__var_9__","NUM_SIGNIFICAND_BITS","NUM_EXPONENT_BITS","toBinaryStringf","nbits","sign","exp","n","f","length","substring","totoBinaryStringf"],"mappings":"kaAsBA,IAAIA,EAAQC,EA4BZ,SAASC,EAAMC,GAKd,IAJA,IACIC,EADAC,EAAM,GAIFF,EAAI,GAIVE,GAHDD,EAAID,EAAI,MACRA,EAAIH,EAAOI,IAEJ,IAAMC,EAEN,IAAMA,EAGd,OAAOA,ECzCR,IAAIC,EAAW,IACXC,EAAW,GAoBf,SAASC,EAAOL,GACf,IAAIE,EACAD,EACAK,EACAC,EAGJ,GADAL,EAAM,GACK,IAANF,EACJ,OAAOE,EAKR,IAHAK,EAAIJ,EAGEG,EAAI,EAAGA,EAAIH,KAChBF,EAAQ,EAAJD,IACM,GACTA,EAAIC,EAAI,EACRC,GAAO,IACFK,IAAMJ,IACVI,EAAID,KAGLN,EAAIC,EACJC,GAAO,OAGG,IAAND,GAAaK,EAAEC,EAAIH,IAbEE,KAkB3B,OAAOJ,EC5CR,IAAIM,EAAOV,EACPW,EAAOC,EACPC,EAAOC,EACPC,EAAMC,EACNjB,EAAQkB,EACRC,EAAOC,EACPC,EAAOC,EACPC,EAASC,EACTtB,EAAOuB,EACPjB,EAAQkB,EAMRC,EAAuB,GACvBC,EAAoB,EAyDxB,SAASC,EAAiB1B,GACzB,IAAI2B,EACAC,EACA1B,EACA2B,EACAC,EACAC,EACAzB,EASJ,GALCsB,EADI5B,EAAI,GAAO,EAAIA,IAAMS,EAClB,IAEA,IAGHT,IAAMQ,GAAQR,IAAMS,EAIxB,OAAOmB,GAFPC,EAAMT,EAAQ,IAAKK,KACnBvB,EAAMkB,EAAQ,IAAKI,IAIpB,GAAKxB,GAAMA,EAIV,OAAO4B,GAFPC,EAAMT,EAAQ,IAAKK,KACnBvB,EAAM,IAAMkB,EAAQ,IAAKI,EAAqB,IAI/C,GAAW,IAANxB,EAIJ,OAAO4B,GAFPC,EAAMT,EAAQ,IAAKK,KACnBvB,EAAMkB,EAAQ,IAAKI,IAgBpB,GAPAO,GANA/B,EAAIa,EAAKb,KAGT8B,EAAIjC,EAAOG,IAMX8B,EAAI/B,EAAM+B,GACVC,EAAI1B,EAAO0B,GAGND,EAEJD,EAAMC,EAAEE,OAAS,MACX,CAEN,IAAM1B,EAAI,EAAGA,EAAIyB,EAAEC,OAAQ1B,IAC1B,GAAgB,MAAXyB,EAAGzB,GAAc,CACrBqB,EAAQrB,EAAI,EACZ,MAIFuB,GAAOF,EAwBR,OArBAzB,EAAM4B,EAAIC,EACLF,EAAM,GAELA,IAAQlB,IAEZgB,EAAQhB,EAAO,GAGhBT,EAAMA,EAAI+B,UAAWN,IAGrBzB,EAAMA,EAAI+B,UAAW,GAGtBJ,EAAM9B,EAAM8B,EAAMlB,GAOXiB,GANPC,EAAMX,EAAMW,EAAKJ,EAAmB,OAGpCvB,EAAMc,EAAMd,EAAKsB,EAAsB,KAAMS,UAAW,EAAGT,IC1HzD,IAACU,EAAoBpC","sourcesContent":["import __var_0__ from '@stdlib/math/base/special/floor';\n/**\n\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\nvar floor = __var_0__;\n\n\n// MAIN //\n\n/**\n* Converts a nonnegative integer to a literal bit representation using the divide-by-2 algorithm.\n*\n* @private\n* @param {NonNegativeInteger} x - nonnegative integer\n* @returns {BinaryString} bit representation\n*\n* @example\n* var v = div2( 3 );\n* // returns '11'\n*\n* @example\n* var v = div2( 0 );\n* // returns ''\n*\n* @example\n* var v = div2( 12 );\n* // returns '1100'\n*\n* @example\n* var v = div2( 188 );\n* // returns '10111100'\n*/\nfunction div2( x ) {\n\tvar str = '';\n\tvar y;\n\n\t// We repeatedly divide by 2 and check for a remainder. If a remainder exists, the number is odd and we add a '1' bit...\n\twhile ( x > 0 ) {\n\t\ty = x / 2.0;\n\t\tx = floor( y );\n\t\tif ( y === x ) {\n\t\t\tstr = '0' + str;\n\t\t} else {\n\t\t\tstr = '1' + str;\n\t\t}\n\t}\n\treturn str;\n}\n\n\n// EXPORTS //\nexport default div2;\n","\n/**\n\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// VARIABLES //\n\nvar MAX_ITER = 149; // 127+22 (subnormals) => BIAS+NUM_SIGNFICAND_BITS-1\nvar MAX_BITS = 24; // only 23 bits for fraction\n\n\n// MAIN //\n\n/**\n* Converts a fraction to a literal bit representation using the multiply-by-2 algorithm.\n*\n* @private\n* @param {number} x - number less than 1\n* @returns {BinaryString} bit representation\n*\n* @example\n* var v = mult2( 0.234375 );\n* // returns '001111'\n*\n* @example\n* var v = mult2( 0.0 );\n* // returns ''\n*/\nfunction mult2( x ) {\n\tvar str;\n\tvar y;\n\tvar i;\n\tvar j;\n\n\tstr = '';\n\tif ( x === 0.0 ) {\n\t\treturn str;\n\t}\n\tj = MAX_ITER;\n\n\t// Each time we multiply by 2 and find a ones digit, add a '1'; otherwise, add a '0'..\n\tfor ( i = 0; i < MAX_ITER; i++ ) {\n\t\ty = x * 2.0;\n\t\tif ( y >= 1.0 ) {\n\t\t\tx = y - 1.0;\n\t\t\tstr += '1';\n\t\t\tif ( j === MAX_ITER ) {\n\t\t\t\tj = i; // first '1'\n\t\t\t}\n\t\t} else {\n\t\t\tx = y;\n\t\t\tstr += '0';\n\t\t}\n\t\t// Stop when we have no more decimals to process or in the event we found a fraction which cannot be represented in a finite number of bits...\n\t\tif ( y === 1.0 || i-j > MAX_BITS ) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn str;\n}\n\n\n// EXPORTS //\nexport default mult2;\n","import __var_0__ from '@stdlib/constants/math/float32-pinf';\nimport __var_1__ from '@stdlib/constants/math/float32-ninf';\nimport __var_2__ from '@stdlib/constants/math/float32-exponent-bias';\nimport __var_3__ from '@stdlib/math/base/special/abs';\nimport __var_4__ from '@stdlib/math/base/special/floor';\nimport __var_5__ from '@stdlib/string/right-pad';\nimport __var_6__ from '@stdlib/string/left-pad';\nimport __var_7__ from '@stdlib/string/repeat';\nimport __var_8__ from './div2.js';\nimport __var_9__ from './mult2.js';\n/**\n\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\nvar PINF = __var_0__;\nvar NINF = __var_1__;\nvar BIAS = __var_2__;\nvar abs = __var_3__;\nvar floor = __var_4__;\nvar rpad = __var_5__;\nvar lpad = __var_6__;\nvar repeat = __var_7__;\nvar div2 = __var_8__;\nvar mult2 = __var_9__;\n\n\n// VARIABLES //\n\n// TODO: consider placing in external modules\nvar NUM_SIGNIFICAND_BITS = 23;\nvar NUM_EXPONENT_BITS = 8;\n\n\n// MAIN //\n\n/**\n* Returns a string giving the literal bit representation of a single-precision floating-point number.\n*\n* @param {number} x - input value\n* @returns {BinaryString} bit representation\n*\n* @example\n* var toFloat32 = require( '@stdlib/number/float64/base/to-float32' );\n* var str = toBinaryStringf( toFloat32( 4.0 ) );\n* // returns '01000000100000000000000000000000'\n*\n* @example\n* var toFloat32 = require( '@stdlib/number/float64/base/to-float32' );\n* var str = toBinaryStringf( toFloat32( 3.141592653589793 ) );\n* // returns '01000000010010010000111111011011'\n*\n* @example\n* var str = toBinaryStringf( toFloat32( -1e38 ) );\n* // returns '11111110100101100111011010011001'\n*\n* @example\n* var toFloat32 = require( '@stdlib/number/float64/base/to-float32' );\n* var str = toBinaryStringf( toFloat32( -3.14e-39 ) );\n* // returns '10000000001000100011000100001011'\n*\n* @example\n* var toFloat32 = require( '@stdlib/number/float64/base/to-float32' );\n* var str = toBinaryStringf( toFloat32( 1.4e-45 ) );\n* // returns '00000000000000000000000000000001'\n*\n* @example\n* var str = toBinaryStringf( 0.0 );\n* // returns '00000000000000000000000000000000'\n*\n* @example\n* var str = toBinaryStringf( -0.0 );\n* // returns '10000000000000000000000000000000'\n*\n* @example\n* var str = toBinaryStringf( NaN );\n* // returns '01111111110000000000000000000000'\n*\n* @example\n* var PINF = require( '@stdlib/constants/math/float32-pinf' );\n* var str = toBinaryStringf( PINF );\n* // returns '01111111100000000000000000000000'\n*\n* @example\n* var NINF = require( '@stdlib/constants/math/float32-ninf' );\n* var str = toBinaryStringf( NINF );\n* // returns '11111111100000000000000000000000'\n*/\nfunction toBinaryStringf( x ) {\n\tvar nbits;\n\tvar sign;\n\tvar str;\n\tvar exp;\n\tvar n;\n\tvar f;\n\tvar i;\n\n\t// Check for a negative value or negative zero...\n\tif ( x < 0.0 || 1.0/x === NINF ) {\n\t\tsign = '1';\n\t} else {\n\t\tsign = '0';\n\t}\n\t// Special case: +-infinity\n\tif ( x === PINF || x === NINF ) {\n\t\t// Based on IEEE 754-2008...\n\t\texp = repeat( '1', NUM_EXPONENT_BITS ); // all 1s\n\t\tstr = repeat( '0', NUM_SIGNIFICAND_BITS ); // all 0s\n\t\treturn sign + exp + str;\n\t}\n\t// Special case: NaN\n\tif ( x !== x ) {\n\t\t// Based on IEEE 754-2008...\n\t\texp = repeat( '1', NUM_EXPONENT_BITS ); // all 1s\n\t\tstr = '1' + repeat( '0', NUM_SIGNIFICAND_BITS-1 ); // can't be all 0s\n\t\treturn sign + exp + str;\n\t}\n\t// Special case: +-0\n\tif ( x === 0.0 ) {\n\t\t// Based on IEEE 754-2008...\n\t\texp = repeat( '0', NUM_EXPONENT_BITS ); // all 0s\n\t\tstr = repeat( '0', NUM_SIGNIFICAND_BITS ); // all 0s\n\t\treturn sign + exp + str;\n\t}\n\tx = abs( x );\n\n\t// Isolate the integer part (digits before the decimal):\n\tn = floor( x );\n\n\t// Isolate the fractional part (digits after the decimal):\n\tf = x - n;\n\n\t// Convert the integer and fractional parts to bit strings:\n\tn = div2( n );\n\tf = mult2( f );\n\n\t// Determine the exponent needed to normalize the integer+fractional parts...\n\tif ( n ) {\n\t\t// Move the decimal `d` digits to the left:\n\t\texp = n.length - 1;\n\t} else {\n\t\t// Find the first '1' bit...\n\t\tfor ( i = 0; i < f.length; i++ ) {\n\t\t\tif ( f[ i ] === '1' ) {\n\t\t\t\tnbits = i + 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t// Move the decimal `d` digits to the right:\n\t\texp = -nbits;\n\t}\n\t// Normalize the combined integer+fractional string...\n\tstr = n + f;\n\tif ( exp < 0 ) {\n\t\t// Handle subnormals...\n\t\tif ( exp <= -BIAS ) {\n\t\t\t// Cap the number of bits removed:\n\t\t\tnbits = BIAS - 1;\n\t\t}\n\t\t// Remove all leading zeros and the first '1' for normal values, and, for subnormals, remove at most BIAS-1 leading bits:\n\t\tstr = str.substring( nbits );\n\t} else {\n\t\t// Remove the leading '1' (implicit/hidden bit):\n\t\tstr = str.substring( 1 );\n\t}\n\t// Convert the exponent to a bit string:\n\texp = div2( exp + BIAS );\n\texp = lpad( exp, NUM_EXPONENT_BITS, '0' );\n\n\t// Fill in any trailing zeros and ensure we have only 23 fraction bits:\n\tstr = rpad( str, NUM_SIGNIFICAND_BITS, '0' ).substring( 0, NUM_SIGNIFICAND_BITS );\n\n\t// Return a bit representation:\n\treturn sign + exp + str;\n}\n\n\n// EXPORTS //\nexport default toBinaryStringf;\n","import __var_0__ from './main.js';\n/**\n\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n/**\n* Return a string giving the literal bit representation of a single-precision floating-point number.\n*\n* @module @stdlib/number/float32/base/to-binary-string\n*\n* @example\n* var toBinaryStringf = require( '@stdlib/number/float32/base/to-binary-string' );\n* var toFloat32 = require( '@stdlib/number/float64/base/to-float32' );\n*\n* var str = toBinaryStringf( toFloat32( 4.0 ) );\n* // returns '01000000100000000000000000000000'\n*\n* str = toBinaryStringf( toFloat32( 3.141592653589793 ) );\n* // returns '01000000010010010000111111011011'\n*\n* str = toBinaryStringf( toFloat32( -1.0e38 ) );\n* // returns '11111110100101100111011010011001'\n*\n* str = toBinaryStringf( toFloat32( -3.14e-39 ) );\n* // returns '10000000001000100011000100001011'\n*\n* str = toBinaryStringf( toFloat32( 1.4e-45 ) );\n* // returns '00000000000000000000000000000001'\n*\n* str = toBinaryStringf( 0.0 );\n* // returns '00000000000000000000000000000000'\n*\n* str = toBinaryStringf( -0.0 );\n* // returns '10000000000000000000000000000000'\n*\n* str = toBinaryStringf( NaN );\n* // returns '01111111110000000000000000000000'\n*\n* var PINF = require( '@stdlib/constants/math/float32-pinf' );\n* str = toBinaryStringf( PINF );\n* // returns '01111111100000000000000000000000'\n*\n* var NINF = require( '@stdlib/constants/math/float32-ninf' );\n* str = toBinaryStringf( NINF );\n* // returns '11111111100000000000000000000000'\n*/\n\n// MODULES //\nvar totoBinaryStringf = __var_0__;\n\n\n// EXPORTS //\nexport default totoBinaryStringf;\n"]}