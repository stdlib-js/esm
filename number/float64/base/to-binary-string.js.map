{"version":3,"sources":["@stdlib/number/float64/base/to-binary-string/lib/div2.js","@stdlib/number/float64/base/to-binary-string/lib/mult2.js","@stdlib/number/float64/base/to-binary-string/lib/main.js","@stdlib/number/float64/base/to-binary-string/lib/index.js"],"names":["floor","__var_0__","div2","x","y","str","MAX_ITER","MAX_BITS","mult2","i","j","PINF","NINF","__var_1__","BIAS","__var_2__","isnan","__var_3__","isNegativeZero","__var_4__","abs","__var_5__","__var_6__","rpad","__var_7__","lpad","__var_8__","repeat","__var_9__","__var_10__","__var_11__","NUM_EXPONENT_BITS","NUM_SIGNIFICAND_BITS","toBinaryString","nbits","sign","exp","n","f","length","substring"],"mappings":"shBAsBA,IAAIA,EAAQC,EA4BZ,SAASC,EAAMC,GAKd,IAJA,IACIC,EADAC,EAAM,GAIFF,EAAI,GAIVE,GAHDD,EAAID,EAAI,MACRA,EAAIH,EAAOI,IAEJ,IAAMC,EAEN,IAAMA,EAGd,OAAOA,ECzCR,IAAIC,EAAW,KACXC,EAAW,GAoBf,SAASC,EAAOL,GACf,IAAIE,EACAD,EACAK,EACAC,EAGJ,GADAL,EAAM,GACK,IAANF,EACJ,OAAOE,EAKR,IAHAK,EAAIJ,EAGEG,EAAI,EAAGA,EAAIH,KAChBF,EAAQ,EAAJD,IACM,GACTA,EAAIC,EAAI,EACRC,GAAO,IACFK,IAAMJ,IACVI,EAAID,KAGLN,EAAIC,EACJC,GAAO,OAGG,IAAND,GAAaK,EAAEC,EAAIH,IAbEE,KAiB3B,OAAOJ,ECzCR,IAAIM,EAAOV,EACPW,EAAOC,EACPC,EAAOC,EACPC,EAAQC,EACRC,EAAiBC,EACjBC,EAAMC,EACNrB,EAAQsB,EACRC,EAAOC,EACPC,EAAOC,EACPC,EAASC,EACT1B,EAAO2B,EACPrB,EAAQsB,EAMRC,EAAoB,GACpBC,EAAuB,GAmD3B,SAASC,EAAgB9B,GACxB,IAAI+B,EACAC,EACA9B,EACA+B,EACAC,EACAC,EACA7B,EASJ,GALC0B,EADIhC,EAAI,GAAOe,EAAgBf,GACxB,IAEA,IAGHA,IAAMQ,GAAQR,IAAMS,EAIxB,OAAOuB,GAFPC,EAAMT,EAAQ,IAAKI,KACnB1B,EAAMsB,EAAQ,IAAKK,IAIpB,GAAKhB,EAAOb,GAIX,OAAOgC,GAFPC,EAAMT,EAAQ,IAAKI,KACnB1B,EAAM,IAAMsB,EAAQ,IAAKK,EAAqB,IAI/C,GAAW,IAAN7B,EAIJ,OAAOgC,GAFPC,EAAMT,EAAQ,IAAKI,KACnB1B,EAAMsB,EAAQ,IAAKK,IAgBpB,GAPAM,GANAnC,EAAIiB,EAAKjB,KAGTkC,EAAIrC,EAAOG,IAMXkC,EAAInC,EAAMmC,GACVC,EAAI9B,EAAO8B,GAGND,EAEJD,EAAMC,EAAEE,OAAS,MACX,CAEN,IAAM9B,EAAI,EAAGA,EAAI6B,EAAEC,OAAQ9B,IAC1B,GAAgB,MAAX6B,EAAG7B,GAAc,CACrByB,EAAQzB,EAAI,EACZ,MAIF2B,GAAOF,EAwBR,OArBA7B,EAAMgC,EAAIC,EACLF,EAAM,GAELA,IAAQtB,IAEZoB,EAAQpB,EAAO,GAGhBT,EAAMA,EAAImC,UAAWN,IAGrB7B,EAAMA,EAAImC,UAAW,GAGtBJ,EAAMlC,EAAMkC,EAAMtB,GAOXqB,GANPC,EAAMX,EAAMW,EAAKL,EAAmB,OAGpC1B,EAAMkB,EAAMlB,EAAK2B,EAAsB,KAAMQ,UAAW,EAAGR,IC3HzD,IAACC,EAAiBhC","sourcesContent":["import __var_0__ from '@stdlib/math/base/special/floor';\n/**\n\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\nvar floor = __var_0__;\n\n\n// MAIN //\n\n/**\n* Converts a nonnegative integer to a literal bit representation using the divide-by-2 algorithm.\n*\n* @private\n* @param {number} x - nonnegative integer\n* @returns {BinaryString} bit representation\n*\n* @example\n* var v = div2( 3 );\n* // returns '11'\n*\n* @example\n* var v = div2( 0 );\n* // returns ''\n*\n* @example\n* var v = div2( 12 );\n* // returns '1100'\n*\n* @example\n* var v = div2( 188 );\n* // returns '10111100'\n*/\nfunction div2( x ) {\n\tvar str = '';\n\tvar y;\n\n\t// We repeatedly divide by 2 and check for a remainder. If a remainder exists, the number is odd and we add a '1' bit...\n\twhile ( x > 0 ) {\n\t\ty = x / 2;\n\t\tx = floor( y );\n\t\tif ( y === x ) {\n\t\t\tstr = '0' + str;\n\t\t} else {\n\t\t\tstr = '1' + str;\n\t\t}\n\t}\n\treturn str;\n}\n\n\n// EXPORTS //\nexport default div2;\n","\n/**\n\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// VARIABLES //\n\nvar MAX_ITER = 1075; // 1023+52 (subnormals) => BIAS+NUM_SIGNFICAND_BITS-1\nvar MAX_BITS = 54; // only 53 bits for fraction\n\n\n// MAIN //\n\n/**\n* Converts a fraction to a literal bit representation using the multiply-by-2 algorithm.\n*\n* @private\n* @param {number} x - number less than 1\n* @returns {BinaryString} bit representation\n*\n* @example\n* var v = mult2( 0.234375 );\n* // returns '001111'\n*\n* @example\n* var v = mult2( 0.0 );\n* // returns ''\n*/\nfunction mult2( x ) {\n\tvar str;\n\tvar y;\n\tvar i;\n\tvar j;\n\n\tstr = '';\n\tif ( x === 0.0 ) {\n\t\treturn str;\n\t}\n\tj = MAX_ITER;\n\n\t// Each time we multiply by 2 and find a ones digit, add a '1'; otherwise, add a '0'..\n\tfor ( i = 0; i < MAX_ITER; i++ ) {\n\t\ty = x * 2.0;\n\t\tif ( y >= 1.0 ) {\n\t\t\tx = y - 1.0;\n\t\t\tstr += '1';\n\t\t\tif ( j === MAX_ITER ) {\n\t\t\t\tj = i; // first '1'\n\t\t\t}\n\t\t} else {\n\t\t\tx = y;\n\t\t\tstr += '0';\n\t\t}\n\t\t// Stop when we have no more decimals to process or in the event we found a fraction which cannot be represented in a finite number of bits...\n\t\tif ( y === 1.0 || i-j > MAX_BITS ) {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn str;\n}\n\n\n// EXPORTS //\nexport default mult2;\n","import __var_0__ from '@stdlib/constants/math/float64-pinf';\nimport __var_1__ from '@stdlib/constants/math/float64-ninf';\nimport __var_2__ from '@stdlib/constants/math/float64-exponent-bias';\nimport __var_3__ from '@stdlib/math/base/assert/is-nan';\nimport __var_4__ from '@stdlib/math/base/assert/is-negative-zero';\nimport __var_5__ from '@stdlib/math/base/special/abs';\nimport __var_6__ from '@stdlib/math/base/special/floor';\nimport __var_7__ from '@stdlib/string/right-pad';\nimport __var_8__ from '@stdlib/string/left-pad';\nimport __var_9__ from '@stdlib/string/repeat';\nimport __var_10__ from './div2.js';\nimport __var_11__ from './mult2.js';\n/**\n\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\nvar PINF = __var_0__;\nvar NINF = __var_1__;\nvar BIAS = __var_2__;\nvar isnan = __var_3__;\nvar isNegativeZero = __var_4__;\nvar abs = __var_5__;\nvar floor = __var_6__;\nvar rpad = __var_7__;\nvar lpad = __var_8__;\nvar repeat = __var_9__;\nvar div2 = __var_10__;\nvar mult2 = __var_11__;\n\n\n// VARIABLES //\n\n// TODO: consider moving to external constants\nvar NUM_EXPONENT_BITS = 11;\nvar NUM_SIGNIFICAND_BITS = 52;\n\n\n// MAIN //\n\n/**\n* Returns a string giving the literal bit representation of a double-precision floating-point number.\n*\n* @param {number} x - input value\n* @returns {BinaryString} bit representation\n*\n* @example\n* var str = toBinaryString( 4.0 );\n* // returns '0100000000010000000000000000000000000000000000000000000000000000'\n*\n* @example\n* var str = toBinaryString( 3.141592653589793 );\n* // returns '0100000000001001001000011111101101010100010001000010110100011000'\n*\n* @example\n* var str = toBinaryString( -1.0e308 );\n* // returns '1111111111100001110011001111001110000101111010111100100010100000'\n*\n* @example\n* var str = toBinaryString( -3.14e-320 );\n* // returns '1000000000000000000000000000000000000000000000000001100011010011'\n*\n* @example\n* var str = toBinaryString( 5.0e-324 );\n* // returns '0000000000000000000000000000000000000000000000000000000000000001'\n*\n* @example\n* var str = toBinaryString( 0.0 );\n* // returns '0000000000000000000000000000000000000000000000000000000000000000'\n*\n* @example\n* var str = toBinaryString( -0.0 );\n* // returns '1000000000000000000000000000000000000000000000000000000000000000'\n*\n* @example\n* var str = toBinaryString( NaN );\n* // returns '0111111111111000000000000000000000000000000000000000000000000000'\n*\n* @example\n* var str = toBinaryString( Infinity );\n* // returns '0111111111110000000000000000000000000000000000000000000000000000'\n*\n* @example\n* var str = toBinaryString( -Infinity );\n* // returns '1111111111110000000000000000000000000000000000000000000000000000'\n*/\nfunction toBinaryString( x ) {\n\tvar nbits;\n\tvar sign;\n\tvar str;\n\tvar exp;\n\tvar n;\n\tvar f;\n\tvar i;\n\n\t// Check for a negative value or negative zero...\n\tif ( x < 0.0 || isNegativeZero( x ) ) {\n\t\tsign = '1';\n\t} else {\n\t\tsign = '0';\n\t}\n\t// Special case: +-infinity\n\tif ( x === PINF || x === NINF ) {\n\t\t// Based on IEEE 754-1985...\n\t\texp = repeat( '1', NUM_EXPONENT_BITS ); // all 1s\n\t\tstr = repeat( '0', NUM_SIGNIFICAND_BITS ); // all 0s\n\t\treturn sign + exp + str;\n\t}\n\t// Special case: NaN\n\tif ( isnan( x ) ) {\n\t\t// Based on IEEE 754-1985...\n\t\texp = repeat( '1', NUM_EXPONENT_BITS ); // all 1s\n\t\tstr = '1' + repeat( '0', NUM_SIGNIFICAND_BITS-1 ); // can't be all 0s\n\t\treturn sign + exp + str;\n\t}\n\t// Special case: +-0\n\tif ( x === 0 ) {\n\t\t// Based on IEEE 754-1985...\n\t\texp = repeat( '0', NUM_EXPONENT_BITS ); // all 0s\n\t\tstr = repeat( '0', NUM_SIGNIFICAND_BITS ); // all 0s\n\t\treturn sign + exp + str;\n\t}\n\tx = abs( x );\n\n\t// Isolate the integer part (digits before the decimal):\n\tn = floor( x );\n\n\t// Isolate the fractional part (digits after the decimal):\n\tf = x - n;\n\n\t// Convert the integer and fractional parts to bit strings:\n\tn = div2( n );\n\tf = mult2( f );\n\n\t// Determine the exponent needed to normalize the integer+fractional parts...\n\tif ( n ) {\n\t\t// Move the decimal `d` digits to the left:\n\t\texp = n.length - 1;\n\t} else {\n\t\t// Find the first '1' bit...\n\t\tfor ( i = 0; i < f.length; i++ ) {\n\t\t\tif ( f[ i ] === '1' ) {\n\t\t\t\tnbits = i + 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t// Move the decimal `d` digits to the right:\n\t\texp = -nbits;\n\t}\n\t// Normalize the combined integer+fractional string...\n\tstr = n + f;\n\tif ( exp < 0 ) {\n\t\t// Handle subnormals...\n\t\tif ( exp <= -BIAS ) {\n\t\t\t// Cap the number of bits removed:\n\t\t\tnbits = BIAS - 1;\n\t\t}\n\t\t// Remove all leading zeros and the first '1' for normal values, and, for subnormals, remove at most BIAS-1 leading bits:\n\t\tstr = str.substring( nbits );\n\t} else {\n\t\t// Remove the leading '1' (implicit/hidden bit):\n\t\tstr = str.substring( 1 );\n\t}\n\t// Convert the exponent to a bit string:\n\texp = div2( exp + BIAS );\n\texp = lpad( exp, NUM_EXPONENT_BITS, '0' );\n\n\t// Fill in any trailing zeros and ensure we have only 52 fraction bits:\n\tstr = rpad( str, NUM_SIGNIFICAND_BITS, '0' ).substring( 0, NUM_SIGNIFICAND_BITS );\n\n\t// Return a bit representation:\n\treturn sign + exp + str;\n}\n\n\n// EXPORTS //\nexport default toBinaryString;\n","import __var_0__ from './main.js';\n/**\n\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n/**\n* Return a string giving the literal bit representation of a double-precision floating-point number.\n*\n* @module @stdlib/number/float64/base/to-binary-string\n*\n* @example\n* var toBinaryString = require( '@stdlib/number/float64/base/to-binary-string' );\n*\n* var str = toBinaryString( 4.0 );\n* // returns '0100000000010000000000000000000000000000000000000000000000000000'\n*\n* str = toBinaryString( 3.141592653589793 );\n* // returns '0100000000001001001000011111101101010100010001000010110100011000'\n*\n* str = toBinaryString( -1.0e308 );\n* // returns '1111111111100001110011001111001110000101111010111100100010100000'\n*\n* str = toBinaryString( -3.14e-320 );\n* // returns '1000000000000000000000000000000000000000000000000001100011010011'\n*\n* str = toBinaryString( 5.0e-324 );\n* // returns '0000000000000000000000000000000000000000000000000000000000000001'\n*\n* str = toBinaryString( 0.0 );\n* // returns '0000000000000000000000000000000000000000000000000000000000000000'\n*\n* str = toBinaryString( -0.0 );\n* // returns '1000000000000000000000000000000000000000000000000000000000000000'\n*\n* str = toBinaryString( NaN );\n* // returns '0111111111111000000000000000000000000000000000000000000000000000'\n*\n* str = toBinaryString( Infinity );\n* // returns '0111111111110000000000000000000000000000000000000000000000000000'\n*\n* str = toBinaryString( -Infinity );\n* // returns '1111111111110000000000000000000000000000000000000000000000000000'\n*/\n\n// MODULES //\nvar toBinaryString = __var_0__;\n\n\n// EXPORTS //\nexport default toBinaryString;\n"]}