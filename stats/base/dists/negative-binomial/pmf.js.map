{"version":3,"sources":["@stdlib/stats/base/dists/negative-binomial/pmf/lib/ibeta_power_terms.js","@stdlib/stats/base/dists/negative-binomial/pmf/lib/ibeta_derivative.js","@stdlib/stats/base/dists/negative-binomial/pmf/lib/pmf.js","@stdlib/stats/base/dists/negative-binomial/pmf/lib/factory.js","@stdlib/stats/base/dists/negative-binomial/pmf/lib/index.js"],"names":["lanczosSumExpGScaled","__var_0__","expm1","__var_1__","log1p","__var_2__","sqrt","__var_3__","abs","__var_4__","exp","__var_5__","pow","__var_6__","max","__var_7__","min","__var_8__","ln","__var_9__","MAX_LN","__var_10__","MIN_LN","__var_11__","G","__var_12__","E","__var_13__","ibetaPowerTerms","a","b","x","y","normalized","result","smallA","ratio","agh","bgh","cgh","l1","l2","l3","p1","b1","b2","c","l","NaN","ibetaDerivative","f1","isnan","isNonNegativeInteger","pmf","r","p","constantFunction","factory","setReadOnly"],"mappings":"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","sourcesContent":["import __var_0__ from '@stdlib/math/base/special/gamma-lanczos-sum-expg-scaled';\nimport __var_1__ from '@stdlib/math/base/special/expm1';\nimport __var_2__ from '@stdlib/math/base/special/log1p';\nimport __var_3__ from '@stdlib/math/base/special/sqrt';\nimport __var_4__ from '@stdlib/math/base/special/abs';\nimport __var_5__ from '@stdlib/math/base/special/exp';\nimport __var_6__ from '@stdlib/math/base/special/pow';\nimport __var_7__ from '@stdlib/math/base/special/max';\nimport __var_8__ from '@stdlib/math/base/special/min';\nimport __var_9__ from '@stdlib/math/base/special/ln';\nimport __var_10__ from '@stdlib/constants/math/float64-max-ln';\nimport __var_11__ from '@stdlib/constants/math/float64-min-ln';\nimport __var_12__ from '@stdlib/constants/math/float64-gamma-lanczos-g';\nimport __var_13__ from '@stdlib/constants/math/float64-e';\n/**\n\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*\n*\n* ## Notice\n*\n* The original C++ code and copyright notice are from the [Boost library]{@link http://www.boost.org/doc/libs/1_62_0/boost/math/special_functions/beta.hpp}. The implementation has been modified for JavaScript.\n*\n* ```text\n* (C) Copyright John Maddock 2006.\n*\n* Use, modification and distribution are subject to the\n* Boost Software License, Version 1.0. (See accompanying file\n* LICENSE or copy at http://www.boost.org/LICENSE_1_0.txt)\n* ```\n*/\n\n'use strict';\n\n// MODULES //\nvar lanczosSumExpGScaled = __var_0__;\nvar expm1 = __var_1__;\nvar log1p = __var_2__;\nvar sqrt = __var_3__;\nvar abs = __var_4__;\nvar exp = __var_5__;\nvar pow = __var_6__;\nvar max = __var_7__;\nvar min = __var_8__;\nvar ln = __var_9__;\nvar MAX_LN = __var_10__;\nvar MIN_LN = __var_11__;\nvar G = __var_12__;\nvar E = __var_13__;\n\n\n// MAIN //\n\n/**\n* Computes the leading power terms in the incomplete beta function.\n*\n* When normalized,\n*\n* ```tex\n* \\frac{ x^a y^b }{ \\operatorname{Beta}(a,b) }\n* ```\n*\n* and otherwise\n*\n* ```tex\n* x^a y^b\n* ```\n*\n* ## Notes\n*\n* -   Almost all of the error in the incomplete beta comes from this function, particularly when \\\\( a \\\\) and \\\\( b \\\\) are large. Computing large powers are _hard_ though, and using logarithms just leads to horrendous cancellation errors.\n*\n* -   For \\\\( l1 * l2 > 0 \\\\) or \\\\( \\operatorname{min}( a, b ) < 1 \\\\), the two power terms both go in the same direction (towards zero or towards infinity). In this case if either term overflows or underflows, then the product of the two must do so also. Alternatively, if one exponent is less than one, then we can't productively use it to eliminate overflow or underflow from the other term.  Problems with spurious overflow/underflow can't be ruled out in this case, but it is _very_ unlikely since one of the power terms will evaluate to a number close to 1.\n*\n* -   If \\\\( \\max( \\abs(l1), \\abs(l2) ) < 0.5 \\\\), both exponents are near one and both the exponents are greater than one, and, further, these two power terms tend in opposite directions (one toward zero, the other toward infinity), so we have to combine the terms to avoid any risk of overflow or underflow. We do this by moving one power term inside the other, we have:\n*\n*     ```tex\n*     (1 + l_1)^a \\cdot (1 + l_2)^b \\\\\n*     = ((1 + l_1) \\cdot (1 + l_2)^(b/a))^a \\\\\n*     = (1 + l_1 + l_3 + l_1*l_3)^a\n*     ```\n*\n*     and\n*\n*     ```tex\n*     l_3 = (1 + l_2)^(b/a) - 1 \\\\\n*     = \\exp((b/a) * \\ln(1 + l_2)) - 1\n*     ```\n*\n*     The tricky bit is deciding which term to move inside. By preference we move the larger term inside, so that the size of the largest exponent is reduced.  However, that can only be done as long as l3 (see above) is also small.\n*\n* @private\n* @param {NonNegativeNumber} a - function parameter\n* @param {NonNegativeNumber} b - function parameter\n* @param {Probability} x - function parameter\n* @param {Probability} y - probability equal to `1-x`\n* @param {boolean} normalized - boolean indicating whether to evaluate the power terms of the regularized or non-regularized incomplete beta function\n* @returns {number} power terms\n*/\nfunction ibetaPowerTerms( a, b, x, y, normalized ) {\n\tvar result;\n\tvar smallA;\n\tvar ratio;\n\tvar agh;\n\tvar bgh;\n\tvar cgh;\n\tvar l1;\n\tvar l2;\n\tvar l3;\n\tvar p1;\n\tvar b1;\n\tvar b2;\n\tvar c;\n\tvar l;\n\n\tif ( !normalized ) {\n\t\t// Can we do better here?\n\t\treturn pow( x, a ) * pow( y, b );\n\t}\n\tc = a + b;\n\n\t// Combine power terms with Lanczos approximation:\n\tagh = a + G - 0.5;\n\tbgh = b + G - 0.5;\n\tcgh = c + G - 0.5;\n\tresult = lanczosSumExpGScaled( c );\n\tresult /= lanczosSumExpGScaled( a ) * lanczosSumExpGScaled( b );\n\n\t// Combine with the leftover terms from the Lanczos approximation:\n\tresult *= sqrt( bgh / E );\n\tresult *= sqrt( agh / cgh );\n\n\t// `l1` and `l2` are the base of the exponents minus one:\n\tl1 = ( ( x * b ) - ( y * agh ) ) / agh;\n\tl2 = ( ( y * a ) - ( x * bgh ) ) / bgh;\n\tif ( min( abs(l1), abs(l2) ) < 0.2 ) {\n\t\t// When the base of the exponent is very near 1 we get really gross errors unless extra care is taken:\n\t\tif ( l1 * l2 > 0 || min( a, b ) < 1 ) {\n\t\t\tif ( abs(l1) < 0.1 ) {\n\t\t\t\tresult *= exp( a * log1p( l1 ) );\n\t\t\t} else {\n\t\t\t\tresult *= pow( ( x*cgh ) / agh, a );\n\t\t\t}\n\t\t\tif ( abs(l2) < 0.1 ) {\n\t\t\t\tresult *= exp( b * log1p( l2 ) );\n\t\t\t} else {\n\t\t\t\tresult *= pow((y * cgh) / bgh, b);\n\t\t\t}\n\t\t}\n\t\telse if ( max( abs(l1), abs(l2) ) < 0.5 ) {\n\t\t\tsmallA = a < b;\n\t\t\tratio = b / a;\n\t\t\tif (\n\t\t\t\t(smallA && (ratio * l2 < 0.1)) ||\n\t\t\t\t(!smallA && (l1 / ratio > 0.1))\n\t\t\t) {\n\t\t\t\tl3 = expm1( ratio * log1p( l2 ) );\n\t\t\t\tl3 = l1 + l3 + ( l3 * l1 );\n\t\t\t\tl3 = a * log1p( l3 );\n\t\t\t\tresult *= exp( l3 );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tl3 = expm1( log1p( l1 ) / ratio );\n\t\t\t\tl3 = l2 + l3 + ( l3 * l2 );\n\t\t\t\tl3 = b * log1p( l3 );\n\t\t\t\tresult *= exp( l3 );\n\t\t\t}\n\t\t}\n\t\telse if ( abs(l1) < abs(l2) ) {\n\t\t\t// First base near 1 only:\n\t\t\tl = ( a * log1p( l1 ) ) + ( b * ln( ( y*cgh ) / bgh ) );\n\t\t\tif ( l <= MIN_LN || l >= MAX_LN ) {\n\t\t\t\tl += ln(result);\n\t\t\t\tif ( l >= MAX_LN ) {\n\t\t\t\t\treturn NaN;\n\t\t\t\t}\n\t\t\t\tresult = exp( l );\n\t\t\t} else {\n\t\t\t\tresult *= exp( l );\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// Second base near 1 only:\n\t\t\tl = ( b * log1p( l2 ) ) + ( a * ln( (x*cgh) / agh ) );\n\t\t\tif ( l <= MIN_LN || l >= MAX_LN ) {\n\t\t\t\tl += ln(result);\n\t\t\t\tif ( l >= MAX_LN ) {\n\t\t\t\t\treturn NaN;\n\t\t\t\t}\n\t\t\t\tresult = exp( l );\n\t\t\t} else {\n\t\t\t\tresult *= exp( l );\n\t\t\t}\n\t\t}\n\t}\n\telse {\n\t\t// General case:\n\t\tb1 = (x * cgh) / agh;\n\t\tb2 = (y * cgh) / bgh;\n\t\tl1 = a * ln(b1);\n\t\tl2 = b * ln(b2);\n\t\tif (\n\t\t\tl1 >= MAX_LN ||\n\t\t\tl1 <= MIN_LN ||\n\t\t\tl2 >= MAX_LN ||\n\t\t\tl2 <= MIN_LN\n\t\t) {\n\t\t\t// Oops, under/overflow, sidestep if we can:\n\t\t\tif ( a < b ) {\n\t\t\t\tp1 = pow( b2, b / a );\n\t\t\t\tl3 = a * ( ln(b1) + ln(p1) );\n\t\t\t\tif ( l3 < MAX_LN && l3 > MIN_LN ) {\n\t\t\t\t\tresult *= pow( p1 * b1, a );\n\t\t\t\t} else {\n\t\t\t\t\tl2 += l1 + ln(result);\n\t\t\t\t\tif ( l2 >= MAX_LN ) {\n\t\t\t\t\t\treturn NaN;\n\t\t\t\t\t}\n\t\t\t\t\tresult = exp( l2 );\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tp1 = pow( b1, a / b );\n\t\t\t\tl3 = ( ln(p1) + ln(b2) ) * b;\n\t\t\t\tif ( l3 < MAX_LN && l3 > MIN_LN ) {\n\t\t\t\t\tresult *= pow( p1 * b2, b );\n\t\t\t\t} else {\n\t\t\t\t\tl2 += l1 + ln( result );\n\t\t\t\t\tif (l2 >= MAX_LN) {\n\t\t\t\t\t\treturn NaN;\n\t\t\t\t\t}\n\t\t\t\t\tresult = exp( l2 );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// Finally the normal case:\n\t\t\tresult *= pow( b1, a ) * pow( b2, b );\n\t\t}\n\t}\n\treturn result;\n}\n\n\n// EXPORTS //\nexport default ibetaPowerTerms;\n","import __var_0__ from './ibeta_power_terms.js';\n/**\n\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\nvar ibetaPowerTerms = __var_0__;\n\n\n// MAIN //\n\n/**\n* Computes the partial derivative with respect to x of the incomplete beta function.\n*\n* @private\n* @param {Probability} x - input value (0 < x <= 1)\n* @param {PositiveNumber} a - first parameter\n* @param {PositiveNumber} b - second parameter (must be greater than 1)\n* @returns {number} value of the partial derivative\n*/\nfunction ibetaDerivative( x, a, b ) {\n\tvar f1;\n\tvar y;\n\tif ( x === 1.0 ) {\n\t\treturn 0.0;\n\t}\n\t// Regular cases:\n\tf1 = ibetaPowerTerms( a, b, x, 1.0 - x, true );\n\ty = ( 1.0 - x ) * x;\n\tf1 /= y;\n\treturn f1;\n}\n\n\n// EXPORTS //\nexport default ibetaDerivative;\n","import __var_0__ from '@stdlib/math/base/assert/is-nan';\nimport __var_1__ from '@stdlib/math/base/assert/is-nonnegative-integer';\nimport __var_2__ from './ibeta_derivative.js';\n/**\n\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\nvar isnan = __var_0__;\nvar isNonNegativeInteger = __var_1__;\nvar ibetaDerivative = __var_2__;\n\n\n// MAIN //\n\n/**\n* Evaluates the probability mass function (PMF) for a negative binomial distribution with number of successes until experiment is stopped `r` and success probability `p`.\n*\n* @param {number} x - input value\n* @param {PositiveNumber} r - number of successes until experiment is stopped\n* @param {Probability} p - success probability\n* @returns {Probability} evaluated PMF\n*\n* @example\n* var y = pmf( 5.0, 20.0, 0.8 );\n* // returns ~0.157\n*\n* @example\n* var y = pmf( 21.0, 20.0, 0.5 );\n* // returns ~0.06\n*\n* @example\n* var y = pmf( 5.0, 10.0, 0.4 );\n* // returns ~0.016\n*\n* @example\n* var y = pmf( 0.0, 10.0, 0.9 );\n* // returns ~0.349\n*\n* @example\n* var y = pmf( 21.0, 15.5, 0.5 );\n* // returns ~0.037\n*\n* @example\n* var y = pmf( 5.0, 7.4, 0.4 );\n* // returns ~0.051\n*\n* @example\n* var y = pmf( 2.0, 0.0, 0.5 );\n* // returns NaN\n*\n* @example\n* var y = pmf( 2.0, -2.0, 0.5 );\n* // returns NaN\n*\n* @example\n* var y = pmf( 2.0, 20, -1.0 );\n* // returns NaN\n*\n* @example\n* var y = pmf( 2.0, 20, 1.5 );\n* // returns NaN\n*\n* @example\n* var y = pmf( NaN, 20.0, 0.5 );\n* // returns NaN\n*\n* @example\n* var y = pmf( 0.0, NaN, 0.5 );\n* // returns NaN\n*\n* @example\n* var y = pmf( 0.0, 20.0, NaN );\n* // returns NaN\n*/\nfunction pmf( x, r, p ) {\n\tif (\n\t\tisnan( x ) ||\n\t\tisnan( r ) ||\n\t\tisnan( p ) ||\n\t\tr <= 0.0 ||\n\t\tp <= 0.0 ||\n\t\tp > 1.0\n\t) {\n\t\treturn NaN;\n\t}\n\tif ( !isNonNegativeInteger( x ) || p === 0.0 ) {\n\t\treturn 0.0;\n\t}\n\treturn ( p / ( r + x ) ) * ibetaDerivative( p, r, x + 1.0 );\n}\n\n\n// EXPORTS //\nexport default pmf;\n","import __var_0__ from '@stdlib/math/base/assert/is-nonnegative-integer';\nimport __var_1__ from '@stdlib/utils/constant-function';\nimport __var_2__ from '@stdlib/math/base/assert/is-nan';\nimport __var_3__ from './ibeta_derivative.js';\n/**\n\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\nvar isNonNegativeInteger = __var_0__;\nvar constantFunction = __var_1__;\nvar isnan = __var_2__;\nvar ibetaDerivative = __var_3__;\n\n\n// MAIN //\n\n/**\n* Returns a function for evaluating the probability mass function (PMF) for a negative binomial distribution with number of successes until experiment is stopped `r` and success probability `p`.\n*\n* @param {PositiveNumber} r - number of successes until experiment is stopped\n* @param {Probability} p - success probability\n* @returns {Function} PMF\n*\n* @example\n* var pmf = factory( 10, 0.5 );\n* var y = pmf( 3.0 );\n* // returns ~0.027\n*\n* y = pmf( 5.0 );\n* // returns ~0.061\n*/\nfunction factory( r, p ) {\n\tif (\n\t\tisnan( r ) ||\n\t\tisnan( p ) ||\n\t\tr <= 0.0 ||\n\t\tp <= 0.0 ||\n\t\tp > 1.0\n\t) {\n\t\treturn constantFunction( NaN );\n\t}\n\treturn pmf;\n\n\t/**\n\t* Evaluates the probability mass function (PMF) for a negative binomial distribution.\n\t*\n\t* @private\n\t* @param {number} x - input value\n\t* @returns {Probability} evaluated PMF\n\t*\n\t* @example\n\t* var y = pmf( 2.0 );\n\t* // returns <number>\n\t*/\n\tfunction pmf( x ) {\n\t\tif ( isnan( x ) ) {\n\t\t\treturn NaN;\n\t\t}\n\t\tif ( !isNonNegativeInteger( x ) ) {\n\t\t\treturn 0.0;\n\t\t}\n\t\treturn ( p / ( r + x ) ) * ibetaDerivative( p, r, x + 1.0 );\n\t}\n}\n\n\n// EXPORTS //\nexport default factory;\n","import __var_0__ from '@stdlib/utils/define-nonenumerable-read-only-property';\nimport __var_1__ from './pmf.js';\nimport __var_2__ from './factory.js';\n/**\n\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n/**\n* Negative binomial distribution probability mass function (PMF).\n*\n* @module @stdlib/stats/base/dists/negative-binomial/pmf\n*\n* @example\n* var pmf = require( '@stdlib/stats/base/dists/negative-binomial/pmf' );\n*\n* var y = pmf( 5.0, 20.0, 0.8 );\n* // returns ~0.157\n*\n* y = pmf( 21.0, 20.0, 0.5 );\n* // returns ~0.06\n*\n* y = pmf( 5.0, 10.0, 0.4 );\n* // returns ~0.016\n*\n* y = pmf( 0.0, 10.0, 0.9 );\n* // returns ~0.349\n*\n* y = pmf( 21.0, 15.5, 0.5 );\n* // returns ~0.037\n*\n* y = pmf( 5.0, 7.4, 0.4 );\n* // returns ~0.051\n*\n* var mypmf = pmf.factory( 10, 0.5 );\n* y = mypmf( 3.0 );\n* // returns ~0.027\n*\n* y = mypmf( 5.0 );\n* // returns ~0.061\n*/\n\n// MODULES //\nvar setReadOnly = __var_0__;\nvar pmf = __var_1__;\nvar factory = __var_2__;\n\n\n// MAIN //\n\nsetReadOnly( pmf, 'factory', factory );\n\n\n// EXPORTS //\nexport default pmf;\n"]}