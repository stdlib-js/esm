{"version":3,"sources":["@stdlib/stats/incr/covmat/lib/main.js","@stdlib/stats/incr/covmat/lib/index.js"],"names":["isPositiveInteger","__var_0__","isPrimitive","isSquareMatrix","__var_1__","isVectorLike","__var_2__","Float64Array","__var_3__","ctor","__var_4__","bctor","__var_5__","numel","__var_6__","ndopts","codegen","createMatrix","n","bool","matrix","createVector","N","vector","incrcovmat","out","means","order","cov","mu","C","d","TypeError","shape","arguments","length","Error","accumulator2","accumulator1","v","covij","denom","rdx","cij","m","r","i","j","get","set","di"],"mappings":"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","sourcesContent":["import __var_0__ from '@stdlib/assert/is-positive-integer';\nimport __var_1__ from '@stdlib/assert/is-square-matrix';\nimport __var_2__ from '@stdlib/assert/is-vector-like';\nimport __var_3__ from '@stdlib/array/float64';\nimport __var_4__ from '@stdlib/ndarray/ctor';\nimport __var_5__ from '@stdlib/ndarray/base/ctor';\nimport __var_6__ from '@stdlib/ndarray/base/numel';\n/**\n\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\nvar isPositiveInteger = __var_0__.isPrimitive;\nvar isSquareMatrix = __var_1__;\nvar isVectorLike = __var_2__;\nvar Float64Array = __var_3__;\nvar ctor = __var_4__;\nvar bctor = __var_5__;\nvar numel = __var_6__;\n\n\n// VARIABLES //\n\nvar ndopts = {\n\t'codegen': false // avoid unnecessarily running afoul of CSPs\n};\n\n\n// FUNCTIONS //\n\n/**\n* Returns a matrix.\n*\n* @private\n* @param {PositiveInteger} n - matrix order\n* @param {boolean} bool - boolean indicating whether to create a low-level ndarray\n* @returns {ndarray} matrix\n*/\nfunction createMatrix( n, bool ) {\n\tvar strides;\n\tvar matrix;\n\tvar buffer;\n\tvar shape;\n\tvar f;\n\n\tif ( bool ) {\n\t\tf = bctor; // low-level ndarray constructor\n\t} else {\n\t\tf = ctor;\n\t}\n\tmatrix = f( 'float64', 2, ndopts );\n\tbuffer = new Float64Array( n*n );\n\tshape = [ n, n ];\n\tstrides = [ n, 1 ];\n\n\treturn matrix( buffer, shape, strides, 0, 'row-major' );\n}\n\n/**\n* Returns a vector.\n*\n* @private\n* @param {PositiveInteger} N - number of elements\n* @returns {ndarray} vector\n*/\nfunction createVector( N ) {\n\tvar strides;\n\tvar vector;\n\tvar buffer;\n\tvar shape;\n\n\tvector = bctor( 'float64', 1, ndopts ); // low-level ndarray\n\tbuffer = new Float64Array( N );\n\tshape = [ N ];\n\tstrides = [ 1 ];\n\n\treturn vector( buffer, shape, strides, 0, 'row-major' );\n}\n\n\n// MAIN //\n\n/**\n* Returns an accumulator function which incrementally computes an unbiased sample covariance matrix.\n*\n* ## Method\n*\n* -   For each unbiased sample covariance, we begin by defining the co-moment \\\\(C_{jn}\\\\)\n*\n*     ```tex\n*     C_n = \\sum_{i=1}^{n} ( x_i - \\bar{x}_n ) ( y_i - \\bar{y}_n )\n*     ```\n*\n*     where \\\\(\\bar{x}_n\\\\) and \\\\(\\bar{y}_n\\\\) are the sample means for \\\\(x\\\\) and \\\\(y\\\\), respectively.\n*\n* -   Based on Welford's method, we know the update formulas for the sample means are given by\n*\n*     ```tex\n*     \\bar{x}_n = \\bar{x}_{n-1} + \\frac{x_n - \\bar{x}_{n-1}}{n}\n*     ```\n*\n*     and\n*\n*     ```tex\n*     \\bar{y}_n = \\bar{y}_{n-1} + \\frac{y_n - \\bar{y}_{n-1}}{n}\n*     ```\n*\n* -   Substituting into the equation for \\\\(C_n\\\\) and rearranging terms\n*\n*     ```tex\n*     C_n = C_{n-1} + (x_n - \\bar{x}_n) (y_n - \\bar{y}_{n-1})\n*     ```\n*\n*     where the apparent asymmetry arises from\n*\n*     ```tex\n*     x_n - \\bar{x}_n = \\frac{n-1}{n} (x_n - \\bar{x}_{n-1})\n*     ```\n*\n*     and, hence, the update term can be equivalently expressed\n*\n*     ```tex\n*     \\frac{n-1}{n} (x_n - \\bar{x}_{n-1}) (y_n - \\bar{y}_{n-1})\n*     ```\n*\n* -   The covariance can be defined\n*\n*     ```tex\n*     \\begin{align*}\n*     \\operatorname{cov}_n(x,y) &= \\frac{C_n}{n} \\\\\n*     &= \\frac{C_{n-1} + \\frac{n-1}{n} (x_n - \\bar{x}_{n-1}) (y_n - \\bar{y}_{n-1})}{n} \\\\\n*     &= \\frac{(n-1)\\operatorname{cov}_{n-1}(x,y) + \\frac{n-1}{n} (x_n - \\bar{x}_{n-1}) (y_n - \\bar{y}_{n-1})}{n}\n*     \\end{align*}\n*     ```\n*\n* -   Applying Bessel's correction, we arrive at an update formula for calculating an unbiased sample covariance\n*\n*     ```tex\n*     \\begin{align*}\n*     \\operatorname{cov}_n(x,y) &= \\frac{n}{n-1}\\cdot\\frac{(n-1)\\operatorname{cov}_{n-1}(x,y) + \\frac{n-1}{n} (x_n - \\bar{x}_{n-1}) (y_n - \\bar{y}_{n-1})}{n} \\\\\n*     &= \\operatorname{cov}_{n-1}(x,y) + \\frac{(x_n - \\bar{x}_{n-1}) (y_n - \\bar{y}_{n-1})}{n} \\\\\n*     &= \\frac{C_{n-1}}{n-1} + \\frac{(x_n - \\bar{x}_{n-1}) (y_n - \\bar{y}_{n-1})}{n}\n*     &= \\frac{C_{n-1} + \\frac{n-1}{n} (x_n - \\bar{x}_{n-1}) (y_n - \\bar{y}_{n-1})}{n-1}\n*     \\end{align*}\n*     ```\n*\n* @param {(PositiveInteger|ndarray)} out - order of the covariance matrix or a square 2-dimensional output ndarray for storing the covariance matrix\n* @param {ndarray} [means] - mean values\n* @throws {TypeError} first argument must be either a positive integer or a 2-dimensional ndarray having equal dimensions\n* @throws {TypeError} second argument must be a 1-dimensional ndarray\n* @throws {Error} number of means must match covariance matrix dimensions\n* @returns {Function} accumulator function\n*\n* @example\n* var Float64Array = require( '@stdlib/array/float64' );\n* var ctor = require( '@stdlib/ndarray/ctor' );\n*\n* var vector = ctor( 'float64', 1 );\n* var matrix = ctor( 'float64', 2 );\n*\n* // Create an output covariance matrix:\n* var buffer = new Float64Array( 4 );\n* var shape = [ 2, 2 ];\n* var strides = [ 2, 1 ];\n* var offset = 0;\n* var order = 'row-major';\n*\n* var cov = matrix( buffer, shape, strides, offset, order );\n*\n* // Create a covariance matrix accumulator:\n* var accumulator = incrcovmat( cov );\n*\n* var out = accumulator();\n* // returns null\n*\n* // Create a data vector:\n* buffer = new Float64Array( 2 );\n* shape = [ 2 ];\n* strides = [ 1 ];\n*\n* var vec = vector( buffer, shape, strides, offset, order );\n*\n* // Provide data to the accumulator:\n* vec.set( 0, 2.0 );\n* vec.set( 1, 1.0 );\n*\n* out = accumulator( vec );\n* // returns <ndarray>\n*\n* var bool = ( out === cov );\n* // returns true\n*\n* vec.set( 0, -5.0 );\n* vec.set( 1, 3.14 );\n*\n* out = accumulator( vec );\n* // returns <ndarray>\n*\n* // Retrieve the covariance matrix:\n* out = accumulator();\n* // returns <ndarray>\n*/\nfunction incrcovmat( out, means ) {\n\tvar order;\n\tvar cov;\n\tvar mu;\n\tvar C;\n\tvar d;\n\tvar N;\n\n\tN = 0;\n\tif ( isPositiveInteger( out ) ) {\n\t\torder = out;\n\t\tcov = createMatrix( order, false );\n\t} else if ( isSquareMatrix( out ) ) {\n\t\torder = out.shape[ 0 ];\n\t\tcov = out;\n\t} else {\n\t\tthrow new TypeError( 'invalid argument. First argument must either specify the order of the covariance matrix or be a square 2-dimensional ndarray for storing the covariance matrix. Value: `' + out + '`.' );\n\t}\n\t// Create a scratch array for storing residuals (i.e., `x_i - xbar_{i-1}`):\n\td = new Float64Array( order );\n\n\t// Create a low-level scratch matrix for storing co-moments:\n\tC = createMatrix( order, true );\n\n\tif ( arguments.length > 1 ) {\n\t\tif ( !isVectorLike( means ) ) {\n\t\t\tthrow new TypeError( 'invalid argument. Second argument must be a 1-dimensional ndarray. Value: `' + means + '`.' );\n\t\t}\n\t\tif ( numel( means.shape ) !== order ) {\n\t\t\tthrow new Error( 'invalid argument. The number of elements (means) in the second argument must match covariance matrix dimensions. Expected: '+order+'. Actual: '+numel( means.shape )+'.' );\n\t\t}\n\t\tmu = means; // TODO: should we copy this? Otherwise, internal state could be \"corrupted\" due to mutation outside the accumulator\n\t\treturn accumulator2;\n\t}\n\t// Create an ndarray vector for storing sample means (note: an ndarray interface is not necessary, but it reduces implementation complexity by ensuring a consistent abstraction for accessing and updating sample means):\n\tmu = createVector( order );\n\n\treturn accumulator1;\n\n\t/**\n\t* If provided a data vector, the accumulator function returns an updated unbiased sample covariance matrix. If not provided a data vector, the accumulator function returns the current unbiased sample covariance matrix.\n\t*\n\t* @private\n\t* @param {ndarray} [v] - data vector\n\t* @throws {TypeError} must provide a 1-dimensional ndarray\n\t* @throws {Error} vector length must match covariance matrix dimensions\n\t* @returns {(ndarray|null)} unbiased sample covariance matrix or null\n\t*/\n\tfunction accumulator1( v ) {\n\t\tvar covij;\n\t\tvar denom;\n\t\tvar rdx;\n\t\tvar cij;\n\t\tvar m;\n\t\tvar n;\n\t\tvar r;\n\t\tvar i;\n\t\tvar j;\n\t\tif ( arguments.length === 0 ) {\n\t\t\tif ( N === 0 ) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\treturn cov;\n\t\t}\n\t\tif ( !isVectorLike( v ) ) {\n\t\t\tthrow new TypeError( 'invalid argument. Must provide a 1-dimensional ndarray. Value: `' + v + '`.' );\n\t\t}\n\t\tif ( v.shape[ 0 ] !== order ) {\n\t\t\tthrow new Error( 'invalid argument. Vector length must match covariance matrix dimensions. Expected: '+order+'. Actual: '+v.shape[ 0 ]+'.' );\n\t\t}\n\t\tn = N;\n\t\tN += 1;\n\t\tr = n / N;\n\n\t\tdenom = n || 1; // Bessel's correction (avoiding divide-by-zero below)\n\n\t\tfor ( i = 0; i < order; i++ ) {\n\t\t\tm = mu.get( i );\n\n\t\t\t// Compute the residual:\n\t\t\td[ i ] = v.get( i ) - m;\n\n\t\t\t// Update the sample mean:\n\t\t\tm += d[ i ] / N;\n\t\t\tmu.set( i, m );\n\n\t\t\t// Update the co-moments and covariance matrix, recognizing that the covariance matrix is symmetric...\n\t\t\trdx = r * d[ i ]; // if `n=0`, `r=0.0`\n\t\t\tfor ( j = 0; j <= i; j++ ) {\n\t\t\t\tcij = C.get( i, j ) + ( rdx*d[j] );\n\t\t\t\tC.set( i, j, cij );\n\t\t\t\tC.set( j, i, cij ); // via symmetry\n\n\t\t\t\tcovij = cij / denom;\n\t\t\t\tcov.set( i, j, covij );\n\t\t\t\tcov.set( j, i, covij ); // via symmetry\n\t\t\t}\n\t\t}\n\t\treturn cov;\n\t}\n\n\t/**\n\t* If provided a data vector, the accumulator function returns an updated unbiased sample covariance matrix. If not provided a data vector, the accumulator function returns the current unbiased sample covariance matrix.\n\t*\n\t* @private\n\t* @param {ndarray} [v] - data vector\n\t* @throws {TypeError} must provide a 1-dimensional ndarray\n\t* @throws {Error} vector length must match covariance matrix dimensions\n\t* @returns {(ndarray|null)} unbiased sample covariance matrix or null\n\t*/\n\tfunction accumulator2( v ) {\n\t\tvar covij;\n\t\tvar cij;\n\t\tvar di;\n\t\tvar i;\n\t\tvar j;\n\t\tif ( arguments.length === 0 ) {\n\t\t\tif ( N === 0 ) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\treturn cov;\n\t\t}\n\t\tif ( !isVectorLike( v ) ) {\n\t\t\tthrow new TypeError( 'invalid argument. Must provide a 1-dimensional ndarray. Value: `' + v + '`.' );\n\t\t}\n\t\tif ( v.shape[ 0 ] !== order ) {\n\t\t\tthrow new Error( 'invalid argument. Vector length must match covariance matrix dimensions. Expected: '+order+'. Actual: '+v.shape[ 0 ]+'.' );\n\t\t}\n\t\tN += 1;\n\t\tfor ( i = 0; i < order; i++ ) {\n\t\t\t// Compute the residual:\n\t\t\td[ i ] = v.get( i ) - mu.get( i );\n\n\t\t\t// Update the co-moments and covariance matrix, recognizing that the covariance matrix is symmetric...\n\t\t\tdi = d[ i ];\n\t\t\tfor ( j = 0; j <= i; j++ ) {\n\t\t\t\tcij = C.get( i, j ) + ( di*d[j] );\n\t\t\t\tC.set( i, j, cij );\n\t\t\t\tC.set( j, i, cij ); // via symmetry\n\n\t\t\t\tcovij = cij / N;\n\t\t\t\tcov.set( i, j, covij );\n\t\t\t\tcov.set( j, i, covij ); // via symmetry\n\t\t\t}\n\t\t}\n\t\treturn cov;\n\t}\n}\n\n\n// EXPORTS //\nexport default incrcovmat;\n","import __var_0__ from './main.js';\n/**\n\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n/**\n* Compute an unbiased sample covariance matrix incrementally.\n*\n* @module @stdlib/stats/incr/covmat\n*\n* @example\n* var Float64Array = require( '@stdlib/array/float64' );\n* var ctor = require( '@stdlib/ndarray/ctor' );\n* var incrcovmat = require( '@stdlib/stats/incr/covmat' );\n*\n* var vector = ctor( 'float64', 1 );\n* var matrix = ctor( 'float64', 2 );\n*\n* // Create an output covariance matrix:\n* var buffer = new Float64Array( 4 );\n* var shape = [ 2, 2 ];\n* var strides = [ 2, 1 ];\n* var offset = 0;\n* var order = 'row-major';\n*\n* var cov = matrix( buffer, shape, strides, offset, order );\n*\n* // Create a covariance matrix accumulator:\n* var accumulator = incrcovmat( cov );\n*\n* var out = accumulator();\n* // returns null\n*\n* // Create a data vector:\n* buffer = new Float64Array( 2 );\n* shape = [ 2 ];\n* strides = [ 1 ];\n*\n* var vec = vector( buffer, shape, strides, offset, order );\n*\n* // Provide data to the accumulator:\n* vec.set( 0, 2.0 );\n* vec.set( 1, 1.0 );\n*\n* out = accumulator( vec );\n* // returns <ndarray>\n*\n* var bool = ( out === cov );\n* // returns true\n*\n* vec.set( 0, -5.0 );\n* vec.set( 1, 3.14 );\n*\n* out = accumulator( vec );\n* // returns <ndarray>\n*\n* // Retrieve the covariance matrix:\n* out = accumulator();\n* // returns <ndarray>\n*/\n\n// MODULES //\nvar incrcovmat = __var_0__;\n\n\n// EXPORTS //\nexport default incrcovmat;\n"]}