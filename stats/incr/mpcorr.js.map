{"version":3,"sources":["@stdlib/stats/incr/mpcorr/lib/main.js","@stdlib/stats/incr/mpcorr/lib/index.js"],"names":["isPositiveInteger","__var_0__","isPrimitive","isNumber","__var_1__","isnan","__var_2__","sqrt","__var_3__","incrmpcorr","W","meanx","meany","buf","dx0","dxN","dy0","dyN","M2x","M2y","mx","my","sx","sy","dx","dy","wi","C","N","n","i","TypeError","Array","arguments","length","accumulator2","accumulator1","x","y","v1","v2","n1","k","j","NaN"],"mappings":"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","sourcesContent":["import __var_0__ from '@stdlib/assert/is-positive-integer';\nimport __var_1__ from '@stdlib/assert/is-number';\nimport __var_2__ from '@stdlib/math/base/assert/is-nan';\nimport __var_3__ from '@stdlib/math/base/special/sqrt';\n/**\n\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\nvar isPositiveInteger = __var_0__.isPrimitive;\nvar isNumber = __var_1__.isPrimitive;\nvar isnan = __var_2__;\nvar sqrt = __var_3__;\n\n\n// MAIN //\n\n/**\n* Returns an accumulator function which incrementally computes a moving sample Pearson product-moment correlation coefficient.\n*\n* ## Method\n*\n* -   Let \\\\(W\\\\) be a window of \\\\(N\\\\) elements over which we want to compute a sample Pearson product-moment correlation coefficient.\n*\n* -   We begin by defining the covariance \\\\( \\operatorname{cov}_n(x,y) \\\\) for a window \\\\(n\\\\) as follows\n*\n*     ```tex\n*     \\operatorname{cov}_n(x,y) &= \\frac{C_n}{n}\n*     ```\n*\n*     where \\\\(C_n\\\\) is the co-moment, which is defined as\n*\n*     ```tex\n*     C_n = \\sum_{i=1}^{N} ( x_i - \\bar{x}_n ) ( y_i - \\bar{y}_n )\n*     ```\n*\n*     and where \\\\(\\bar{x}_n\\\\) and \\\\(\\bar{y}_n\\\\) are the sample means for \\\\(x\\\\) and \\\\(y\\\\), respectively, and \\\\(i=1\\\\) specifies the first element in a window.\n*\n* -   The sample mean is computed using the canonical formula\n*\n*     ```tex\n*     \\bar{x}_n = \\frac{1}{N} \\sum_{i=1}^{N} x_i\n*     ```\n*\n*     which, taking into account a previous window, can be expressed\n*\n*     ```tex\n*     \\begin{align*}\n*     \\bar{x}_n &= \\frac{1}{N} \\biggl( \\sum_{i=0}^{N-1} x_i - x_0 + x_N \\biggr) \\\\\n*               &= \\bar{x}_{n-1} + \\frac{x_N - x_0}{N}\n*     \\end{align*}\n*     ```\n*\n*     where \\\\(x_0\\\\) is the first value in the previous window.\n*\n* -   We can substitute into the co-moment equation\n*\n*     ```tex\n*     \\begin{align*}\n*     C_n &= \\sum_{i=1}^{N} ( x_i - \\bar{x}_n ) ( y_i - \\bar{y}_n ) \\\\\n*         &= \\sum_{i=1}^{N} \\biggl( x_i - \\bar{x}_{n-1} - \\frac{x_N - x_0}{N} \\biggr) \\biggl( y_i - \\bar{y}_{n-1} - \\frac{y_N - y_0}{N} \\biggr) \\\\\n*         &= \\sum_{i=1}^{N} \\biggl( \\Delta x_{i,n-1} - \\frac{x_N - x_0}{N} \\biggr) \\biggl( \\Delta y_{i,n-1} - \\frac{y_N - y_0}{N} \\biggr)\n*     \\end{align*}\n*     ```\n*\n*     where\n*\n*     ```tex\n*     \\Delta x_{i,k} = x_i - \\bar{x}_{k}\n*     ```\n*\n* -   We can subsequently expand terms and apply a summation identity\n*\n*     ```tex\n*     \\begin{align*}\n*     C_n &= \\sum_{i=1}^{N} \\Delta x_{i,n-1} \\Delta y_{i,n-1} - \\sum_{i=1}^{N} \\Delta x_{i,n-1} \\biggl( \\frac{y_N - y_0}{N} \\biggr) - \\sum_{i=1}^{N} \\Delta y_{i,n-1} \\biggl( \\frac{x_N - x_0}{N} \\biggr) + \\sum_{i=1}^{N} \\biggl( \\frac{x_N - x_0}{N} \\biggr) \\biggl( \\frac{y_N - y_0}{N} \\biggr) \\\\\n*         &= \\sum_{i=1}^{N} \\Delta x_{i,n-1} \\Delta y_{i,n-1} - \\biggl( \\frac{y_N - y_0}{N} \\biggr) \\sum_{i=1}^{N} \\Delta x_{i,n-1} - \\biggl( \\frac{x_N - x_0}{N} \\biggr) \\sum_{i=1}^{N} \\Delta y_{i,n-1} + \\frac{(x_N - x_0)(y_N - y_0)}{N}\n*     \\end{align*}\n*     ```\n*\n* -   Let us first consider the second term which we can reorganize as follows\n*\n*     ```tex\n*     \\begin{align*}\n*     \\biggl( \\frac{y_N - y_0}{N} \\biggr) \\sum_{i=1}^{N} \\Delta x_{i,n-1} &= \\biggl( \\frac{y_N - y_0}{N} \\biggr) \\sum_{i=1}{N} ( x_i - \\bar{x}_{n-1}) \\\\\n*         &= \\biggl( \\frac{y_N - y_0}{N} \\biggr) \\sum_{i=1}^{N} x_i - \\biggl( \\frac{y_N - y_0}{N} \\biggr) \\sum_{i=1}^{N} \\bar{x}_{n-1} \\\\\n*         &= (y_N - y_0) \\bar{x}_{n} - (y_N - y_0)\\bar{x}_{n-1} \\\\\n*         &= (y_N - y_0) (\\bar{x}_{n} - \\bar{x}_{n-1}) \\\\\n*         &= \\frac{(x_N - x_0)(y_N - y_0)}{N}\n*     \\end{align*}\n*     ```\n*\n* -   The third term can be reorganized in a manner similar to the second term such that\n*\n*     ```tex\n*     \\biggl( \\frac{x_N - x_0}{N} \\biggr) \\sum_{i=1}^{N} \\Delta y_{i,n-1} = \\frac{(x_N - x_0)(y_N - y_0)}{N}\n*     ```\n*\n* -   Substituting back into the equation for the co-moment\n*\n*     ```tex\n*     \\begin{align*}\n*     C_n &= \\sum_{i=1}^{N} \\Delta x_{i,n-1} \\Delta y_{i,n-1} - \\frac{(x_N - x_0)(y_N - y_0)}{N} - \\frac{(x_N - x_0)(y_N - y_0)}{N} + \\frac{(x_N - x_0)(y_N - y_0)}{N} \\\\\n*         &= \\sum_{i=1}^{N} \\Delta x_{i,n-1} \\Delta y_{i,n-1} - \\frac{(x_N - x_0)(y_N - y_0)}{N}\n*     \\end{align*}\n*     ```\n*\n* -   Let us now consider the first term which we can modify as follows\n*\n*     ```tex\n*     \\begin{align*}\n*     \\sum_{i=1}^{N} \\Delta x_{i,n-1} \\Delta y_{i,n-1} &= \\sum_{i=1}^{N} (x_i - \\bar{x}_{n-1})(y_i - \\bar{y}_{n-1}) \\\\\n*         &= \\sum_{i=1}^{N-1} (x_i - \\bar{x}_{n-1})(y_i - \\bar{y}_{n-1}) + (x_N - \\bar{x}_{n-1})(y_N - \\bar{y}_{n-1}) \\\\\n*         &= \\sum_{i=1}^{N-1} (x_i - \\bar{x}_{n-1})(y_i - \\bar{y}_{n-1}) + (x_N - \\bar{x}_{n-1})(y_N - \\bar{y}_{n-1}) + (x_0 - \\bar{x}_{n-1})(y_0 - \\bar{y}_{n-1}) - (x_0 - \\bar{x}_{n-1})(y_0 - \\bar{y}_{n-1}) \\\\\n*         &= \\sum_{i=0}^{N-1} (x_i - \\bar{x}_{n-1})(y_i - \\bar{y}_{n-1}) + (x_N - \\bar{x}_{n-1})(y_N - \\bar{y}_{n-1}) - (x_0 - \\bar{x}_{n-1})(y_0 - \\bar{y}_{n-1})\n*     \\end{align*}\n*     ```\n*\n*     where we recognize that the first term equals the co-moment for the previous window\n*\n*     ```tex\n*     C_{n-1} = \\sum_{i=0}^{N-1} (x_i - \\bar{x}_{n-1})(y_i - \\bar{y}_{n-1})\n*     ```\n*\n*     In which case,\n*\n*     ```tex\n*     \\begin{align*}\n*     \\sum_{i=1}^{N} \\Delta x_{i,n-1} \\Delta y_{i,n-1} &= C_{n-1} + (x_N - \\bar{x}_{n-1})(y_N - \\bar{y}_{n-1}) - (x_0 - \\bar{x}_{n-1})(y_0 - \\bar{y}_{n-1}) \\\\\n*         &= C_{n-1} + \\Delta x_{N,n-1} \\Delta y_{N,n-1} - \\Delta x_{0,n-1} \\Delta y_{0,n-1}\n*     \\end{align*}\n*     ```\n*\n* -   Substituting into the equation for the co-moment\n*\n*     ```tex\n*     C_n = C_{n-1} + \\Delta x_{N,n-1} \\Delta y_{N,n-1} - \\Delta x_{0,n-1} \\Delta y_{0,n-1} - \\frac{(x_N - x_0)(y_N - y_0)}{N}\n*     ```\n*\n* -   We can make one further modification to the last term\n*\n*     ```tex\n*     \\begin{align*}\n*     \\frac{(x_N - x_0)(y_N - y_0)}{N} &= \\frac{(x_N - \\bar{x}_{n-1} - x_0 + \\bar{x}_{n-1})(y_N - \\bar{y}_{n-1} - y_0 + \\bar{y}_{n-1})}{N} \\\\\n*         &= \\frac{(\\Delta x_{N,n-1} - \\Delta x_{0,n-1})(\\Delta y_{N,n-1} - \\Delta y_{0,n-1})}{N}\n*     \\end{align*}\n*     ```\n*\n*     which, upon substitution into the equation for the co-moment, yields\n*\n*     ```tex\n*     C_n = C_{n-1} + \\Delta x_{N,n-1} \\Delta y_{N,n-1} - \\Delta x_{0,n-1} \\Delta y_{0,n-1} - \\frac{(\\Delta x_{N,n-1} - \\Delta x_{0,n-1})(\\Delta y_{N,n-1} - \\Delta y_{0,n-1})}{N}\n*     ```\n*\n* -   To calculate corrected sample standard deviations, we first recognize that the corrected sample standard deviation is defined as the square root of the unbiased sample variance. Accordingly, in order to derive an update equation for the corrected sample standard deviation, deriving an update equation for the unbiased sample variance is sufficient.\n*\n* -   The difference between the unbiased sample variance in a window \\\\(W_{n-1}\\\\) and the unbiased sample variance in a window \\\\(W_{n})\\\\) is given by\n*\n*     ```tex\n*     \\Delta s^2 = s_n^2 - s_{n-1}^2\n*     ```\n*\n* -   If we multiply both sides by \\\\(N-1\\\\),\n*\n*     ```tex\n*     (N-1)(\\Delta s^2) = (N-1)s_{n}^2 - (N-1)s_{n-1}^2\n*     ```\n*\n* -   If we substitute the definition of the unbiased sample variance having the form\n*\n*     ```tex\n*     \\begin{align*}\n*     s^2 &= \\frac{1}{N-1} \\biggl( \\sum_{i=1}^{N} (x_i - \\bar{x})^2 \\biggr) \\\\\n*         &= \\frac{1}{N-1} \\biggl( \\sum_{i=1}^{N} (x_i^2 - 2\\bar{x}x_i + \\bar{x}^2) \\biggr) \\\\\n*         &= \\frac{1}{N-1} \\biggl( \\sum_{i=1}^{N} x_i^2 - 2\\bar{x} \\sum_{i=1}^{N} x_i + \\sum_{i=1}^{N} \\bar{x}^2) \\biggr) \\\\\n*         &= \\frac{1}{N-1} \\biggl( \\sum_{i=1}^{N} x_i^2 - \\frac{2N\\bar{x}\\sum_{i=1}^{N} x_i}{N} + N\\bar{x}^2 \\biggr) \\\\\n*         &= \\frac{1}{N-1} \\biggl( \\sum_{i=1}^{N} x_i^2 - 2N\\bar{x}^2 + N\\bar{x}^2 \\biggr) \\\\\n*         &= \\frac{1}{N-1} \\biggl( \\sum_{i=1}^{N} x_i^2 - N\\bar{x}^2 \\biggr)\n*     \\end{align*}\n*     ```\n*\n*     we return\n*\n*     ```tex\n*     (N-1)(\\Delta s^2) = \\biggl(\\sum_{i=1}^N x_i^2 - N\\bar{x}_{n}^2 \\biggr) - \\biggl(\\sum_{i=0}^{N-1} x_i^2 - N\\bar{x}_{n-1}^2 \\biggr)\n*     ```\n*\n* -   This can be further simplified by recognizing that subtracting the sums reduces to \\\\(x_N^2 - x_0^2\\\\); in which case,\n*\n*     ```tex\n*     \\begin{align*}\n*     (N-1)(\\Delta s^2) &= x_N^2 - x_0^2 - N\\bar{x}_{n}^2 + N\\bar{x}_{n-1}^2 \\\\\n*     &= x_N^2 - x_0^2 - N(\\bar{x}_{n}^2 - \\bar{x}_{n-1}^2) \\\\\n*     &= x_N^2 - x_0^2 - N(\\bar{x}_{n} - \\bar{x}_{n-1})(\\bar{x}_{n} + \\bar{x}_{n-1})\n*     \\end{align*}\n*     ```\n*\n* -   Recognizing that the difference of means can be expressed\n*\n*     ```tex\n*     \\bar{x}_{n} - \\bar{x}_{n-1} = \\frac{1}{N} \\biggl( \\sum_{i=1}^N x_i - \\sum_{i=0}^{N-1} x_i \\biggr) = \\frac{x_N - x_0}{N}\n*     ```\n*\n*     and substituting into the equation above\n*\n*     ```tex\n*     (N-1)(\\Delta s^2) = x_N^2 - x_0^2 - (x_N - x_0)(\\bar{x}_{n} + \\bar{x}_{n-1})\n*     ```\n*\n* -   Rearranging terms gives us the update equation\n*\n*     ```tex\n*     \\begin{align*}\n*     (N-1)(\\Delta s^2) &= (x_N - x_0)(x_N + x_0) - (x_N - x_0)(\\bar{x}_{n} + \\bar{x}_{n-1})\n*     &= (x_N - x_0)(x_N + x_0 - \\bar{x}_{n} - \\bar{x}_{n-1}) \\\\\n*     &= (x_N - x_0)(x_N - \\bar{x}_{n} + x_0 - \\bar{x}_{n-1})\n*     \\end{align*}\n*     ```\n*\n* -   To compute the corrected sample standard deviation, we apply Bessel's correction and take the square root.\n*\n* -   The sample Pearson product-moment correlation coefficient can thus be calculated as\n*\n*     ```tex\n*     r_n(x,y) = \\frac{\\operatorname{cov}_n(x,y)}{\\sigma_{x,n} \\sigma_{y,n}}\n*     ```\n*\n*     where \\\\(\\sigma_{x,n}\\\\) and \\\\(\\sigma_{y,n}\\\\) are the corrected sample standard deviations for \\\\(x\\\\) and \\\\(y\\\\), respectively, for a window \\\\(n\\\\).\n*\n*\n* @param {PositiveInteger} W - window size\n* @param {number} [meanx] - mean value\n* @param {number} [meany] - mean value\n* @throws {TypeError} first argument must be a positive integer\n* @throws {TypeError} second argument must be a number primitive\n* @throws {TypeError} third argument must be a number primitive\n* @returns {Function} accumulator function\n*\n* @example\n* var accumulator = incrmpcorr( 3 );\n*\n* var r = accumulator();\n* // returns null\n*\n* r = accumulator( 2.0, 1.0 );\n* // returns 0.0\n*\n* r = accumulator( -5.0, 3.14 );\n* // returns ~-1.0\n*\n* r = accumulator( 3.0, -1.0 );\n* // returns ~-0.925\n*\n* r = accumulator( 5.0, -9.5 );\n* // returns ~-0.863\n*\n* r = accumulator();\n* // returns ~-0.863\n*\n* @example\n* var accumulator = incrmpcorr( 3, -2.0, 10.0 );\n*/\nfunction incrmpcorr( W, meanx, meany ) {\n\tvar buf;\n\tvar dx0;\n\tvar dxN;\n\tvar dy0;\n\tvar dyN;\n\tvar M2x;\n\tvar M2y;\n\tvar mx;\n\tvar my;\n\tvar sx;\n\tvar sy;\n\tvar dx;\n\tvar dy;\n\tvar wi;\n\tvar C;\n\tvar N;\n\tvar n;\n\tvar i;\n\tif ( !isPositiveInteger( W ) ) {\n\t\tthrow new TypeError( 'invalid argument. First argument must be a positive integer. Value: `' + W + '`.' );\n\t}\n\tbuf = new Array( 2*W ); // strided array\n\tn = W - 1;\n\tM2x = 0.0;\n\tM2y = 0.0;\n\tC = 0.0;\n\twi = -1;\n\tN = 0;\n\tif ( arguments.length > 1 ) {\n\t\tif ( !isNumber( meanx ) ) {\n\t\t\tthrow new TypeError( 'invalid argument. Second argument must be a number primitive. Value: `' + meanx + '`.' );\n\t\t}\n\t\tif ( !isNumber( meany ) ) {\n\t\t\tthrow new TypeError( 'invalid argument. Third argument must be a number primitive. Value: `' + meany + '`.' );\n\t\t}\n\t\tmx = meanx;\n\t\tmy = meany;\n\t\treturn accumulator2;\n\t}\n\tmx = 0.0;\n\tmy = 0.0;\n\treturn accumulator1;\n\n\t/**\n\t* If provided a value, the accumulator function returns an updated sample correlation coefficient. If not provided a value, the accumulator function returns the current sample correlation coefficient.\n\t*\n\t* @private\n\t* @param {number} [x] - input value\n\t* @param {number} [y] - input value\n\t* @returns {(number|null)} sample correlation coefficient or null\n\t*/\n\tfunction accumulator1( x, y ) {\n\t\tvar v1;\n\t\tvar v2;\n\t\tvar n1;\n\t\tvar k;\n\t\tvar j;\n\t\tif ( arguments.length === 0 ) {\n\t\t\tif ( N === 0 ) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tif ( N === 1 ) {\n\t\t\t\treturn 0.0;\n\t\t\t}\n\t\t\tif ( N < W ) {\n\t\t\t\treturn ( C/(N-1) ) / ( sx*sy );\n\t\t\t}\n\t\t\treturn ( C/n ) / ( sx*sy );\n\t\t}\n\t\t// Update the window and strided array indices for managing the circular buffer:\n\t\twi = (wi+1) % W;\n\t\ti = 2 * wi;\n\n\t\t// Case: an incoming value is NaN, the sliding co-moment is automatically NaN...\n\t\tif ( isnan( x ) || isnan( y ) ) {\n\t\t\tN = W; // explicitly set to avoid `N < W` branch\n\t\t\tC = NaN;\n\t\t}\n\t\t// Case: initial window...\n\t\telse if ( N < W ) {\n\t\t\tbuf[ i ] = x; // update buffer\n\t\t\tbuf[ i+1 ] = y;\n\n\t\t\tN += 1;\n\n\t\t\tdx = x - mx;\n\t\t\tmx += dx / N;\n\t\t\tM2x += dx * ( x-mx );\n\n\t\t\tdy = y - my;\n\t\t\tmy += dy / N;\n\t\t\tdyN = y - my;\n\t\t\tM2y += dy * dyN;\n\n\t\t\tC += dx * dyN;\n\t\t\tif ( N === 1 ) {\n\t\t\t\treturn 0.0;\n\t\t\t}\n\t\t\tn1 = N - 1;\n\t\t\tsx = sqrt( M2x/n1 );\n\t\t\tsy = sqrt( M2y/n1 );\n\t\t\treturn ( C/n1 ) / ( sx*sy ); // Note: why all the dividing by `N`? To avoid overflow.\n\t\t}\n\t\t// Case: N = W = 1\n\t\telse if ( N === 1 ) {\n\t\t\treturn 0.0;\n\t\t}\n\t\t// Case: an outgoing value is NaN, and, thus, we need to compute the accumulated values...\n\t\telse if ( isnan( buf[ i ] ) || isnan( buf[ i+1 ] ) ) {\n\t\t\tN = 1;\n\t\t\tmx = x;\n\t\t\tmy = y;\n\t\t\tM2x = 0.0;\n\t\t\tM2y = 0.0;\n\t\t\tC = 0.0;\n\t\t\tfor ( k = 0; k < W; k++ ) {\n\t\t\t\tj = 2 * k; // convert to a strided array index\n\t\t\t\tif ( j !== i ) {\n\t\t\t\t\tv1 = buf[ j ];\n\t\t\t\t\tv2 = buf[ j+1 ];\n\t\t\t\t\tif ( isnan( v1 ) || isnan( v2 ) ) {\n\t\t\t\t\t\tN = W; // explicitly set to avoid `N < W` branch\n\t\t\t\t\t\tC = NaN;\n\t\t\t\t\t\tbreak; // co-moment is automatically NaN, so no need to continue\n\t\t\t\t\t}\n\t\t\t\t\tN += 1;\n\n\t\t\t\t\tdx = v1 - mx;\n\t\t\t\t\tmx += dx / N;\n\t\t\t\t\tM2x += dx * ( v1-mx );\n\n\t\t\t\t\tdy = v2 - my;\n\t\t\t\t\tmy += dy / N;\n\t\t\t\t\tdyN = v2 - my;\n\t\t\t\t\tM2y += dy * dyN;\n\n\t\t\t\t\tC += dx * dyN;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// Case: neither the current co-moment nor the incoming values are NaN, so we need to update the accumulated values...\n\t\telse if ( isnan( C ) === false ) {\n\t\t\tdx0 = buf[ i ] - mx;\n\t\t\tdy0 = buf[ i+1 ] - my;\n\t\t\tdxN = x - mx;\n\t\t\tdyN = y - my;\n\t\t\tdx = dxN - dx0;\n\t\t\tdy = dyN - dy0;\n\t\t\tmx += dx / W;\n\t\t\tmy += dy / W;\n\t\t\tM2x += dx * ( dx0+(x-mx) );\n\t\t\tM2y += dy * ( dy0+(y-my) );\n\t\t\tC += (dxN*dyN) - (dx0*dy0) - ( dx*dy/W );\n\t\t}\n\t\t// Case: the current co-moment is NaN, so nothing to do until the buffer no longer contains NaN values...\n\t\tbuf[ i ] = x;\n\t\tbuf[ i+1 ] = y;\n\n\t\tsx = sqrt( M2x/n );\n\t\tsy = sqrt( M2y/n );\n\t\treturn ( C/n ) / ( sx*sy ); // Note: why all the dividing by `n`? To avoid overflow.\n\t}\n\n\t/**\n\t* If provided a value, the accumulator function returns an updated sample correlation coefficient. If not provided a value, the accumulator function returns the current sample correlation coefficient.\n\t*\n\t* @private\n\t* @param {number} [x] - input value\n\t* @param {number} [y] - input value\n\t* @returns {(number|null)} sample correlation coefficient or null\n\t*/\n\tfunction accumulator2( x, y ) {\n\t\tvar k;\n\t\tvar j;\n\t\tif ( arguments.length === 0 ) {\n\t\t\tif ( N === 0 ) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tif ( N < W ) {\n\t\t\t\treturn ( C/N ) / ( sx*sy );\n\t\t\t}\n\t\t\treturn ( C/W ) / ( sx*sy );\n\t\t}\n\t\t// Update the window and strided array indices for managing the circular buffer:\n\t\twi = (wi+1) % W;\n\t\ti = 2 * wi;\n\n\t\t// Case: an incoming value is NaN, the sliding co-moment is automatically NaN...\n\t\tif ( isnan( x ) || isnan( y ) ) {\n\t\t\tN = W; // explicitly set to avoid `N < W` branch\n\t\t\tC = NaN;\n\t\t}\n\t\t// Case: initial window...\n\t\telse if ( N < W ) {\n\t\t\tbuf[ i ] = x; // update buffer\n\t\t\tbuf[ i+1 ] = y;\n\n\t\t\tN += 1;\n\t\t\tdx = x - mx;\n\t\t\tM2x += dx * dx;\n\t\t\tdy = y - my;\n\t\t\tM2y += dy * dy;\n\n\t\t\tC += dx * dy;\n\t\t\tsx = sqrt( M2x/N );\n\t\t\tsy = sqrt( M2y/N );\n\t\t\treturn ( C/N ) / ( sx*sy ); // Note: why all the dividing by `N`? To avoid overflow.\n\t\t}\n\t\t// Case: an outgoing value is NaN, and, thus, we need to compute the accumulated values...\n\t\telse if ( isnan( buf[ i ] ) || isnan( buf[ i+1 ] ) ) {\n\t\t\tM2x = 0.0;\n\t\t\tM2y = 0.0;\n\t\t\tC = 0.0;\n\t\t\tfor ( k = 0; k < W; k++ ) {\n\t\t\t\tj = 2 * k; // convert to a strided array index\n\t\t\t\tif ( j !== i ) {\n\t\t\t\t\tif ( isnan( buf[ j ] ) || isnan( buf[ j+1 ] ) ) {\n\t\t\t\t\t\tN = W; // explicitly set to avoid `N < W` branch\n\t\t\t\t\t\tC = NaN;\n\t\t\t\t\t\tbreak; // co-moment is automatically NaN, so no need to continue\n\t\t\t\t\t}\n\t\t\t\t\tdx = buf[j] - mx;\n\t\t\t\t\tM2x += dx * dx;\n\t\t\t\t\tdy = buf[j+1] - my;\n\t\t\t\t\tM2y += dy * dy;\n\t\t\t\t\tC += dx * dy;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// Case: neither the current co-moment nor the incoming values are NaN, so we need to update the accumulated values...\n\t\telse if ( isnan( C ) === false ) {\n\t\t\t// Use textbook formulas along with simplification arising from difference of sums:\n\t\t\tdx0 = buf[ i ] - mx;\n\t\t\tdxN = x - mx;\n\t\t\tdy0 = buf[ i+1 ] - my;\n\t\t\tdyN = y - my;\n\t\t\tM2x += ( dxN-dx0 ) * ( dxN+dx0 );\n\t\t\tM2y += ( dyN-dy0 ) * ( dyN+dy0 );\n\t\t\tC += ( dxN*dyN ) - ( dx0*dy0 );\n\t\t}\n\t\t// Case: the current co-moment is NaN, so nothing to do until the buffer no longer contains NaN values...\n\t\tbuf[ i ] = x;\n\t\tbuf[ i+1 ] = y;\n\n\t\tsx = sqrt( M2x/W );\n\t\tsy = sqrt( M2y/W );\n\t\treturn ( C/W ) / ( sx*sy ); // Note: why all the dividing by `W`? To avoid overflow.\n\t}\n}\n\n\n// EXPORTS //\nexport default incrmpcorr;\n","import __var_0__ from './main.js';\n/**\n\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n/**\n* Compute a moving sample Pearson product-moment correlation coefficient incrementally.\n*\n* @module @stdlib/stats/incr/mpcorr\n*\n* @example\n* var incrmpcorr = require( '@stdlib/stats/incr/mpcorr' );\n*\n* var accumulator = incrmpcorr( 3 );\n*\n* var r = accumulator();\n* // returns null\n*\n* r = accumulator( 2.0, 1.0 );\n* // returns 0.0\n*\n* r = accumulator( -5.0, 3.14 );\n* // returns ~-1.0\n*\n* r = accumulator( 3.0, -1.0 );\n* // returns ~-0.925\n*\n* r = accumulator( 5.0, -9.5 );\n* // returns ~-0.863\n*\n* r = accumulator();\n* // returns ~-0.863\n*/\n\n// MODULES //\nvar incrmpcorr = __var_0__;\n\n\n// EXPORTS //\nexport default incrmpcorr;\n"]}