// This file is a part of stdlib. License is Apache-2.0: http://www.apache.org/licenses/LICENSE-2.0
import i from"./../../assert/has-own-property.js";import t from"./../../assert/is-plain-object.js";import e from"./../../assert/is-positive-integer.js";import n from"./../../assert/is-boolean.js";import r from"./minmax.js";import a from"./meanstdev.js";import o from"./../../utils/copy.js";import s from"./../../utils/define-read-only-property.js";import l from"./../../utils/define-read-only-accessor.js";import m from"./../../math/base/special/max.js";import p from"./../../math/base/special/sqrt.js";import u from"./../../math/base/special/roundn.js";import f from"./../base/dists/t/quantile.js";import v from"./../../assert/is-number.js";import c from"./../../assert/is-string.js";import d from"./../../assert/is-nonnegative-integer.js";import h from"./../../assert/is-nan.js";var g=i,j=t,b=v.isPrimitive,w=c.isPrimitive,y=d.isPrimitive,T=h;function x(i,t){if(!j(t))return new TypeError("invalid argument. Options argument must be an object. Value: `"+t+"`.");if(g(t,"alpha")){if(i.alpha=t.alpha,!b(i.alpha)||T(i.alpha))return new TypeError("invalid option. `alpha` option must be a number primitive. Option: `"+i.alpha+"`.");if(i.alpha<0||i.alpha>1)return new RangeError("invalid option. `alpha` option must be on the interval [0,1]. Option: `"+i.alpha+"`.")}return g(t,"alternative")&&(i.alternative=t.alternative,!w(i.alternative))?new TypeError("invalid option. `alternative` option must be a string primitive. Option: `"+i.alternative+"`."):g(t,"init")&&(i.init=t.init,!y(i.init))?new TypeError("invalid option. `init` option must be a nonnegative integer. Option: `"+i.init+"`."):null}var E=100,O=.05,P="two-sided",V=4,q=!0,R={init:E,alpha:O,alternative:P,digits:V,decision:q},A=i,D=t,F=e.isPrimitive,G=n.isPrimitive,M=r,k=a,z=o,B=s,C=l,H=m,I=p,J=u,K=f,L=x,N=R;function Q(){var i,t,e,n,r,a,o,s,l,m,p;if(n=z(N),arguments.length&&(r=L(n,arguments[0])))throw r;return C(t={},"rejected",f),B(t,"alpha",n.alpha),C(t,"criticalValue",v),C(t,"statistic",c),C(t,"df",d),C(t,"mean",h),C(t,"sd",g),C(t,"min",j),C(t,"max",b),B(t,"alt",n.alternative),B(t,"method","Grubbs' Test"),B(t,"print",w),m=0,l=0,p=0,s=0,e=M(a=[0,0]),i=k(o=[0,0]),u;function u(r){var u,f,v;return 0===arguments.length?m<n.init||l<=0?null:t:(m+=1,i(r),e(r),l=m-2,m<n.init||l<=0?null:("min"===n.alternative?(p=(o[0]-a[0])/o[1],u=n.alpha/m):"max"===n.alternative?(p=(a[1]-o[0])/o[1],u=n.alpha/m):(f=H(o[0]-a[0],a[1]-o[0]),p=f/o[1],u=n.alpha/(2*m)),v=K(1-u,l),s=(m-1)*v/I(m*(l+v*v)),t))}function f(){return p>s}function v(){return s}function c(){return p}function d(){return l}function h(){return o[0]}function g(){return o[1]}function j(){return a[0]}function b(){return a[1]}function w(i){var e,r,m;if(r=n.digits,e=n.decision,arguments.length>0){if(!D(i))throw new TypeError("invalid argument. Must provide an object. Value: `"+i+"`.");if(A(i,"digits")){if(!F(i.digits))throw new TypeError("invalid option. `digits` option must be a positive integer. Option: `"+i.digits+"`.");r=i.digits}if(A(i,"decision")){if(!G(i.decision))throw new TypeError("invalid option. `decision` option must be boolean. Option: `"+i.decision+"`.");e=i.decision}}return m="",m+=t.method,m+="\n\n",m+="Alternative hypothesis: ","max"===n.alternative?m+="The maximum value ("+a[1]+") is an outlier":"min"===n.alternative?m+="The minimum value ("+a[0]+") is an outlier":(m+="The ",o[0]-a[0]>a[1]-o[0]?m+="minimum value ("+a[0]+")":m+="maximum value ("+a[1]+")",m+=" is an outlier"),m+="\n\n",m+="    criticalValue: "+J(s,-r)+"\n",m+="    statistic: "+J(p,-r)+"\n",m+="    df: "+l+"\n",m+="\n",e&&(m+="Test Decision: ",m+=p>s?"Reject null in favor of alternative at "+100*n.alpha+"% significance level":"Fail to reject null in favor of alternative at "+100*n.alpha+"% significance level",m+="\n"),m}}var S=Q;export default S;
//# sourceMappingURL=grubbs.js.map