{"version":3,"sources":["@stdlib/stats/incr/mstdev/lib/main.js","@stdlib/stats/incr/mstdev/lib/index.js"],"names":["isPositiveInteger","__var_0__","isPrimitive","isNumber","__var_1__","isnan","__var_2__","sqrt","__var_3__","incrmstdev","W","mean","delta","buf","tmp","M2","mu","N","n","i","TypeError","Array","arguments","length","accumulator2","accumulator1","x","k","v","NaN"],"mappings":"mMAyBA,IAAIA,EAAoBC,EAAUC,YAC9BC,EAAWC,EAAUF,YACrBG,EAAQC,EACRC,EAAOC,EA2GX,SAASC,EAAYC,EAAGC,GACvB,IAAIC,EACAC,EACAC,EACAC,EACAC,EAGAC,EACAC,EACAC,EACJ,IAAMnB,EAAmBU,GACxB,MAAM,IAAIU,UAAW,8DAAgEV,EAAI,MAO1F,GALAG,EAAM,IAAIQ,MAAOX,GACjBQ,EAAIR,EAAI,EACRK,EAAK,EACLI,GAAK,EACLF,EAAI,EACCK,UAAUC,OAAS,EAAI,CAC3B,IAAMpB,EAAUQ,GACf,MAAM,IAAIS,UAAW,8DAAgET,EAAO,MAG7F,OADAK,EAAKL,EACEa,EAGR,OADAR,EAAK,EACES,EASP,SAASA,EAAcC,GACtB,IAAIC,EACAC,EACJ,GAA0B,IAArBN,UAAUC,OACd,OAAW,IAANN,EACG,KAEG,IAANA,EACKZ,EAAOU,GAASc,IAAM,EAGxBtB,EADHU,EAAIP,EACKK,GAAME,EAAE,GAETF,EAAKG,GAMnB,GAHAC,GAAKA,EAAE,GAAKT,EAGPL,EAAOqB,GACXT,EAAIP,EACJK,EAAKc,QAGD,CAAA,GAAKZ,EAAIP,EAMb,OALAG,EAAKM,GAAMO,EAIXX,IAFAH,EAAQc,EAAIV,IAEGU,GADfV,GAAMJ,GAFNK,GAAK,KAIM,IAANA,EACG,EAEDV,EAAMQ,GAAME,EAAE,IAGjB,GAAW,IAANA,EAET,OADAF,EAAK,EAID,GAAKV,EAAOQ,EAAKM,KAIrB,IAHAF,EAAI,EACJD,EAAKU,EACLX,EAAK,EACCY,EAAI,EAAGA,EAAIjB,EAAGiB,IACnB,GAAKA,IAAMR,EAAI,CAEd,GADAS,EAAIf,EAAKc,GACJtB,EAAOuB,GAAM,CACjBX,EAAIP,EACJK,EAAKc,IACL,MAKDd,IAFAH,EAAQgB,EAAIZ,IAEGY,GADfZ,GAAMJ,GAFNK,GAAK,WAQkB,IAAhBZ,EAAOU,KAChBD,EAAMD,EAAKM,GAKXJ,IAJAH,EAAQc,EAAIZ,IACPA,EAAME,GAENU,GADLV,GAAMJ,EAAQF,MAOf,OADAG,EAAKM,GAAMO,EACJnB,EAAMQ,EAAKG,GAUnB,SAASM,EAAcE,GACtB,IAAIC,EACJ,GAA0B,IAArBL,UAAUC,OACd,OAAW,IAANN,EACG,KAGAV,EADHU,EAAIP,EACKK,EAAKE,EAENF,EAAKL,GAMnB,GAHAS,GAAKA,EAAE,GAAKT,EAGPL,EAAOqB,GACXT,EAAIP,EACJK,EAAKc,QAGD,CAAA,GAAKZ,EAAIP,EAKb,OAJAG,EAAKM,GAAMO,EAIJnB,GADPQ,IADAH,EAAQc,EAAIV,GACEJ,IAFdK,GAAK,IAMD,GAAKZ,EAAOQ,EAAKM,KAErB,IADAJ,EAAK,EACCY,EAAI,EAAGA,EAAIjB,EAAGiB,IACnB,GAAKA,IAAMR,EAAI,CACd,GAAKd,EAAOQ,EAAKc,IAAQ,CACxBV,EAAIP,EACJK,EAAKc,IACL,MAEDjB,EAAQC,EAAKc,GAAMX,EACnBD,GAAMH,EAAQA,QAKS,IAAhBP,EAAOU,KAChBD,EAAMD,EAAKM,GACXJ,IAAQW,EAAEZ,IAAUY,EAAEV,EAAKF,EAAIE,IAKhC,OADAH,EAAKM,GAAMO,EACJnB,EAAMQ,EAAKL,IC5PjB,IAACD,EAAaR","sourcesContent":["import __var_0__ from '@stdlib/assert/is-positive-integer';\nimport __var_1__ from '@stdlib/assert/is-number';\nimport __var_2__ from '@stdlib/math/base/assert/is-nan';\nimport __var_3__ from '@stdlib/math/base/special/sqrt';\n/**\n\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\nvar isPositiveInteger = __var_0__.isPrimitive;\nvar isNumber = __var_1__.isPrimitive;\nvar isnan = __var_2__;\nvar sqrt = __var_3__;\n\n\n// MAIN //\n\n/**\n* Returns an accumulator function which incrementally computes a moving corrected sample standard deviation.\n*\n* ## Method\n*\n* -   Let \\\\(W\\\\) be a window of \\\\(N\\\\) elements over which we want to compute an corrected sample standard deviation.\n*\n* -   We first recognize that the corrected sample standard deviation is defined as the square root of the unbiased sample variance. Accordingly, in order to derive an update equation for the corrected sample standard deviation, deriving an update equation for the unbiased sample variance is sufficient.\n*\n* -   The difference between the unbiased sample variance in a window \\\\(W_i\\\\) and the unbiased sample variance in a window \\\\(W_{i+1})\\\\) is given by\n*\n*     ```tex\n*     \\Delta s^2 = s_{i+1}^2 - s_{i}^2\n*     ```\n*\n* -   If we multiply both sides by \\\\(N-1\\\\),\n*\n*     ```tex\n*     (N-1)(\\Delta s^2) = (N-1)s_{i+1}^2 - (N-1)s_{i}^2\n*     ```\n*\n* -   If we substitute the definition of the unbiased sample variance having the form\n*\n*     ```tex\n*     \\begin{align*}\n*     s^2 &= \\frac{1}{N-1} \\biggl( \\sum_{i=1}^{N} (x_i - \\bar{x})^2 \\biggr) \\\\\n*         &= \\frac{1}{N-1} \\biggl( \\sum_{i=1}^{N} (x_i^2 - 2\\bar{x}x_i + \\bar{x}^2) \\biggr) \\\\\n*         &= \\frac{1}{N-1} \\biggl( \\sum_{i=1}^{N} x_i^2 - 2\\bar{x} \\sum_{i=1}^{N} x_i + \\sum_{i=1}^{N} \\bar{x}^2) \\biggr) \\\\\n*         &= \\frac{1}{N-1} \\biggl( \\sum_{i=1}^{N} x_i^2 - \\frac{2N\\bar{x}\\sum_{i=1}^{N} x_i}{N} + N\\bar{x}^2 \\biggr) \\\\\n*         &= \\frac{1}{N-1} \\biggl( \\sum_{i=1}^{N} x_i^2 - 2N\\bar{x}^2 + N\\bar{x}^2 \\biggr) \\\\\n*         &= \\frac{1}{N-1} \\biggl( \\sum_{i=1}^{N} x_i^2 - N\\bar{x}^2 \\biggr)\n*     \\end{align*}\n*     ```\n*\n*     we return\n*\n*     ```tex\n*     (N-1)(\\Delta s^2) = \\biggl(\\sum_{k=1}^N x_k^2 - N\\bar{x}_{i+1}^2 \\biggr) - \\biggl(\\sum_{k=0}^{N-1} x_k^2 - N\\bar{x}_{i}^2 \\biggr)\n*     ```\n*\n* -   This can be further simplified by recognizing that subtracting the sums reduces to \\\\(x_N^2 - x_0^2\\\\); in which case,\n*\n*     ```tex\n*     \\begin{align*}\n*     (N-1)(\\Delta s^2) &= x_N^2 - x_0^2 - N\\bar{x}_{i+1}^2 + N\\bar{x}_{i}^2 \\\\\n*     &= x_N^2 - x_0^2 - N(\\bar{x}_{i+1}^2 - \\bar{x}_{i}^2) \\\\\n*     &= x_N^2 - x_0^2 - N(\\bar{x}_{i+1} - \\bar{x}_{i})(\\bar{x}_{i+1} + \\bar{x}_{i})\n*     \\end{align*}\n*     ```\n*\n* -   Recognizing that the difference of means can be expressed\n*\n*     ```tex\n*     \\bar{x}_{i+1} - \\bar{x}_i = \\frac{1}{N} \\biggl( \\sum_{k=1}^N x_k - \\sum_{k=0}^{N-1} x_k \\biggr) = \\frac{x_N - x_0}{N}\n*     ```\n*\n*     and substituting into the equation above\n*\n*     ```tex\n*     (N-1)(\\Delta s^2) = x_N^2 - x_0^2 - (x_N - x_0)(\\bar{x}_{i+1} + \\bar{x}_{i})\n*     ```\n*\n* -   Rearranging terms gives us the update equation\n*\n*     ```tex\n*     \\begin{align*}\n*     (N-1)(\\Delta s^2) &= (x_N - x_0)(x_N + x_0) - (x_N - x_0)(\\bar{x}_{i+1} + \\bar{x}_{i})\n*     &= (x_N - x_0)(x_N + x_0 - \\bar{x}_{i+1} - \\bar{x}_{i}) \\\\\n*     &= (x_N - x_0)(x_N - \\bar{x}_{i+1} + x_0 - \\bar{x}_{i})\n*     \\end{align*}\n*     ```\n*\n* @param {PositiveInteger} W - window size\n* @param {number} [mean] - mean value\n* @throws {TypeError} first argument must be a positive integer\n* @throws {TypeError} second argument must be a number primitive\n* @returns {Function} accumulator function\n*\n* @example\n* var accumulator = incrmstdev( 3 );\n*\n* var s = accumulator();\n* // returns null\n*\n* s = accumulator( 2.0 );\n* // returns 0.0\n*\n* s = accumulator( -5.0 );\n* // returns ~4.95\n*\n* s = accumulator( 3.0 );\n* // returns ~4.36\n*\n* s = accumulator( 5.0 );\n* // returns ~5.29\n*\n* s = accumulator();\n* // returns ~5.29\n*\n* @example\n* var accumulator = incrmstdev( 3, 5.0 );\n*/\nfunction incrmstdev( W, mean ) {\n\tvar delta;\n\tvar buf;\n\tvar tmp;\n\tvar M2;\n\tvar mu;\n\tvar d1;\n\tvar d2;\n\tvar N;\n\tvar n;\n\tvar i;\n\tif ( !isPositiveInteger( W ) ) {\n\t\tthrow new TypeError( 'invalid argument. Must provide a positive integer. Value: `' + W + '`.' );\n\t}\n\tbuf = new Array( W );\n\tn = W - 1;\n\tM2 = 0.0;\n\ti = -1;\n\tN = 0;\n\tif ( arguments.length > 1 ) {\n\t\tif ( !isNumber( mean ) ) {\n\t\t\tthrow new TypeError( 'invalid argument. Must provide a number primitive. Value: `' + mean + '`.' );\n\t\t}\n\t\tmu = mean;\n\t\treturn accumulator2;\n\t}\n\tmu = 0.0;\n\treturn accumulator1;\n\n\t/**\n\t* If provided a value, the accumulator function returns an updated corrected sample standard deviation. If not provided a value, the accumulator function returns the current corrected sample standard deviation.\n\t*\n\t* @private\n\t* @param {number} [x] - input value\n\t* @returns {(number|null)} corrected sample standard deviation or null\n\t*/\n\tfunction accumulator1( x ) {\n\t\tvar k;\n\t\tvar v;\n\t\tif ( arguments.length === 0 ) {\n\t\t\tif ( N === 0 ) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tif ( N === 1 ) {\n\t\t\t\treturn ( isnan( M2 ) ) ? NaN : 0.0;\n\t\t\t}\n\t\t\tif ( N < W ) {\n\t\t\t\treturn sqrt( M2 / (N-1) );\n\t\t\t}\n\t\t\treturn sqrt( M2 / n );\n\t\t}\n\t\t// Update the index for managing the circular buffer:\n\t\ti = (i+1) % W;\n\n\t\t// Case: incoming value is NaN, the sliding second moment is automatically NaN...\n\t\tif ( isnan( x ) ) {\n\t\t\tN = W; // explicitly set to avoid `N < W` branch\n\t\t\tM2 = NaN;\n\t\t}\n\t\t// Case: initial window...\n\t\telse if ( N < W ) {\n\t\t\tbuf[ i ] = x; // update buffer\n\t\t\tN += 1;\n\t\t\tdelta = x - mu;\n\t\t\tmu += delta / N;\n\t\t\tM2 += delta * (x - mu);\n\t\t\tif ( N === 1 ) {\n\t\t\t\treturn 0.0;\n\t\t\t}\n\t\t\treturn sqrt( M2 / (N-1) );\n\t\t}\n\t\t// Case: N = W = 1\n\t\telse if ( N === 1 ) {\n\t\t\tM2 = 0.0;\n\t\t\treturn M2;\n\t\t}\n\t\t// Case: outgoing value is NaN, and, thus, we need to compute the accumulated values...\n\t\telse if ( isnan( buf[ i ] ) ) {\n\t\t\tN = 1;\n\t\t\tmu = x;\n\t\t\tM2 = 0.0;\n\t\t\tfor ( k = 0; k < W; k++ ) {\n\t\t\t\tif ( k !== i ) {\n\t\t\t\t\tv = buf[ k ];\n\t\t\t\t\tif ( isnan( v ) ) {\n\t\t\t\t\t\tN = W; // explicitly set to avoid `N < W` branch\n\t\t\t\t\t\tM2 = NaN;\n\t\t\t\t\t\tbreak; // second moment is automatically NaN, so no need to continue\n\t\t\t\t\t}\n\t\t\t\t\tN += 1;\n\t\t\t\t\tdelta = v - mu;\n\t\t\t\t\tmu += delta / N;\n\t\t\t\t\tM2 += delta * (v - mu);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// Case: neither the current second moment nor the incoming value are NaN, so we need to update the accumulated values...\n\t\telse if ( isnan( M2 ) === false ) {\n\t\t\ttmp = buf[ i ];\n\t\t\tdelta = x - tmp;\n\t\t\td1 = tmp - mu;\n\t\t\tmu += delta / W;\n\t\t\td2 = x - mu;\n\t\t\tM2 += delta * (d1 + d2);\n\t\t}\n\t\t// Case: the current second moment is NaN, so nothing to do until the buffer no longer contains NaN values...\n\n\t\tbuf[ i ] = x;\n\t\treturn sqrt( M2 / n );\n\t}\n\n\t/**\n\t* If provided a value, the accumulator function returns an updated corrected sample standard deviation. If not provided a value, the accumulator function returns the current corrected sample standard deviation.\n\t*\n\t* @private\n\t* @param {number} [x] - input value\n\t* @returns {(number|null)} corrected sample standard deviation or null\n\t*/\n\tfunction accumulator2( x ) {\n\t\tvar k;\n\t\tif ( arguments.length === 0 ) {\n\t\t\tif ( N === 0 ) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tif ( N < W ) {\n\t\t\t\treturn sqrt( M2 / N );\n\t\t\t}\n\t\t\treturn sqrt( M2 / W );\n\t\t}\n\t\t// Update the index for managing the circular buffer:\n\t\ti = (i+1) % W;\n\n\t\t// Case: incoming value is NaN, the sliding second moment is automatically NaN...\n\t\tif ( isnan( x ) ) {\n\t\t\tN = W; // explicitly set to avoid `N < W` branch\n\t\t\tM2 = NaN;\n\t\t}\n\t\t// Case: initial window...\n\t\telse if ( N < W ) {\n\t\t\tbuf[ i ] = x; // update buffer\n\t\t\tN += 1;\n\t\t\tdelta = x - mu;\n\t\t\tM2 += delta * delta;\n\t\t\treturn sqrt( M2 / N );\n\t\t}\n\t\t// Case: outgoing value is NaN, and, thus, we need to compute the accumulated values...\n\t\telse if ( isnan( buf[ i ] ) ) {\n\t\t\tM2 = 0.0;\n\t\t\tfor ( k = 0; k < W; k++ ) {\n\t\t\t\tif ( k !== i ) {\n\t\t\t\t\tif ( isnan( buf[ k ] ) ) {\n\t\t\t\t\t\tN = W; // explicitly set to avoid `N < W` branch\n\t\t\t\t\t\tM2 = NaN;\n\t\t\t\t\t\tbreak; // second moment is automatically NaN, so no need to continue\n\t\t\t\t\t}\n\t\t\t\t\tdelta = buf[ k ] - mu;\n\t\t\t\t\tM2 += delta * delta;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// Case: neither the current second moment nor the incoming value are NaN, so we need to update the accumulated values...\n\t\telse if ( isnan( M2 ) === false ) {\n\t\t\ttmp = buf[ i ];\n\t\t\tM2 += ( x-tmp ) * ( x-mu + tmp-mu );\n\t\t}\n\t\t// Case: the current second moment is NaN, so nothing to do until the buffer no longer contains NaN values...\n\n\t\tbuf[ i ] = x;\n\t\treturn sqrt( M2 / W );\n\t}\n}\n\n\n// EXPORTS //\nexport default incrmstdev;\n","import __var_0__ from './main.js';\n/**\n\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n/**\n* Compute a moving corrected sample standard deviation incrementally.\n*\n* @module @stdlib/stats/incr/mstdev\n*\n* @example\n* var incrmstdev = require( '@stdlib/stats/incr/mstdev' );\n*\n* var accumulator = incrmstdev( 3 );\n*\n* var s = accumulator();\n* // returns null\n*\n* s = accumulator( 2.0 );\n* // returns 0.0\n*\n* s = accumulator( -5.0 );\n* // returns ~4.95\n*\n* s = accumulator( 3.0 );\n* // returns ~4.36\n*\n* s = accumulator( 5.0 );\n* // returns ~5.29\n*\n* s = accumulator();\n* // returns ~5.29\n*/\n\n// MODULES //\nvar incrmstdev = __var_0__;\n\n\n// EXPORTS //\nexport default incrmstdev;\n"]}