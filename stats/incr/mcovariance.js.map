{"version":3,"sources":["@stdlib/stats/incr/mcovariance/lib/main.js","@stdlib/stats/incr/mcovariance/lib/index.js"],"names":["isPositiveInteger","__var_0__","isPrimitive","isNumber","__var_1__","isnan","__var_2__","incrmcovariance","W","meanx","meany","buf","dx0","dxN","dy0","dyN","mx","my","wi","C","N","n","i","TypeError","Array","arguments","length","accumulator2","accumulator1","x","y","v1","v2","k","j","NaN"],"mappings":"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","sourcesContent":["import __var_0__ from '@stdlib/assert/is-positive-integer';\nimport __var_1__ from '@stdlib/assert/is-number';\nimport __var_2__ from '@stdlib/math/base/assert/is-nan';\n/**\n\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\nvar isPositiveInteger = __var_0__.isPrimitive;\nvar isNumber = __var_1__.isPrimitive;\nvar isnan = __var_2__;\n\n\n// MAIN //\n\n/**\n* Returns an accumulator function which incrementally computes a moving unbiased sample covariance.\n*\n* ## Method\n*\n* -   Let \\\\(W\\\\) be a window of \\\\(N\\\\) elements over which we want to compute an unbiased sample covariance.\n*\n* -   We begin by defining the covariance \\\\( \\operatorname{cov}_n(x,y) \\\\) for a window \\\\(n\\\\) as follows\n*\n*     ```tex\n*     \\operatorname{cov}_n(x,y) &= \\frac{C_n}{n}\n*     ```\n*\n*     where \\\\(C_n\\\\) is the co-moment, which is defined as\n*\n*     ```tex\n*     C_n = \\sum_{i=1}^{N} ( x_i - \\bar{x}_n ) ( y_i - \\bar{y}_n )\n*     ```\n*\n*     and where \\\\(\\bar{x}_n\\\\) and \\\\(\\bar{y}_n\\\\) are the sample means for \\\\(x\\\\) and \\\\(y\\\\), respectively, and \\\\(i=1\\\\) specifies the first element in a window.\n*\n* -   The sample mean is computed using the canonical formula\n*\n*     ```tex\n*     \\bar{x}_n = \\frac{1}{N} \\sum_{i=1}^{N} x_i\n*     ```\n*\n*     which, taking into account a previous window, can be expressed\n*\n*     ```tex\n*     \\begin{align*}\n*     \\bar{x}_n &= \\frac{1}{N} \\biggl( \\sum_{i=0}^{N-1} x_i - x_0 + x_N \\biggr) \\\\\n*               &= \\bar{x}_{n-1} + \\frac{x_N - x_0}{N}\n*     \\end{align*}\n*     ```\n*\n*     where \\\\(x_0\\\\) is the first value in the previous window.\n*\n* -   We can substitute into the co-moment equation\n*\n*     ```tex\n*     \\begin{align*}\n*     C_n &= \\sum_{i=1}^{N} ( x_i - \\bar{x}_n ) ( y_i - \\bar{y}_n ) \\\\\n*         &= \\sum_{i=1}^{N} \\biggl( x_i - \\bar{x}_{n-1} - \\frac{x_N - x_0}{N} \\biggr) \\biggl( y_i - \\bar{y}_{n-1} - \\frac{y_N - y_0}{N} \\biggr) \\\\\n*         &= \\sum_{i=1}^{N} \\biggl( \\Delta x_{i,n-1} - \\frac{x_N - x_0}{N} \\biggr) \\biggl( \\Delta y_{i,n-1} - \\frac{y_N - y_0}{N} \\biggr)\n*     \\end{align*}\n*     ```\n*\n*     where\n*\n*     ```tex\n*     \\Delta x_{i,k} = x_i - \\bar{x}_{k}\n*     ```\n*\n* -   We can subsequently expand terms and apply a summation identity\n*\n*     ```tex\n*     \\begin{align*}\n*     C_n &= \\sum_{i=1}^{N} \\Delta x_{i,n-1} \\Delta y_{i,n-1} - \\sum_{i=1}^{N} \\Delta x_{i,n-1} \\biggl( \\frac{y_N - y_0}{N} \\biggr) - \\sum_{i=1}^{N} \\Delta y_{i,n-1} \\biggl( \\frac{x_N - x_0}{N} \\biggr) + \\sum_{i=1}^{N} \\biggl( \\frac{x_N - x_0}{N} \\biggr) \\biggl( \\frac{y_N - y_0}{N} \\biggr) \\\\\n*         &= \\sum_{i=1}^{N} \\Delta x_{i,n-1} \\Delta y_{i,n-1} - \\biggl( \\frac{y_N - y_0}{N} \\biggr) \\sum_{i=1}^{N} \\Delta x_{i,n-1} - \\biggl( \\frac{x_N - x_0}{N} \\biggr) \\sum_{i=1}^{N} \\Delta y_{i,n-1} + \\frac{(x_N - x_0)(y_N - y_0)}{N}\n*     \\end{align*}\n*     ```\n*\n* -   Let us first consider the second term which we can reorganize as follows\n*\n*     ```tex\n*     \\begin{align*}\n*     \\biggl( \\frac{y_N - y_0}{N} \\biggr) \\sum_{i=1}^{N} \\Delta x_{i,n-1} &= \\biggl( \\frac{y_N - y_0}{N} \\biggr) \\sum_{i=1}{N} ( x_i - \\bar{x}_{n-1}) \\\\\n*         &= \\biggl( \\frac{y_N - y_0}{N} \\biggr) \\sum_{i=1}^{N} x_i - \\biggl( \\frac{y_N - y_0}{N} \\biggr) \\sum_{i=1}^{N} \\bar{x}_{n-1} \\\\\n*         &= (y_N - y_0) \\bar{x}_{n} - (y_N - y_0)\\bar{x}_{n-1} \\\\\n*         &= (y_N - y_0) (\\bar{x}_{n} - \\bar{x}_{n-1}) \\\\\n*         &= \\frac{(x_N - x_0)(y_N - y_0)}{N}\n*     \\end{align*}\n*     ```\n*\n* -   The third term can be reorganized in a manner similar to the second term such that\n*\n*     ```tex\n*     \\biggl( \\frac{x_N - x_0}{N} \\biggr) \\sum_{i=1}^{N} \\Delta y_{i,n-1} = \\frac{(x_N - x_0)(y_N - y_0)}{N}\n*     ```\n*\n* -   Substituting back into the equation for the co-moment\n*\n*     ```tex\n*     \\begin{align*}\n*     C_n &= \\sum_{i=1}^{N} \\Delta x_{i,n-1} \\Delta y_{i,n-1} - \\frac{(x_N - x_0)(y_N - y_0)}{N} - \\frac{(x_N - x_0)(y_N - y_0)}{N} + \\frac{(x_N - x_0)(y_N - y_0)}{N} \\\\\n*         &= \\sum_{i=1}^{N} \\Delta x_{i,n-1} \\Delta y_{i,n-1} - \\frac{(x_N - x_0)(y_N - y_0)}{N}\n*     \\end{align*}\n*     ```\n*\n* -   Let us now consider the first term which we can modify as follows\n*\n*     ```tex\n*     \\begin{align*}\n*     \\sum_{i=1}^{N} \\Delta x_{i,n-1} \\Delta y_{i,n-1} &= \\sum_{i=1}^{N} (x_i - \\bar{x}_{n-1})(y_i - \\bar{y}_{n-1}) \\\\\n*         &= \\sum_{i=1}^{N-1} (x_i - \\bar{x}_{n-1})(y_i - \\bar{y}_{n-1}) + (x_N - \\bar{x}_{n-1})(y_N - \\bar{y}_{n-1}) \\\\\n*         &= \\sum_{i=1}^{N-1} (x_i - \\bar{x}_{n-1})(y_i - \\bar{y}_{n-1}) + (x_N - \\bar{x}_{n-1})(y_N - \\bar{y}_{n-1}) + (x_0 - \\bar{x}_{n-1})(y_0 - \\bar{y}_{n-1}) - (x_0 - \\bar{x}_{n-1})(y_0 - \\bar{y}_{n-1}) \\\\\n*         &= \\sum_{i=0}^{N-1} (x_i - \\bar{x}_{n-1})(y_i - \\bar{y}_{n-1}) + (x_N - \\bar{x}_{n-1})(y_N - \\bar{y}_{n-1}) - (x_0 - \\bar{x}_{n-1})(y_0 - \\bar{y}_{n-1})\n*     \\end{align*}\n*     ```\n*\n*     where we recognize that the first term equals the co-moment for the previous window\n*\n*     ```tex\n*     C_{n-1} = \\sum_{i=0}^{N-1} (x_i - \\bar{x}_{n-1})(y_i - \\bar{y}_{n-1})\n*     ```\n*\n*     In which case,\n*\n*     ```tex\n*     \\begin{align*}\n*     \\sum_{i=1}^{N} \\Delta x_{i,n-1} \\Delta y_{i,n-1} &= C_{n-1} + (x_N - \\bar{x}_{n-1})(y_N - \\bar{y}_{n-1}) - (x_0 - \\bar{x}_{n-1})(y_0 - \\bar{y}_{n-1}) \\\\\n*         &= C_{n-1} + \\Delta x_{N,n-1} \\Delta y_{N,n-1} - \\Delta x_{0,n-1} \\Delta y_{0,n-1}\n*     \\end{align*}\n*     ```\n*\n* -   Substituting into the equation for the co-moment\n*\n*     ```tex\n*     C_n = C_{n-1} + \\Delta x_{N,n-1} \\Delta y_{N,n-1} - \\Delta x_{0,n-1} \\Delta y_{0,n-1} - \\frac{(x_N - x_0)(y_N - y_0)}{N}\n*     ```\n*\n* -   We can make one further modification to the last term\n*\n*     ```tex\n*     \\begin{align*}\n*     \\frac{(x_N - x_0)(y_N - y_0)}{N} &= \\frac{(x_N - \\bar{x}_{n-1} - x_0 + \\bar{x}_{n-1})(y_N - \\bar{y}_{n-1} - y_0 + \\bar{y}_{n-1})}{N} \\\\\n*         &= \\frac{(\\Delta x_{N,n-1} - \\Delta x_{0,n-1})(\\Delta y_{N,n-1} - \\Delta y_{0,n-1})}{N}\n*     \\end{align*}\n*     ```\n*\n*     which, upon substitution into the equation for the co-moment, yields\n*\n*     ```tex\n*     C_n = C_{n-1} + \\Delta x_{N,n-1} \\Delta y_{N,n-1} - \\Delta x_{0,n-1} \\Delta y_{0,n-1} - \\frac{(\\Delta x_{N,n-1} - \\Delta x_{0,n-1})(\\Delta y_{N,n-1} - \\Delta y_{0,n-1})}{N}\n*     ```\n*\n*\n* @param {PositiveInteger} W - window size\n* @param {number} [meanx] - mean value\n* @param {number} [meany] - mean value\n* @throws {TypeError} first argument must be a positive integer\n* @throws {TypeError} second argument must be a number primitive\n* @throws {TypeError} third argument must be a number primitive\n* @returns {Function} accumulator function\n*\n* @example\n* var accumulator = incrmcovariance( 3 );\n*\n* var v = accumulator();\n* // returns null\n*\n* v = accumulator( 2.0, 1.0 );\n* // returns 0.0\n*\n* v = accumulator( -5.0, 3.14 );\n* // returns ~-7.49\n*\n* v = accumulator( 3.0, -1.0 );\n* // returns -8.35\n*\n* v = accumulator( 5.0, -9.5 );\n* // returns -29.42\n*\n* v = accumulator();\n* // returns -29.42\n*\n* @example\n* var accumulator = incrmcovariance( 3, -2.0, 10.0 );\n*/\nfunction incrmcovariance( W, meanx, meany ) {\n\tvar buf;\n\tvar dx0;\n\tvar dxN;\n\tvar dy0;\n\tvar dyN;\n\tvar mx;\n\tvar my;\n\tvar wi;\n\tvar C;\n\tvar N;\n\tvar n;\n\tvar i;\n\tif ( !isPositiveInteger( W ) ) {\n\t\tthrow new TypeError( 'invalid argument. First argument must be a positive integer. Value: `' + W + '`.' );\n\t}\n\tbuf = new Array( 2*W ); // strided array\n\tn = W - 1;\n\tC = 0.0;\n\twi = -1;\n\tN = 0;\n\tif ( arguments.length > 1 ) {\n\t\tif ( !isNumber( meanx ) ) {\n\t\t\tthrow new TypeError( 'invalid argument. Second argument must be a number primitive. Value: `' + meanx + '`.' );\n\t\t}\n\t\tif ( !isNumber( meany ) ) {\n\t\t\tthrow new TypeError( 'invalid argument. Third argument must be a number primitive. Value: `' + meany + '`.' );\n\t\t}\n\t\tmx = meanx;\n\t\tmy = meany;\n\t\treturn accumulator2;\n\t}\n\tmx = 0.0;\n\tmy = 0.0;\n\treturn accumulator1;\n\n\t/**\n\t* If provided a value, the accumulator function returns an updated unbiased sample covariance. If not provided a value, the accumulator function returns the current unbiased sample covariance.\n\t*\n\t* @private\n\t* @param {number} [x] - input value\n\t* @param {number} [y] - input value\n\t* @returns {(number|null)} unbiased sample covariance or null\n\t*/\n\tfunction accumulator1( x, y ) {\n\t\tvar v1;\n\t\tvar v2;\n\t\tvar k;\n\t\tvar j;\n\t\tif ( arguments.length === 0 ) {\n\t\t\tif ( N === 0 ) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tif ( N === 1 ) {\n\t\t\t\treturn 0.0;\n\t\t\t}\n\t\t\tif ( N < W ) {\n\t\t\t\treturn C / (N-1);\n\t\t\t}\n\t\t\treturn C / n;\n\t\t}\n\t\t// Update the window and strided array indices for managing the circular buffer:\n\t\twi = (wi+1) % W;\n\t\ti = 2 * wi;\n\n\t\t// Case: an incoming value is NaN, the sliding co-moment is automatically NaN...\n\t\tif ( isnan( x ) || isnan( y ) ) {\n\t\t\tN = W; // explicitly set to avoid `N < W` branch\n\t\t\tC = NaN;\n\t\t}\n\t\t// Case: initial window...\n\t\telse if ( N < W ) {\n\t\t\tbuf[ i ] = x; // update buffer\n\t\t\tbuf[ i+1 ] = y;\n\n\t\t\tN += 1;\n\t\t\tdxN = x - mx;\n\t\t\tmx += dxN / N;\n\t\t\tmy += ( y-my ) / N;\n\t\t\tC += dxN * ( y-my ); // Note: repeated `y-my` is intentional, as `my` is updated when used here\n\t\t\tif ( N === 1 ) {\n\t\t\t\treturn 0.0;\n\t\t\t}\n\t\t\treturn C / (N-1);\n\t\t}\n\t\t// Case: N = W = 1\n\t\telse if ( N === 1 ) {\n\t\t\treturn 0.0;\n\t\t}\n\t\t// Case: an outgoing value is NaN, and, thus, we need to compute the accumulated values...\n\t\telse if ( isnan( buf[ i ] ) || isnan( buf[ i+1 ] ) ) {\n\t\t\tN = 1;\n\t\t\tmx = x;\n\t\t\tmy = y;\n\t\t\tC = 0.0;\n\t\t\tfor ( k = 0; k < W; k++ ) {\n\t\t\t\tj = 2 * k; // convert to a strided array index\n\t\t\t\tif ( j !== i ) {\n\t\t\t\t\tv1 = buf[ j ];\n\t\t\t\t\tv2 = buf[ j+1 ];\n\t\t\t\t\tif ( isnan( v1 ) || isnan( v2 ) ) {\n\t\t\t\t\t\tN = W; // explicitly set to avoid `N < W` branch\n\t\t\t\t\t\tC = NaN;\n\t\t\t\t\t\tbreak; // co-moment is automatically NaN, so no need to continue\n\t\t\t\t\t}\n\t\t\t\t\tN += 1;\n\t\t\t\t\tdxN = v1 - mx;\n\t\t\t\t\tmx += dxN / N;\n\t\t\t\t\tmy += ( v2-my ) / N;\n\t\t\t\t\tC += dxN * ( v2-my ); // Note: repeated `y-my` is intentional, as `my` is updated when used here\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// Case: neither the current co-moment nor the incoming values are NaN, so we need to update the accumulated values...\n\t\telse if ( isnan( C ) === false ) {\n\t\t\tdx0 = buf[ i ] - mx;\n\t\t\tdy0 = buf[ i+1 ] - my;\n\t\t\tdxN = x - mx;\n\t\t\tdyN = y - my;\n\t\t\tC += (dxN*dyN) - (dx0*dy0) - ( (dxN-dx0)*(dyN-dy0)/W );\n\t\t\tmx += ( dxN-dx0 ) / W;\n\t\t\tmy += ( dyN-dy0 ) / W;\n\t\t}\n\t\t// Case: the current co-moment is NaN, so nothing to do until the buffer no longer contains NaN values...\n\t\tbuf[ i ] = x;\n\t\tbuf[ i+1 ] = y;\n\n\t\treturn C / n;\n\t}\n\n\t/**\n\t* If provided a value, the accumulator function returns an updated unbiased sample covariance. If not provided a value, the accumulator function returns the current unbiased sample covariance.\n\t*\n\t* @private\n\t* @param {number} [x] - input value\n\t* @param {number} [y] - input value\n\t* @returns {(number|null)} unbiased sample covariance or null\n\t*/\n\tfunction accumulator2( x, y ) {\n\t\tvar k;\n\t\tvar j;\n\t\tif ( arguments.length === 0 ) {\n\t\t\tif ( N === 0 ) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tif ( N < W ) {\n\t\t\t\treturn C / N;\n\t\t\t}\n\t\t\treturn C / W;\n\t\t}\n\t\t// Update the window and strided array indices for managing the circular buffer:\n\t\twi = (wi+1) % W;\n\t\ti = 2 * wi;\n\n\t\t// Case: an incoming value is NaN, the sliding co-moment is automatically NaN...\n\t\tif ( isnan( x ) || isnan( y ) ) {\n\t\t\tN = W; // explicitly set to avoid `N < W` branch\n\t\t\tC = NaN;\n\t\t}\n\t\t// Case: initial window...\n\t\telse if ( N < W ) {\n\t\t\tbuf[ i ] = x; // update buffer\n\t\t\tbuf[ i+1 ] = y;\n\n\t\t\tN += 1;\n\t\t\tC += ( x-mx ) * ( y-my );\n\t\t\treturn C / N;\n\t\t}\n\t\t// Case: an outgoing value is NaN, and, thus, we need to compute the accumulated values...\n\t\telse if ( isnan( buf[ i ] ) || isnan( buf[ i+1 ] ) ) {\n\t\t\tC = 0.0;\n\t\t\tfor ( k = 0; k < W; k++ ) {\n\t\t\t\tj = 2 * k; // convert to a strided array index\n\t\t\t\tif ( j !== i ) {\n\t\t\t\t\tif ( isnan( buf[ j ] ) || isnan( buf[ j+1 ] ) ) {\n\t\t\t\t\t\tN = W; // explicitly set to avoid `N < W` branch\n\t\t\t\t\t\tC = NaN;\n\t\t\t\t\t\tbreak; // co-moment is automatically NaN, so no need to continue\n\t\t\t\t\t}\n\t\t\t\t\tC += ( buf[j]-mx ) * ( buf[j+1]-my );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// Case: neither the current co-moment nor the incoming values are NaN, so we need to update the accumulated values...\n\t\telse if ( isnan( C ) === false ) {\n\t\t\t// Use textbook formula along with simplification arising from difference of sums:\n\t\t\tC += ( (x-mx)*(y-my) ) - ( (buf[i]-mx)*(buf[i+1]-my) );\n\t\t}\n\t\t// Case: the current co-moment is NaN, so nothing to do until the buffer no longer contains NaN values...\n\t\tbuf[ i ] = x;\n\t\tbuf[ i+1 ] = y;\n\n\t\treturn C / W;\n\t}\n}\n\n\n// EXPORTS //\nexport default incrmcovariance;\n","import __var_0__ from './main.js';\n/**\n\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n/**\n* Compute a moving unbiased sample covariance incrementally.\n*\n* @module @stdlib/stats/incr/mcovariance\n*\n* @example\n* var incrmcovariance = require( '@stdlib/stats/incr/mcovariance' );\n*\n* var accumulator = incrmcovariance( 3 );\n*\n* var v = accumulator();\n* // returns null\n*\n* v = accumulator( 2.0, 1.0 );\n* // returns 0.0\n*\n* v = accumulator( -5.0, 3.14 );\n* // returns ~-7.49\n*\n* v = accumulator( 3.0, -1.0 );\n* // returns -8.35\n*\n* v = accumulator( 5.0, -9.5 );\n* // returns -29.42\n*\n* v = accumulator();\n* // returns -29.42\n*/\n\n// MODULES //\nvar incrmcovariance = __var_0__;\n\n\n// EXPORTS //\nexport default incrmcovariance;\n"]}