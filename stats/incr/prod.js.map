{"version":3,"sources":["@stdlib/stats/incr/prod/lib/main.js","@stdlib/stats/incr/prod/lib/index.js"],"names":["frexp","__var_0__","ldexp","__var_1__","PARTS","incrprod","frac","prod","exp","x","arguments","length"],"mappings":"oGAuBA,IAAIA,EAAQC,EACRC,EAAQC,EAMRC,EAAQ,CAAE,EAAK,GAoCnB,SAASC,IACR,IAAIC,EACAC,EACAC,EAMJ,OAHAF,EAAO,GACPE,EAAM,EAWN,SAAsBC,GACrB,GAA0B,IAArBC,UAAUC,OACd,YAAkB,IAATJ,EAAoB,KAAOA,EAGrCP,EAAOI,EAAOK,GAGdH,GAAQF,EAAO,GAGfI,GAAOJ,EAAO,GAGTE,GAAQ,IAAOA,EAAO,KAC1BN,EAAOI,EAAOE,GACdA,EAAOF,EAAO,GACdI,GAAOJ,EAAO,IAGf,OADAG,EAAOL,EAAOI,EAAME,IC1DnB,IAACH,EAAWJ","sourcesContent":["import __var_0__ from '@stdlib/math/base/special/frexp';\nimport __var_1__ from '@stdlib/math/base/special/ldexp';\n/**\n\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\nvar frexp = __var_0__;\nvar ldexp = __var_1__;\n\n\n// VARIABLES //\n\n// `frexp` workspace:\nvar PARTS = [ 0.0, 0 ]; // WARNING: not thread safe\n\n\n// MAIN //\n\n/**\n* Returns an accumulator function which incrementally computes a product.\n*\n* ## Method\n*\n* To avoid overflow/underflow, we store the fractional and exponent parts of intermediate results separately. By keeping a normalized fraction, we prevent underflow/overflow of the fraction. Underflow of the exponent is impossible, as IEEE 754 floating-point exponents are integer values. Overflow of the exponent is possible, but highly unlikely. In the worst case, an intermediate exponent is greater than the minimum safe integer, and adding the exponent of an incoming value does not change the intermediate result. While incorrect, such behavior does not lead to exponent overflow.\n*\n* While intermediate results are largely immune to overflow and not subject to underflow, this does not mean that returned results will never be zero or infinite. In fact, zero (underflow) and infinite (overflow) results may be transient (i.e., infinity followed by a finite number).\n*\n*\n* ## References\n*\n* -   Ueberhuber, Christoph W. 1997. _Numerical Computation 1: Methods, Software, and Analysis_. Springer-Verlag Berlin Heidelberg. doi:[10.1007/978-3-642-59118-1](https://doi.org/10.1007/978-3-642-59118-1).\n*\n* @returns {Function} accumulator function\n*\n* @example\n* var accumulator = incrprod();\n*\n* var prod = accumulator();\n* // returns null\n*\n* prod = accumulator( 2.0 );\n* // returns 2.0\n*\n* prod = accumulator( -5.0 );\n* // returns -10.0\n*\n* prod = accumulator();\n* // returns -10.0\n*/\nfunction incrprod() {\n\tvar frac;\n\tvar prod;\n\tvar exp;\n\n\t// Initial product is 1.0, which may be split into its fractional and exponent parts (0.5 x 2.0**1 = 1.0):\n\tfrac = 0.5;\n\texp = 1.0;\n\n\treturn accumulator;\n\n\t/**\n\t* If provided a value, the accumulator function returns an updated product. If not provided a value, the accumulator function returns the current product.\n\t*\n\t* @private\n\t* @param {number} [x] - new value\n\t* @returns {(number|null)} product or null\n\t*/\n\tfunction accumulator( x ) {\n\t\tif ( arguments.length === 0 ) {\n\t\t\treturn ( prod === void 0 ) ? null : prod;\n\t\t}\n\t\t// Split the incoming value into a normalized fraction and exponent:\n\t\tfrexp( PARTS, x );\n\n\t\t// Update the accumulated fraction:\n\t\tfrac *= PARTS[ 0 ];\n\n\t\t// Update the accumulated exponent:\n\t\texp += PARTS[ 1 ];\n\n\t\t// Ensure fraction remains normalized to avoid overflow/underflow...\n\t\tif ( frac > -0.5 && frac < 0.5 ) {\n\t\t\tfrexp( PARTS, frac );\n\t\t\tfrac = PARTS[ 0 ];\n\t\t\texp += PARTS[ 1 ];\n\t\t}\n\t\tprod = ldexp( frac, exp );\n\t\treturn prod;\n\t}\n}\n\n\n// EXPORTS //\nexport default incrprod;\n","import __var_0__ from './main.js';\n/**\n\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n/**\n* Compute a product incrementally.\n*\n* @module @stdlib/stats/incr/prod\n*\n* @example\n* var incrprod = require( '@stdlib/stats/incr/prod' );\n*\n* var accumulator = incrprod();\n*\n* var prod = accumulator();\n* // returns null\n*\n* prod = accumulator( 2.0 );\n* // returns 2.0\n*\n* prod = accumulator( -5.0 );\n* // returns -10.0\n*\n* prod = accumulator();\n* // returns -10.0\n*/\n\n// MODULES //\nvar incrprod = __var_0__;\n\n\n// EXPORTS //\nexport default incrprod;\n"]}